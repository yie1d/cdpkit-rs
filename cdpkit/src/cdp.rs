// Auto-generated from Chrome DevTools Protocol
// Generated at: 2026-02-06 10:38:35 +08:00
// DO NOT EDIT MANUALLY  OvO

#![allow(dead_code, unused_imports, clippy::all)]

use crate::{Command, CDP};
use futures::stream::Stream;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

/// CDP Protocol version (major.minor)
pub const CDP_VERSION: &str = "1.3";

pub mod accessibility {
    use super::*;

    /// Unique accessibility node identifier.
    pub type AXNodeId = String;

    /// Enum of possible property types.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AXValueType {
        #[serde(rename = "boolean")]
        Boolean,
        #[serde(rename = "tristate")]
        Tristate,
        #[serde(rename = "booleanOrUndefined")]
        BooleanOrUndefined,
        #[serde(rename = "idref")]
        Idref,
        #[serde(rename = "idrefList")]
        IdrefList,
        #[serde(rename = "integer")]
        Integer,
        #[serde(rename = "node")]
        Node,
        #[serde(rename = "nodeList")]
        NodeList,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "computedString")]
        ComputedString,
        #[serde(rename = "token")]
        Token,
        #[serde(rename = "tokenList")]
        TokenList,
        #[serde(rename = "domRelation")]
        DomRelation,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "internalRole")]
        InternalRole,
        #[serde(rename = "valueUndefined")]
        ValueUndefined,
    }
    impl From<&str> for AXValueType {
        fn from(s: &str) -> Self {
            match s {
                "boolean" => Self::Boolean,
                "tristate" => Self::Tristate,
                "booleanOrUndefined" => Self::BooleanOrUndefined,
                "idref" => Self::Idref,
                "idrefList" => Self::IdrefList,
                "integer" => Self::Integer,
                "node" => Self::Node,
                "nodeList" => Self::NodeList,
                "number" => Self::Number,
                "string" => Self::String,
                "computedString" => Self::ComputedString,
                "token" => Self::Token,
                "tokenList" => Self::TokenList,
                "domRelation" => Self::DomRelation,
                "role" => Self::Role,
                "internalRole" => Self::InternalRole,
                "valueUndefined" => Self::ValueUndefined,
                _ => Self::Boolean,
            }
        }
    }
    impl From<String> for AXValueType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of possible property sources.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AXValueSourceType {
        #[serde(rename = "attribute")]
        Attribute,
        #[serde(rename = "implicit")]
        Implicit,
        #[serde(rename = "style")]
        Style,
        #[serde(rename = "contents")]
        Contents,
        #[serde(rename = "placeholder")]
        Placeholder,
        #[serde(rename = "relatedElement")]
        RelatedElement,
    }
    impl From<&str> for AXValueSourceType {
        fn from(s: &str) -> Self {
            match s {
                "attribute" => Self::Attribute,
                "implicit" => Self::Implicit,
                "style" => Self::Style,
                "contents" => Self::Contents,
                "placeholder" => Self::Placeholder,
                "relatedElement" => Self::RelatedElement,
                _ => Self::Attribute,
            }
        }
    }
    impl From<String> for AXValueSourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AXValueNativeSourceType {
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "figcaption")]
        Figcaption,
        #[serde(rename = "label")]
        Label,
        #[serde(rename = "labelfor")]
        Labelfor,
        #[serde(rename = "labelwrapped")]
        Labelwrapped,
        #[serde(rename = "legend")]
        Legend,
        #[serde(rename = "rubyannotation")]
        Rubyannotation,
        #[serde(rename = "tablecaption")]
        Tablecaption,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "other")]
        Other,
    }
    impl From<&str> for AXValueNativeSourceType {
        fn from(s: &str) -> Self {
            match s {
                "description" => Self::Description,
                "figcaption" => Self::Figcaption,
                "label" => Self::Label,
                "labelfor" => Self::Labelfor,
                "labelwrapped" => Self::Labelwrapped,
                "legend" => Self::Legend,
                "rubyannotation" => Self::Rubyannotation,
                "tablecaption" => Self::Tablecaption,
                "title" => Self::Title,
                "other" => Self::Other,
                _ => Self::Description,
            }
        }
    }
    impl From<String> for AXValueNativeSourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A single source for a computed AX property.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AXValueSource {
        /// What type of source this is.
        #[serde(rename = "type")]
        pub type_: AXValueSourceType,
        /// The value of this property source.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<AXValue>,
        /// The name of the relevant attribute, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub attribute: Option<String>,
        /// The value of the relevant attribute, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "attributeValue")]
        pub attribute_value: Option<AXValue>,
        /// Whether this source is superseded by a higher priority source.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub superseded: Option<bool>,
        /// The native markup source for this value, e.g. a `<label>` element.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nativeSource")]
        pub native_source: Option<AXValueNativeSourceType>,
        /// The value, such as a node or node list, of the native source.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nativeSourceValue")]
        pub native_source_value: Option<AXValue>,
        /// Whether the value for this property is invalid.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub invalid: Option<bool>,
        /// Reason for the value being invalid, if it is.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "invalidReason")]
        pub invalid_reason: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AXRelatedNode {
        /// The BackendNodeId of the related DOM node.
        #[serde(rename = "backendDOMNodeId")]
        pub backend_dom_node_id: dom::BackendNodeId,
        /// The IDRef value provided, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub idref: Option<String>,
        /// The text alternative of this node in the current context.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub text: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AXProperty {
        /// The name of this property.
        pub name: AXPropertyName,
        /// The value of this property.
        pub value: AXValue,
    }

    /// A single computed AX property.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AXValue {
        /// The type of this value.
        #[serde(rename = "type")]
        pub type_: AXValueType,
        /// The computed value of this property.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<serde_json::Value>,
        /// One or more related nodes, if applicable.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "relatedNodes")]
        pub related_nodes: Option<Vec<AXRelatedNode>>,
        /// The sources which contributed to the computation of this property.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub sources: Option<Vec<AXValueSource>>,
    }

    /// Values of AXProperty name: - from 'busy' to 'roledescription': states which apply to every AX node - from 'live' to 'root': attributes which apply to nodes in live regions - from 'autocomplete' to 'valuetext': attributes which apply to widgets - from 'checked' to 'selected': states which apply to widgets - from 'activedescendant' to 'owns': relationships between elements other than parent/child/sibling - from 'activeFullscreenElement' to 'uninteresting': reasons why this noode is hidden
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AXPropertyName {
        #[serde(rename = "actions")]
        Actions,
        #[serde(rename = "busy")]
        Busy,
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "editable")]
        Editable,
        #[serde(rename = "focusable")]
        Focusable,
        #[serde(rename = "focused")]
        Focused,
        #[serde(rename = "hidden")]
        Hidden,
        #[serde(rename = "hiddenRoot")]
        HiddenRoot,
        #[serde(rename = "invalid")]
        Invalid,
        #[serde(rename = "keyshortcuts")]
        Keyshortcuts,
        #[serde(rename = "settable")]
        Settable,
        #[serde(rename = "roledescription")]
        Roledescription,
        #[serde(rename = "live")]
        Live,
        #[serde(rename = "atomic")]
        Atomic,
        #[serde(rename = "relevant")]
        Relevant,
        #[serde(rename = "root")]
        Root,
        #[serde(rename = "autocomplete")]
        Autocomplete,
        #[serde(rename = "hasPopup")]
        HasPopup,
        #[serde(rename = "level")]
        Level,
        #[serde(rename = "multiselectable")]
        Multiselectable,
        #[serde(rename = "orientation")]
        Orientation,
        #[serde(rename = "multiline")]
        Multiline,
        #[serde(rename = "readonly")]
        Readonly,
        #[serde(rename = "required")]
        Required,
        #[serde(rename = "valuemin")]
        Valuemin,
        #[serde(rename = "valuemax")]
        Valuemax,
        #[serde(rename = "valuetext")]
        Valuetext,
        #[serde(rename = "checked")]
        Checked,
        #[serde(rename = "expanded")]
        Expanded,
        #[serde(rename = "modal")]
        Modal,
        #[serde(rename = "pressed")]
        Pressed,
        #[serde(rename = "selected")]
        Selected,
        #[serde(rename = "activedescendant")]
        Activedescendant,
        #[serde(rename = "controls")]
        Controls,
        #[serde(rename = "describedby")]
        Describedby,
        #[serde(rename = "details")]
        Details,
        #[serde(rename = "errormessage")]
        Errormessage,
        #[serde(rename = "flowto")]
        Flowto,
        #[serde(rename = "labelledby")]
        Labelledby,
        #[serde(rename = "owns")]
        Owns,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "activeFullscreenElement")]
        ActiveFullscreenElement,
        #[serde(rename = "activeModalDialog")]
        ActiveModalDialog,
        #[serde(rename = "activeAriaModalDialog")]
        ActiveAriaModalDialog,
        #[serde(rename = "ariaHiddenElement")]
        AriaHiddenElement,
        #[serde(rename = "ariaHiddenSubtree")]
        AriaHiddenSubtree,
        #[serde(rename = "emptyAlt")]
        EmptyAlt,
        #[serde(rename = "emptyText")]
        EmptyText,
        #[serde(rename = "inertElement")]
        InertElement,
        #[serde(rename = "inertSubtree")]
        InertSubtree,
        #[serde(rename = "labelContainer")]
        LabelContainer,
        #[serde(rename = "labelFor")]
        LabelFor,
        #[serde(rename = "notRendered")]
        NotRendered,
        #[serde(rename = "notVisible")]
        NotVisible,
        #[serde(rename = "presentationalRole")]
        PresentationalRole,
        #[serde(rename = "probablyPresentational")]
        ProbablyPresentational,
        #[serde(rename = "inactiveCarouselTabContent")]
        InactiveCarouselTabContent,
        #[serde(rename = "uninteresting")]
        Uninteresting,
    }
    impl From<&str> for AXPropertyName {
        fn from(s: &str) -> Self {
            match s {
                "actions" => Self::Actions,
                "busy" => Self::Busy,
                "disabled" => Self::Disabled,
                "editable" => Self::Editable,
                "focusable" => Self::Focusable,
                "focused" => Self::Focused,
                "hidden" => Self::Hidden,
                "hiddenRoot" => Self::HiddenRoot,
                "invalid" => Self::Invalid,
                "keyshortcuts" => Self::Keyshortcuts,
                "settable" => Self::Settable,
                "roledescription" => Self::Roledescription,
                "live" => Self::Live,
                "atomic" => Self::Atomic,
                "relevant" => Self::Relevant,
                "root" => Self::Root,
                "autocomplete" => Self::Autocomplete,
                "hasPopup" => Self::HasPopup,
                "level" => Self::Level,
                "multiselectable" => Self::Multiselectable,
                "orientation" => Self::Orientation,
                "multiline" => Self::Multiline,
                "readonly" => Self::Readonly,
                "required" => Self::Required,
                "valuemin" => Self::Valuemin,
                "valuemax" => Self::Valuemax,
                "valuetext" => Self::Valuetext,
                "checked" => Self::Checked,
                "expanded" => Self::Expanded,
                "modal" => Self::Modal,
                "pressed" => Self::Pressed,
                "selected" => Self::Selected,
                "activedescendant" => Self::Activedescendant,
                "controls" => Self::Controls,
                "describedby" => Self::Describedby,
                "details" => Self::Details,
                "errormessage" => Self::Errormessage,
                "flowto" => Self::Flowto,
                "labelledby" => Self::Labelledby,
                "owns" => Self::Owns,
                "url" => Self::Url,
                "activeFullscreenElement" => Self::ActiveFullscreenElement,
                "activeModalDialog" => Self::ActiveModalDialog,
                "activeAriaModalDialog" => Self::ActiveAriaModalDialog,
                "ariaHiddenElement" => Self::AriaHiddenElement,
                "ariaHiddenSubtree" => Self::AriaHiddenSubtree,
                "emptyAlt" => Self::EmptyAlt,
                "emptyText" => Self::EmptyText,
                "inertElement" => Self::InertElement,
                "inertSubtree" => Self::InertSubtree,
                "labelContainer" => Self::LabelContainer,
                "labelFor" => Self::LabelFor,
                "notRendered" => Self::NotRendered,
                "notVisible" => Self::NotVisible,
                "presentationalRole" => Self::PresentationalRole,
                "probablyPresentational" => Self::ProbablyPresentational,
                "inactiveCarouselTabContent" => Self::InactiveCarouselTabContent,
                "uninteresting" => Self::Uninteresting,
                _ => Self::Actions,
            }
        }
    }
    impl From<String> for AXPropertyName {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A node in the accessibility tree.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AXNode {
        /// Unique identifier for this node.
        #[serde(rename = "nodeId")]
        pub node_id: AXNodeId,
        /// Whether this node is ignored for accessibility
        pub ignored: bool,
        /// Collection of reasons why this node is hidden.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ignoredReasons")]
        pub ignored_reasons: Option<Vec<AXProperty>>,
        /// This `Node`'s role, whether explicit or implicit.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub role: Option<AXValue>,
        /// This `Node`'s Chrome raw role.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "chromeRole")]
        pub chrome_role: Option<AXValue>,
        /// The accessible name for this `Node`.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<AXValue>,
        /// The accessible description for this `Node`.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<AXValue>,
        /// The value for this `Node`.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<AXValue>,
        /// All other properties
        #[serde(skip_serializing_if = "Option::is_none")]
        pub properties: Option<Vec<AXProperty>>,
        /// ID for this node's parent.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentId")]
        pub parent_id: Option<AXNodeId>,
        /// IDs for each of this node's child nodes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "childIds")]
        pub child_ids: Option<Vec<AXNodeId>>,
        /// The backend ID for the associated DOM node, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendDOMNodeId")]
        pub backend_dom_node_id: Option<dom::BackendNodeId>,
        /// The frame ID for the frame associated with this nodes document.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
    }

    /// Disables the accessibility domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Accessibility.disable";
    }

    /// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls. This turns on accessibility for the page, which can impact performance until accessibility is disabled.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Accessibility.enable";
    }

    /// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPartialAxTree {
        /// Identifier of the node to get the partial accessibility tree for.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
        /// Identifier of the backend node to get the partial accessibility tree for.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// JavaScript object id of the node wrapper to get the partial accessibility tree for.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// Whether to fetch this node's ancestors, siblings and children. Defaults to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fetchRelatives")]
        fetch_relatives: Option<bool>,
    }

    impl GetPartialAxTree {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
                fetch_relatives: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_fetch_relatives(mut self, fetch_relatives: impl Into<bool>) -> Self {
            self.fetch_relatives = Some(fetch_relatives.into());
            self
        }
    }

    impl Command for GetPartialAxTree {
        type Response = GetPartialAxTreeResult;
        const METHOD: &'static str = "Accessibility.getPartialAXTree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPartialAxTreeResult {
        /// The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and children, if requested.
        pub nodes: Vec<AXNode>,
    }

    /// Fetches the entire accessibility tree for the root Document
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFullAxTree {
        /// The maximum depth at which descendants of the root node should be retrieved. If omitted, the full tree is returned.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// The frame for whose document the AX tree should be retrieved. If omitted, the root frame is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
    }

    impl GetFullAxTree {
        pub fn new() -> Self {
            Self {
                depth: None,
                frame_id: None,
            }
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for GetFullAxTree {
        type Response = GetFullAxTreeResult;
        const METHOD: &'static str = "Accessibility.getFullAXTree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFullAxTreeResult {
        pub nodes: Vec<AXNode>,
    }

    /// Fetches the root node. Requires `enable()` to have been called previously.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRootAxNode {
        /// The frame in whose document the node resides. If omitted, the root frame is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
    }

    impl GetRootAxNode {
        pub fn new() -> Self {
            Self { frame_id: None }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for GetRootAxNode {
        type Response = GetRootAxNodeResult;
        const METHOD: &'static str = "Accessibility.getRootAXNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRootAxNodeResult {
        pub node: AXNode,
    }

    /// Fetches a node and all ancestors up to and including the root. Requires `enable()` to have been called previously.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAxNodeAndAncestors {
        /// Identifier of the node to get.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
        /// Identifier of the backend node to get.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// JavaScript object id of the node wrapper to get.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl GetAxNodeAndAncestors {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for GetAxNodeAndAncestors {
        type Response = GetAxNodeAndAncestorsResult;
        const METHOD: &'static str = "Accessibility.getAXNodeAndAncestors";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAxNodeAndAncestorsResult {
        pub nodes: Vec<AXNode>,
    }

    /// Fetches a particular accessibility node by AXNodeId. Requires `enable()` to have been called previously.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetChildAxNodes {
        id: AXNodeId,
        /// The frame in whose document the node resides. If omitted, the root frame is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
    }

    impl GetChildAxNodes {
        pub fn new(id: impl Into<AXNodeId>) -> Self {
            Self {
                id: id.into(),
                frame_id: None,
            }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for GetChildAxNodes {
        type Response = GetChildAxNodesResult;
        const METHOD: &'static str = "Accessibility.getChildAXNodes";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetChildAxNodesResult {
        pub nodes: Vec<AXNode>,
    }

    /// Query a DOM node's accessibility subtree for accessible name and role. This command computes the name and role for all nodes in the subtree, including those that are ignored for accessibility, and returns those that match the specified name and role. If no DOM node is specified, or the DOM node does not exist, the command returns an error. If neither `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QueryAxTree {
        /// Identifier of the node for the root to query.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
        /// Identifier of the backend node for the root to query.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// JavaScript object id of the node wrapper for the root to query.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// Find nodes with this computed name.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "accessibleName")]
        accessible_name: Option<String>,
        /// Find nodes with this computed role.
        #[serde(skip_serializing_if = "Option::is_none")]
        role: Option<String>,
    }

    impl QueryAxTree {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
                accessible_name: None,
                role: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_accessible_name(mut self, accessible_name: impl Into<String>) -> Self {
            self.accessible_name = Some(accessible_name.into());
            self
        }

        pub fn with_role(mut self, role: impl Into<String>) -> Self {
            self.role = Some(role.into());
            self
        }
    }

    impl Command for QueryAxTree {
        type Response = QueryAxTreeResult;
        const METHOD: &'static str = "Accessibility.queryAXTree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QueryAxTreeResult {
        /// A list of `Accessibility.AXNode` matching the specified attributes, including nodes that are ignored for accessibility.
        pub nodes: Vec<AXNode>,
    }

    /// The loadComplete event mirrors the load complete event sent by the browser to assistive technology when the web page has finished loading.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadComplete {
        /// New document root node.
        pub root: AXNode,
    }

    impl LoadComplete {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Accessibility.loadComplete")
        }
    }

    /// The nodesUpdated event is sent every time a previously requested node has changed the in tree.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodesUpdated {
        /// Updated node data.
        pub nodes: Vec<AXNode>,
    }

    impl NodesUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Accessibility.nodesUpdated")
        }
    }
}

pub mod animation {
    use super::*;

    /// Animation instance.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Animation {
        /// `Animation`'s id.
        pub id: String,
        /// `Animation`'s name.
        pub name: String,
        /// `Animation`'s internal paused state.
        #[serde(rename = "pausedState")]
        pub paused_state: bool,
        /// `Animation`'s play state.
        #[serde(rename = "playState")]
        pub play_state: String,
        /// `Animation`'s playback rate.
        #[serde(rename = "playbackRate")]
        pub playback_rate: f64,
        /// `Animation`'s start time. Milliseconds for time based animations and percentage [0 - 100] for scroll driven animations (i.e. when viewOrScrollTimeline exists).
        #[serde(rename = "startTime")]
        pub start_time: f64,
        /// `Animation`'s current time.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
        /// Animation type of `Animation`.
        #[serde(rename = "type")]
        pub type_: String,
        /// `Animation`'s source animation node.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub source: Option<AnimationEffect>,
        /// A unique ID for `Animation` representing the sources that triggered this CSS animation/transition.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cssId")]
        pub css_id: Option<String>,
        /// View or scroll timeline
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "viewOrScrollTimeline")]
        pub view_or_scroll_timeline: Option<ViewOrScrollTimeline>,
    }

    /// Timeline instance
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ViewOrScrollTimeline {
        /// Scroll container node
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceNodeId")]
        pub source_node_id: Option<dom::BackendNodeId>,
        /// Represents the starting scroll position of the timeline as a length offset in pixels from scroll origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "startOffset")]
        pub start_offset: Option<f64>,
        /// Represents the ending scroll position of the timeline as a length offset in pixels from scroll origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "endOffset")]
        pub end_offset: Option<f64>,
        /// The element whose principal box's visibility in the scrollport defined the progress of the timeline. Does not exist for animations with ScrollTimeline
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "subjectNodeId")]
        pub subject_node_id: Option<dom::BackendNodeId>,
        /// Orientation of the scroll
        pub axis: dom::ScrollOrientation,
    }

    /// AnimationEffect instance
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AnimationEffect {
        /// `AnimationEffect`'s delay.
        pub delay: f64,
        /// `AnimationEffect`'s end delay.
        #[serde(rename = "endDelay")]
        pub end_delay: f64,
        /// `AnimationEffect`'s iteration start.
        #[serde(rename = "iterationStart")]
        pub iteration_start: f64,
        /// `AnimationEffect`'s iterations. Omitted if the value is infinite.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub iterations: Option<f64>,
        /// `AnimationEffect`'s iteration duration. Milliseconds for time based animations and percentage [0 - 100] for scroll driven animations (i.e. when viewOrScrollTimeline exists).
        pub duration: f64,
        /// `AnimationEffect`'s playback direction.
        pub direction: String,
        /// `AnimationEffect`'s fill mode.
        pub fill: String,
        /// `AnimationEffect`'s target node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<dom::BackendNodeId>,
        /// `AnimationEffect`'s keyframes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keyframesRule")]
        pub keyframes_rule: Option<KeyframesRule>,
        /// `AnimationEffect`'s timing function.
        pub easing: String,
    }

    /// Keyframes Rule
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct KeyframesRule {
        /// CSS keyframed animation's name.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// List of animation keyframes.
        pub keyframes: Vec<KeyframeStyle>,
    }

    /// Keyframe Style
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct KeyframeStyle {
        /// Keyframe's time offset.
        pub offset: String,
        /// `AnimationEffect`'s timing function.
        pub easing: String,
    }

    /// Disables animation domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Animation.disable";
    }

    /// Enables animation domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Animation.enable";
    }

    /// Returns the current time of the an animation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCurrentTime {
        /// Id of animation.
        id: String,
    }

    impl GetCurrentTime {
        pub fn new(id: impl Into<String>) -> Self {
            Self { id: id.into() }
        }
    }

    impl Command for GetCurrentTime {
        type Response = GetCurrentTimeResult;
        const METHOD: &'static str = "Animation.getCurrentTime";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCurrentTimeResult {
        /// Current time of the page.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
    }

    /// Gets the playback rate of the document timeline.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPlaybackRate {}

    impl GetPlaybackRate {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetPlaybackRate {
        type Response = GetPlaybackRateResult;
        const METHOD: &'static str = "Animation.getPlaybackRate";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPlaybackRateResult {
        /// Playback rate for animations on page.
        #[serde(rename = "playbackRate")]
        pub playback_rate: f64,
    }

    /// Releases a set of animations to no longer be manipulated.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReleaseAnimations {
        /// List of animation ids to seek.
        animations: Vec<String>,
    }

    impl ReleaseAnimations {
        pub fn new(animations: impl Into<Vec<String>>) -> Self {
            Self {
                animations: animations.into(),
            }
        }
    }

    impl Command for ReleaseAnimations {
        type Response = ();
        const METHOD: &'static str = "Animation.releaseAnimations";
    }

    /// Gets the remote object of the Animation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveAnimation {
        /// Animation id.
        #[serde(rename = "animationId")]
        animation_id: String,
    }

    impl ResolveAnimation {
        pub fn new(animation_id: impl Into<String>) -> Self {
            Self {
                animation_id: animation_id.into(),
            }
        }
    }

    impl Command for ResolveAnimation {
        type Response = ResolveAnimationResult;
        const METHOD: &'static str = "Animation.resolveAnimation";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveAnimationResult {
        /// Corresponding remote object.
        #[serde(rename = "remoteObject")]
        pub remote_object: runtime::RemoteObject,
    }

    /// Seek a set of animations to a particular time within each animation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SeekAnimations {
        /// List of animation ids to seek.
        animations: Vec<String>,
        /// Set the current time of each animation.
        #[serde(rename = "currentTime")]
        current_time: f64,
    }

    impl SeekAnimations {
        pub fn new(animations: impl Into<Vec<String>>, current_time: impl Into<f64>) -> Self {
            Self {
                animations: animations.into(),
                current_time: current_time.into(),
            }
        }
    }

    impl Command for SeekAnimations {
        type Response = ();
        const METHOD: &'static str = "Animation.seekAnimations";
    }

    /// Sets the paused state of a set of animations.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPaused {
        /// Animations to set the pause state of.
        animations: Vec<String>,
        /// Paused state to set to.
        paused: bool,
    }

    impl SetPaused {
        pub fn new(animations: impl Into<Vec<String>>, paused: impl Into<bool>) -> Self {
            Self {
                animations: animations.into(),
                paused: paused.into(),
            }
        }
    }

    impl Command for SetPaused {
        type Response = ();
        const METHOD: &'static str = "Animation.setPaused";
    }

    /// Sets the playback rate of the document timeline.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPlaybackRate {
        /// Playback rate for animations on page
        #[serde(rename = "playbackRate")]
        playback_rate: f64,
    }

    impl SetPlaybackRate {
        pub fn new(playback_rate: impl Into<f64>) -> Self {
            Self {
                playback_rate: playback_rate.into(),
            }
        }
    }

    impl Command for SetPlaybackRate {
        type Response = ();
        const METHOD: &'static str = "Animation.setPlaybackRate";
    }

    /// Sets the timing of an animation node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetTiming {
        /// Animation id.
        #[serde(rename = "animationId")]
        animation_id: String,
        /// Duration of the animation.
        duration: f64,
        /// Delay of the animation.
        delay: f64,
    }

    impl SetTiming {
        pub fn new(
            animation_id: impl Into<String>,
            duration: impl Into<f64>,
            delay: impl Into<f64>,
        ) -> Self {
            Self {
                animation_id: animation_id.into(),
                duration: duration.into(),
                delay: delay.into(),
            }
        }
    }

    impl Command for SetTiming {
        type Response = ();
        const METHOD: &'static str = "Animation.setTiming";
    }

    /// Event for when an animation has been cancelled.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AnimationCanceled {
        /// Id of the animation that was cancelled.
        pub id: String,
    }

    impl AnimationCanceled {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Animation.animationCanceled")
        }
    }

    /// Event for each animation that has been created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AnimationCreated {
        /// Id of the animation that was created.
        pub id: String,
    }

    impl AnimationCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Animation.animationCreated")
        }
    }

    /// Event for animation that has been started.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AnimationStarted {
        /// Animation that was started.
        pub animation: Animation,
    }

    impl AnimationStarted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Animation.animationStarted")
        }
    }

    /// Event for animation that has been updated.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AnimationUpdated {
        /// Animation that was updated.
        pub animation: Animation,
    }

    impl AnimationUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Animation.animationUpdated")
        }
    }
}

pub mod audits {
    use super::*;

    /// Information about a cookie that is affected by an inspector issue.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AffectedCookie {
        /// The following three properties uniquely identify a cookie
        pub name: String,
        pub path: String,
        pub domain: String,
    }

    /// Information about a request that is affected by an inspector issue.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AffectedRequest {
        /// The unique request id.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestId")]
        pub request_id: Option<network::RequestId>,
        pub url: String,
    }

    /// Information about the frame affected by an inspector issue.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AffectedFrame {
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieExclusionReason {
        #[serde(rename = "ExcludeSameSiteUnspecifiedTreatedAsLax")]
        ExcludeSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "ExcludeSameSiteNoneInsecure")]
        ExcludeSameSiteNoneInsecure,
        #[serde(rename = "ExcludeSameSiteLax")]
        ExcludeSameSiteLax,
        #[serde(rename = "ExcludeSameSiteStrict")]
        ExcludeSameSiteStrict,
        #[serde(rename = "ExcludeDomainNonASCII")]
        ExcludeDomainNonAscii,
        #[serde(rename = "ExcludeThirdPartyCookieBlockedInFirstPartySet")]
        ExcludeThirdPartyCookieBlockedInFirstPartySet,
        #[serde(rename = "ExcludeThirdPartyPhaseout")]
        ExcludeThirdPartyPhaseout,
        #[serde(rename = "ExcludePortMismatch")]
        ExcludePortMismatch,
        #[serde(rename = "ExcludeSchemeMismatch")]
        ExcludeSchemeMismatch,
    }
    impl From<&str> for CookieExclusionReason {
        fn from(s: &str) -> Self {
            match s {
                "ExcludeSameSiteUnspecifiedTreatedAsLax" => {
                    Self::ExcludeSameSiteUnspecifiedTreatedAsLax
                }
                "ExcludeSameSiteNoneInsecure" => Self::ExcludeSameSiteNoneInsecure,
                "ExcludeSameSiteLax" => Self::ExcludeSameSiteLax,
                "ExcludeSameSiteStrict" => Self::ExcludeSameSiteStrict,
                "ExcludeDomainNonASCII" => Self::ExcludeDomainNonAscii,
                "ExcludeThirdPartyCookieBlockedInFirstPartySet" => {
                    Self::ExcludeThirdPartyCookieBlockedInFirstPartySet
                }
                "ExcludeThirdPartyPhaseout" => Self::ExcludeThirdPartyPhaseout,
                "ExcludePortMismatch" => Self::ExcludePortMismatch,
                "ExcludeSchemeMismatch" => Self::ExcludeSchemeMismatch,
                _ => Self::ExcludeSameSiteUnspecifiedTreatedAsLax,
            }
        }
    }
    impl From<String> for CookieExclusionReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieWarningReason {
        #[serde(rename = "WarnSameSiteUnspecifiedCrossSiteContext")]
        WarnSameSiteUnspecifiedCrossSiteContext,
        #[serde(rename = "WarnSameSiteNoneInsecure")]
        WarnSameSiteNoneInsecure,
        #[serde(rename = "WarnSameSiteUnspecifiedLaxAllowUnsafe")]
        WarnSameSiteUnspecifiedLaxAllowUnsafe,
        #[serde(rename = "WarnSameSiteStrictLaxDowngradeStrict")]
        WarnSameSiteStrictLaxDowngradeStrict,
        #[serde(rename = "WarnSameSiteStrictCrossDowngradeStrict")]
        WarnSameSiteStrictCrossDowngradeStrict,
        #[serde(rename = "WarnSameSiteStrictCrossDowngradeLax")]
        WarnSameSiteStrictCrossDowngradeLax,
        #[serde(rename = "WarnSameSiteLaxCrossDowngradeStrict")]
        WarnSameSiteLaxCrossDowngradeStrict,
        #[serde(rename = "WarnSameSiteLaxCrossDowngradeLax")]
        WarnSameSiteLaxCrossDowngradeLax,
        #[serde(rename = "WarnAttributeValueExceedsMaxSize")]
        WarnAttributeValueExceedsMaxSize,
        #[serde(rename = "WarnDomainNonASCII")]
        WarnDomainNonAscii,
        #[serde(rename = "WarnThirdPartyPhaseout")]
        WarnThirdPartyPhaseout,
        #[serde(rename = "WarnCrossSiteRedirectDowngradeChangesInclusion")]
        WarnCrossSiteRedirectDowngradeChangesInclusion,
        #[serde(rename = "WarnDeprecationTrialMetadata")]
        WarnDeprecationTrialMetadata,
        #[serde(rename = "WarnThirdPartyCookieHeuristic")]
        WarnThirdPartyCookieHeuristic,
    }
    impl From<&str> for CookieWarningReason {
        fn from(s: &str) -> Self {
            match s {
                "WarnSameSiteUnspecifiedCrossSiteContext" => {
                    Self::WarnSameSiteUnspecifiedCrossSiteContext
                }
                "WarnSameSiteNoneInsecure" => Self::WarnSameSiteNoneInsecure,
                "WarnSameSiteUnspecifiedLaxAllowUnsafe" => {
                    Self::WarnSameSiteUnspecifiedLaxAllowUnsafe
                }
                "WarnSameSiteStrictLaxDowngradeStrict" => {
                    Self::WarnSameSiteStrictLaxDowngradeStrict
                }
                "WarnSameSiteStrictCrossDowngradeStrict" => {
                    Self::WarnSameSiteStrictCrossDowngradeStrict
                }
                "WarnSameSiteStrictCrossDowngradeLax" => Self::WarnSameSiteStrictCrossDowngradeLax,
                "WarnSameSiteLaxCrossDowngradeStrict" => Self::WarnSameSiteLaxCrossDowngradeStrict,
                "WarnSameSiteLaxCrossDowngradeLax" => Self::WarnSameSiteLaxCrossDowngradeLax,
                "WarnAttributeValueExceedsMaxSize" => Self::WarnAttributeValueExceedsMaxSize,
                "WarnDomainNonASCII" => Self::WarnDomainNonAscii,
                "WarnThirdPartyPhaseout" => Self::WarnThirdPartyPhaseout,
                "WarnCrossSiteRedirectDowngradeChangesInclusion" => {
                    Self::WarnCrossSiteRedirectDowngradeChangesInclusion
                }
                "WarnDeprecationTrialMetadata" => Self::WarnDeprecationTrialMetadata,
                "WarnThirdPartyCookieHeuristic" => Self::WarnThirdPartyCookieHeuristic,
                _ => Self::WarnSameSiteUnspecifiedCrossSiteContext,
            }
        }
    }
    impl From<String> for CookieWarningReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieOperation {
        #[serde(rename = "SetCookie")]
        SetCookie,
        #[serde(rename = "ReadCookie")]
        ReadCookie,
    }
    impl From<&str> for CookieOperation {
        fn from(s: &str) -> Self {
            match s {
                "SetCookie" => Self::SetCookie,
                "ReadCookie" => Self::ReadCookie,
                _ => Self::SetCookie,
            }
        }
    }
    impl From<String> for CookieOperation {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Represents the category of insight that a cookie issue falls under.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InsightType {
        #[serde(rename = "GitHubResource")]
        GitHubResource,
        #[serde(rename = "GracePeriod")]
        GracePeriod,
        #[serde(rename = "Heuristics")]
        Heuristics,
    }
    impl From<&str> for InsightType {
        fn from(s: &str) -> Self {
            match s {
                "GitHubResource" => Self::GitHubResource,
                "GracePeriod" => Self::GracePeriod,
                "Heuristics" => Self::Heuristics,
                _ => Self::GitHubResource,
            }
        }
    }
    impl From<String> for InsightType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Information about the suggested solution to a cookie issue.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CookieIssueInsight {
        #[serde(rename = "type")]
        pub type_: InsightType,
        /// Link to table entry in third-party cookie migration readiness list.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tableEntryUrl")]
        pub table_entry_url: Option<String>,
    }

    /// This information is currently necessary, as the front-end has a difficult time finding a specific cookie. With this, we can convey specific error information without the cookie.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CookieIssueDetails {
        /// If AffectedCookie is not set then rawCookieLine contains the raw Set-Cookie header string. This hints at a problem where the cookie line is syntactically or semantically malformed in a way that no valid cookie could be created.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub cookie: Option<AffectedCookie>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rawCookieLine")]
        pub raw_cookie_line: Option<String>,
        #[serde(rename = "cookieWarningReasons")]
        pub cookie_warning_reasons: Vec<CookieWarningReason>,
        #[serde(rename = "cookieExclusionReasons")]
        pub cookie_exclusion_reasons: Vec<CookieExclusionReason>,
        /// Optionally identifies the site-for-cookies and the cookie url, which may be used by the front-end as additional context.
        pub operation: CookieOperation,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "siteForCookies")]
        pub site_for_cookies: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cookieUrl")]
        pub cookie_url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub request: Option<AffectedRequest>,
        /// The recommended solution to the issue.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub insight: Option<CookieIssueInsight>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MixedContentResolutionStatus {
        #[serde(rename = "MixedContentBlocked")]
        MixedContentBlocked,
        #[serde(rename = "MixedContentAutomaticallyUpgraded")]
        MixedContentAutomaticallyUpgraded,
        #[serde(rename = "MixedContentWarning")]
        MixedContentWarning,
    }
    impl From<&str> for MixedContentResolutionStatus {
        fn from(s: &str) -> Self {
            match s {
                "MixedContentBlocked" => Self::MixedContentBlocked,
                "MixedContentAutomaticallyUpgraded" => Self::MixedContentAutomaticallyUpgraded,
                "MixedContentWarning" => Self::MixedContentWarning,
                _ => Self::MixedContentBlocked,
            }
        }
    }
    impl From<String> for MixedContentResolutionStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MixedContentResourceType {
        #[serde(rename = "AttributionSrc")]
        AttributionSrc,
        #[serde(rename = "Audio")]
        Audio,
        #[serde(rename = "Beacon")]
        Beacon,
        #[serde(rename = "CSPReport")]
        CspReport,
        #[serde(rename = "Download")]
        Download,
        #[serde(rename = "EventSource")]
        EventSource,
        #[serde(rename = "Favicon")]
        Favicon,
        #[serde(rename = "Font")]
        Font,
        #[serde(rename = "Form")]
        Form,
        #[serde(rename = "Frame")]
        Frame,
        #[serde(rename = "Image")]
        Image,
        #[serde(rename = "Import")]
        Import,
        #[serde(rename = "JSON")]
        Json,
        #[serde(rename = "Manifest")]
        Manifest,
        #[serde(rename = "Ping")]
        Ping,
        #[serde(rename = "PluginData")]
        PluginData,
        #[serde(rename = "PluginResource")]
        PluginResource,
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "Resource")]
        Resource,
        #[serde(rename = "Script")]
        Script,
        #[serde(rename = "ServiceWorker")]
        ServiceWorker,
        #[serde(rename = "SharedWorker")]
        SharedWorker,
        #[serde(rename = "SpeculationRules")]
        SpeculationRules,
        #[serde(rename = "Stylesheet")]
        Stylesheet,
        #[serde(rename = "Track")]
        Track,
        #[serde(rename = "Video")]
        Video,
        #[serde(rename = "Worker")]
        Worker,
        #[serde(rename = "XMLHttpRequest")]
        XmlHttpRequest,
        #[serde(rename = "XSLT")]
        Xslt,
    }
    impl From<&str> for MixedContentResourceType {
        fn from(s: &str) -> Self {
            match s {
                "AttributionSrc" => Self::AttributionSrc,
                "Audio" => Self::Audio,
                "Beacon" => Self::Beacon,
                "CSPReport" => Self::CspReport,
                "Download" => Self::Download,
                "EventSource" => Self::EventSource,
                "Favicon" => Self::Favicon,
                "Font" => Self::Font,
                "Form" => Self::Form,
                "Frame" => Self::Frame,
                "Image" => Self::Image,
                "Import" => Self::Import,
                "JSON" => Self::Json,
                "Manifest" => Self::Manifest,
                "Ping" => Self::Ping,
                "PluginData" => Self::PluginData,
                "PluginResource" => Self::PluginResource,
                "Prefetch" => Self::Prefetch,
                "Resource" => Self::Resource,
                "Script" => Self::Script,
                "ServiceWorker" => Self::ServiceWorker,
                "SharedWorker" => Self::SharedWorker,
                "SpeculationRules" => Self::SpeculationRules,
                "Stylesheet" => Self::Stylesheet,
                "Track" => Self::Track,
                "Video" => Self::Video,
                "Worker" => Self::Worker,
                "XMLHttpRequest" => Self::XmlHttpRequest,
                "XSLT" => Self::Xslt,
                _ => Self::AttributionSrc,
            }
        }
    }
    impl From<String> for MixedContentResourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MixedContentIssueDetails {
        /// The type of resource causing the mixed content issue (css, js, iframe, form,...). Marked as optional because it is mapped to from blink::mojom::RequestContextType, which will be replaced by network::mojom::RequestDestination
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resourceType")]
        pub resource_type: Option<MixedContentResourceType>,
        /// The way the mixed content issue is being resolved.
        #[serde(rename = "resolutionStatus")]
        pub resolution_status: MixedContentResolutionStatus,
        /// The unsafe http url causing the mixed content issue.
        #[serde(rename = "insecureURL")]
        pub insecure_url: String,
        /// The url responsible for the call to an unsafe url.
        #[serde(rename = "mainResourceURL")]
        pub main_resource_url: String,
        /// The mixed content request. Does not always exist (e.g. for unsafe form submission urls).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub request: Option<AffectedRequest>,
        /// Optional because not every mixed content issue is necessarily linked to a frame.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub frame: Option<AffectedFrame>,
    }

    /// Enum indicating the reason a response has been blocked. These reasons are refinements of the net error BLOCKED_BY_RESPONSE.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum BlockedByResponseReason {
        #[serde(rename = "CoepFrameResourceNeedsCoepHeader")]
        CoepFrameResourceNeedsCoepHeader,
        #[serde(rename = "CoopSandboxedIFrameCannotNavigateToCoopPage")]
        CoopSandboxedIFrameCannotNavigateToCoopPage,
        #[serde(rename = "CorpNotSameOrigin")]
        CorpNotSameOrigin,
        #[serde(rename = "CorpNotSameOriginAfterDefaultedToSameOriginByCoep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        #[serde(rename = "CorpNotSameOriginAfterDefaultedToSameOriginByDip")]
        CorpNotSameOriginAfterDefaultedToSameOriginByDip,
        #[serde(rename = "CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip,
        #[serde(rename = "CorpNotSameSite")]
        CorpNotSameSite,
        #[serde(rename = "SRIMessageSignatureMismatch")]
        SriMessageSignatureMismatch,
    }
    impl From<&str> for BlockedByResponseReason {
        fn from(s: &str) -> Self {
            match s {
                "CoepFrameResourceNeedsCoepHeader" => Self::CoepFrameResourceNeedsCoepHeader,
                "CoopSandboxedIFrameCannotNavigateToCoopPage" => {
                    Self::CoopSandboxedIFrameCannotNavigateToCoopPage
                }
                "CorpNotSameOrigin" => Self::CorpNotSameOrigin,
                "CorpNotSameOriginAfterDefaultedToSameOriginByCoep" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByCoep
                }
                "CorpNotSameOriginAfterDefaultedToSameOriginByDip" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByDip
                }
                "CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip
                }
                "CorpNotSameSite" => Self::CorpNotSameSite,
                "SRIMessageSignatureMismatch" => Self::SriMessageSignatureMismatch,
                _ => Self::CoepFrameResourceNeedsCoepHeader,
            }
        }
    }
    impl From<String> for BlockedByResponseReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Details for a request that has been blocked with the BLOCKED_BY_RESPONSE code. Currently only used for COEP/COOP, but may be extended to include some CSP errors in the future.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BlockedByResponseIssueDetails {
        pub request: AffectedRequest,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentFrame")]
        pub parent_frame: Option<AffectedFrame>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "blockedFrame")]
        pub blocked_frame: Option<AffectedFrame>,
        pub reason: BlockedByResponseReason,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum HeavyAdResolutionStatus {
        #[serde(rename = "HeavyAdBlocked")]
        HeavyAdBlocked,
        #[serde(rename = "HeavyAdWarning")]
        HeavyAdWarning,
    }
    impl From<&str> for HeavyAdResolutionStatus {
        fn from(s: &str) -> Self {
            match s {
                "HeavyAdBlocked" => Self::HeavyAdBlocked,
                "HeavyAdWarning" => Self::HeavyAdWarning,
                _ => Self::HeavyAdBlocked,
            }
        }
    }
    impl From<String> for HeavyAdResolutionStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum HeavyAdReason {
        #[serde(rename = "NetworkTotalLimit")]
        NetworkTotalLimit,
        #[serde(rename = "CpuTotalLimit")]
        CpuTotalLimit,
        #[serde(rename = "CpuPeakLimit")]
        CpuPeakLimit,
    }
    impl From<&str> for HeavyAdReason {
        fn from(s: &str) -> Self {
            match s {
                "NetworkTotalLimit" => Self::NetworkTotalLimit,
                "CpuTotalLimit" => Self::CpuTotalLimit,
                "CpuPeakLimit" => Self::CpuPeakLimit,
                _ => Self::NetworkTotalLimit,
            }
        }
    }
    impl From<String> for HeavyAdReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HeavyAdIssueDetails {
        /// The resolution status, either blocking the content or warning.
        pub resolution: HeavyAdResolutionStatus,
        /// The reason the ad was blocked, total network or cpu or peak cpu.
        pub reason: HeavyAdReason,
        /// The frame that was blocked.
        pub frame: AffectedFrame,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContentSecurityPolicyViolationType {
        #[serde(rename = "kInlineViolation")]
        KInlineViolation,
        #[serde(rename = "kEvalViolation")]
        KEvalViolation,
        #[serde(rename = "kURLViolation")]
        KUrlViolation,
        #[serde(rename = "kSRIViolation")]
        KSriViolation,
        #[serde(rename = "kTrustedTypesSinkViolation")]
        KTrustedTypesSinkViolation,
        #[serde(rename = "kTrustedTypesPolicyViolation")]
        KTrustedTypesPolicyViolation,
        #[serde(rename = "kWasmEvalViolation")]
        KWasmEvalViolation,
    }
    impl From<&str> for ContentSecurityPolicyViolationType {
        fn from(s: &str) -> Self {
            match s {
                "kInlineViolation" => Self::KInlineViolation,
                "kEvalViolation" => Self::KEvalViolation,
                "kURLViolation" => Self::KUrlViolation,
                "kSRIViolation" => Self::KSriViolation,
                "kTrustedTypesSinkViolation" => Self::KTrustedTypesSinkViolation,
                "kTrustedTypesPolicyViolation" => Self::KTrustedTypesPolicyViolation,
                "kWasmEvalViolation" => Self::KWasmEvalViolation,
                _ => Self::KInlineViolation,
            }
        }
    }
    impl From<String> for ContentSecurityPolicyViolationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SourceCodeLocation {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptId")]
        pub script_id: Option<runtime::ScriptId>,
        pub url: String,
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContentSecurityPolicyIssueDetails {
        /// The url not included in allowed sources.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "blockedURL")]
        pub blocked_url: Option<String>,
        /// Specific directive that is violated, causing the CSP issue.
        #[serde(rename = "violatedDirective")]
        pub violated_directive: String,
        #[serde(rename = "isReportOnly")]
        pub is_report_only: bool,
        #[serde(rename = "contentSecurityPolicyViolationType")]
        pub content_security_policy_violation_type: ContentSecurityPolicyViolationType,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameAncestor")]
        pub frame_ancestor: Option<AffectedFrame>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: Option<SourceCodeLocation>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<dom::BackendNodeId>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SharedArrayBufferIssueType {
        #[serde(rename = "TransferIssue")]
        TransferIssue,
        #[serde(rename = "CreationIssue")]
        CreationIssue,
    }
    impl From<&str> for SharedArrayBufferIssueType {
        fn from(s: &str) -> Self {
            match s {
                "TransferIssue" => Self::TransferIssue,
                "CreationIssue" => Self::CreationIssue,
                _ => Self::TransferIssue,
            }
        }
    }
    impl From<String> for SharedArrayBufferIssueType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Details for a issue arising from an SAB being instantiated in, or transferred to a context that is not cross-origin isolated.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedArrayBufferIssueDetails {
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        #[serde(rename = "isWarning")]
        pub is_warning: bool,
        #[serde(rename = "type")]
        pub type_: SharedArrayBufferIssueType,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LowTextContrastIssueDetails {
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: dom::BackendNodeId,
        #[serde(rename = "violatingNodeSelector")]
        pub violating_node_selector: String,
        #[serde(rename = "contrastRatio")]
        pub contrast_ratio: f64,
        #[serde(rename = "thresholdAA")]
        pub threshold_aa: f64,
        #[serde(rename = "thresholdAAA")]
        pub threshold_aaa: f64,
        #[serde(rename = "fontSize")]
        pub font_size: String,
        #[serde(rename = "fontWeight")]
        pub font_weight: String,
    }

    /// Details for a CORS related issue, e.g. a warning or error related to CORS RFC1918 enforcement.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CorsIssueDetails {
        #[serde(rename = "corsErrorStatus")]
        pub cors_error_status: network::CorsErrorStatus,
        #[serde(rename = "isWarning")]
        pub is_warning: bool,
        pub request: AffectedRequest,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub location: Option<SourceCodeLocation>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "initiatorOrigin")]
        pub initiator_origin: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resourceIPAddressSpace")]
        pub resource_ip_address_space: Option<network::IPAddressSpace>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clientSecurityState")]
        pub client_security_state: Option<network::ClientSecurityState>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingIssueType {
        #[serde(rename = "PermissionPolicyDisabled")]
        PermissionPolicyDisabled,
        #[serde(rename = "UntrustworthyReportingOrigin")]
        UntrustworthyReportingOrigin,
        #[serde(rename = "InsecureContext")]
        InsecureContext,
        #[serde(rename = "InvalidHeader")]
        InvalidHeader,
        #[serde(rename = "InvalidRegisterTriggerHeader")]
        InvalidRegisterTriggerHeader,
        #[serde(rename = "SourceAndTriggerHeaders")]
        SourceAndTriggerHeaders,
        #[serde(rename = "SourceIgnored")]
        SourceIgnored,
        #[serde(rename = "TriggerIgnored")]
        TriggerIgnored,
        #[serde(rename = "OsSourceIgnored")]
        OsSourceIgnored,
        #[serde(rename = "OsTriggerIgnored")]
        OsTriggerIgnored,
        #[serde(rename = "InvalidRegisterOsSourceHeader")]
        InvalidRegisterOsSourceHeader,
        #[serde(rename = "InvalidRegisterOsTriggerHeader")]
        InvalidRegisterOsTriggerHeader,
        #[serde(rename = "WebAndOsHeaders")]
        WebAndOsHeaders,
        #[serde(rename = "NoWebOrOsSupport")]
        NoWebOrOsSupport,
        #[serde(rename = "NavigationRegistrationWithoutTransientUserActivation")]
        NavigationRegistrationWithoutTransientUserActivation,
        #[serde(rename = "InvalidInfoHeader")]
        InvalidInfoHeader,
        #[serde(rename = "NoRegisterSourceHeader")]
        NoRegisterSourceHeader,
        #[serde(rename = "NoRegisterTriggerHeader")]
        NoRegisterTriggerHeader,
        #[serde(rename = "NoRegisterOsSourceHeader")]
        NoRegisterOsSourceHeader,
        #[serde(rename = "NoRegisterOsTriggerHeader")]
        NoRegisterOsTriggerHeader,
        #[serde(rename = "NavigationRegistrationUniqueScopeAlreadySet")]
        NavigationRegistrationUniqueScopeAlreadySet,
    }
    impl From<&str> for AttributionReportingIssueType {
        fn from(s: &str) -> Self {
            match s {
                "PermissionPolicyDisabled" => Self::PermissionPolicyDisabled,
                "UntrustworthyReportingOrigin" => Self::UntrustworthyReportingOrigin,
                "InsecureContext" => Self::InsecureContext,
                "InvalidHeader" => Self::InvalidHeader,
                "InvalidRegisterTriggerHeader" => Self::InvalidRegisterTriggerHeader,
                "SourceAndTriggerHeaders" => Self::SourceAndTriggerHeaders,
                "SourceIgnored" => Self::SourceIgnored,
                "TriggerIgnored" => Self::TriggerIgnored,
                "OsSourceIgnored" => Self::OsSourceIgnored,
                "OsTriggerIgnored" => Self::OsTriggerIgnored,
                "InvalidRegisterOsSourceHeader" => Self::InvalidRegisterOsSourceHeader,
                "InvalidRegisterOsTriggerHeader" => Self::InvalidRegisterOsTriggerHeader,
                "WebAndOsHeaders" => Self::WebAndOsHeaders,
                "NoWebOrOsSupport" => Self::NoWebOrOsSupport,
                "NavigationRegistrationWithoutTransientUserActivation" => {
                    Self::NavigationRegistrationWithoutTransientUserActivation
                }
                "InvalidInfoHeader" => Self::InvalidInfoHeader,
                "NoRegisterSourceHeader" => Self::NoRegisterSourceHeader,
                "NoRegisterTriggerHeader" => Self::NoRegisterTriggerHeader,
                "NoRegisterOsSourceHeader" => Self::NoRegisterOsSourceHeader,
                "NoRegisterOsTriggerHeader" => Self::NoRegisterOsTriggerHeader,
                "NavigationRegistrationUniqueScopeAlreadySet" => {
                    Self::NavigationRegistrationUniqueScopeAlreadySet
                }
                _ => Self::PermissionPolicyDisabled,
            }
        }
    }
    impl From<String> for AttributionReportingIssueType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SharedDictionaryError {
        #[serde(rename = "UseErrorCrossOriginNoCorsRequest")]
        UseErrorCrossOriginNoCorsRequest,
        #[serde(rename = "UseErrorDictionaryLoadFailure")]
        UseErrorDictionaryLoadFailure,
        #[serde(rename = "UseErrorMatchingDictionaryNotUsed")]
        UseErrorMatchingDictionaryNotUsed,
        #[serde(rename = "UseErrorUnexpectedContentDictionaryHeader")]
        UseErrorUnexpectedContentDictionaryHeader,
        #[serde(rename = "WriteErrorCossOriginNoCorsRequest")]
        WriteErrorCossOriginNoCorsRequest,
        #[serde(rename = "WriteErrorDisallowedBySettings")]
        WriteErrorDisallowedBySettings,
        #[serde(rename = "WriteErrorExpiredResponse")]
        WriteErrorExpiredResponse,
        #[serde(rename = "WriteErrorFeatureDisabled")]
        WriteErrorFeatureDisabled,
        #[serde(rename = "WriteErrorInsufficientResources")]
        WriteErrorInsufficientResources,
        #[serde(rename = "WriteErrorInvalidMatchField")]
        WriteErrorInvalidMatchField,
        #[serde(rename = "WriteErrorInvalidStructuredHeader")]
        WriteErrorInvalidStructuredHeader,
        #[serde(rename = "WriteErrorInvalidTTLField")]
        WriteErrorInvalidTtlField,
        #[serde(rename = "WriteErrorNavigationRequest")]
        WriteErrorNavigationRequest,
        #[serde(rename = "WriteErrorNoMatchField")]
        WriteErrorNoMatchField,
        #[serde(rename = "WriteErrorNonIntegerTTLField")]
        WriteErrorNonIntegerTtlField,
        #[serde(rename = "WriteErrorNonListMatchDestField")]
        WriteErrorNonListMatchDestField,
        #[serde(rename = "WriteErrorNonSecureContext")]
        WriteErrorNonSecureContext,
        #[serde(rename = "WriteErrorNonStringIdField")]
        WriteErrorNonStringIdField,
        #[serde(rename = "WriteErrorNonStringInMatchDestList")]
        WriteErrorNonStringInMatchDestList,
        #[serde(rename = "WriteErrorNonStringMatchField")]
        WriteErrorNonStringMatchField,
        #[serde(rename = "WriteErrorNonTokenTypeField")]
        WriteErrorNonTokenTypeField,
        #[serde(rename = "WriteErrorRequestAborted")]
        WriteErrorRequestAborted,
        #[serde(rename = "WriteErrorShuttingDown")]
        WriteErrorShuttingDown,
        #[serde(rename = "WriteErrorTooLongIdField")]
        WriteErrorTooLongIdField,
        #[serde(rename = "WriteErrorUnsupportedType")]
        WriteErrorUnsupportedType,
    }
    impl From<&str> for SharedDictionaryError {
        fn from(s: &str) -> Self {
            match s {
                "UseErrorCrossOriginNoCorsRequest" => Self::UseErrorCrossOriginNoCorsRequest,
                "UseErrorDictionaryLoadFailure" => Self::UseErrorDictionaryLoadFailure,
                "UseErrorMatchingDictionaryNotUsed" => Self::UseErrorMatchingDictionaryNotUsed,
                "UseErrorUnexpectedContentDictionaryHeader" => {
                    Self::UseErrorUnexpectedContentDictionaryHeader
                }
                "WriteErrorCossOriginNoCorsRequest" => Self::WriteErrorCossOriginNoCorsRequest,
                "WriteErrorDisallowedBySettings" => Self::WriteErrorDisallowedBySettings,
                "WriteErrorExpiredResponse" => Self::WriteErrorExpiredResponse,
                "WriteErrorFeatureDisabled" => Self::WriteErrorFeatureDisabled,
                "WriteErrorInsufficientResources" => Self::WriteErrorInsufficientResources,
                "WriteErrorInvalidMatchField" => Self::WriteErrorInvalidMatchField,
                "WriteErrorInvalidStructuredHeader" => Self::WriteErrorInvalidStructuredHeader,
                "WriteErrorInvalidTTLField" => Self::WriteErrorInvalidTtlField,
                "WriteErrorNavigationRequest" => Self::WriteErrorNavigationRequest,
                "WriteErrorNoMatchField" => Self::WriteErrorNoMatchField,
                "WriteErrorNonIntegerTTLField" => Self::WriteErrorNonIntegerTtlField,
                "WriteErrorNonListMatchDestField" => Self::WriteErrorNonListMatchDestField,
                "WriteErrorNonSecureContext" => Self::WriteErrorNonSecureContext,
                "WriteErrorNonStringIdField" => Self::WriteErrorNonStringIdField,
                "WriteErrorNonStringInMatchDestList" => Self::WriteErrorNonStringInMatchDestList,
                "WriteErrorNonStringMatchField" => Self::WriteErrorNonStringMatchField,
                "WriteErrorNonTokenTypeField" => Self::WriteErrorNonTokenTypeField,
                "WriteErrorRequestAborted" => Self::WriteErrorRequestAborted,
                "WriteErrorShuttingDown" => Self::WriteErrorShuttingDown,
                "WriteErrorTooLongIdField" => Self::WriteErrorTooLongIdField,
                "WriteErrorUnsupportedType" => Self::WriteErrorUnsupportedType,
                _ => Self::UseErrorCrossOriginNoCorsRequest,
            }
        }
    }
    impl From<String> for SharedDictionaryError {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SRIMessageSignatureError {
        #[serde(rename = "MissingSignatureHeader")]
        MissingSignatureHeader,
        #[serde(rename = "MissingSignatureInputHeader")]
        MissingSignatureInputHeader,
        #[serde(rename = "InvalidSignatureHeader")]
        InvalidSignatureHeader,
        #[serde(rename = "InvalidSignatureInputHeader")]
        InvalidSignatureInputHeader,
        #[serde(rename = "SignatureHeaderValueIsNotByteSequence")]
        SignatureHeaderValueIsNotByteSequence,
        #[serde(rename = "SignatureHeaderValueIsParameterized")]
        SignatureHeaderValueIsParameterized,
        #[serde(rename = "SignatureHeaderValueIsIncorrectLength")]
        SignatureHeaderValueIsIncorrectLength,
        #[serde(rename = "SignatureInputHeaderMissingLabel")]
        SignatureInputHeaderMissingLabel,
        #[serde(rename = "SignatureInputHeaderValueNotInnerList")]
        SignatureInputHeaderValueNotInnerList,
        #[serde(rename = "SignatureInputHeaderValueMissingComponents")]
        SignatureInputHeaderValueMissingComponents,
        #[serde(rename = "SignatureInputHeaderInvalidComponentType")]
        SignatureInputHeaderInvalidComponentType,
        #[serde(rename = "SignatureInputHeaderInvalidComponentName")]
        SignatureInputHeaderInvalidComponentName,
        #[serde(rename = "SignatureInputHeaderInvalidHeaderComponentParameter")]
        SignatureInputHeaderInvalidHeaderComponentParameter,
        #[serde(rename = "SignatureInputHeaderInvalidDerivedComponentParameter")]
        SignatureInputHeaderInvalidDerivedComponentParameter,
        #[serde(rename = "SignatureInputHeaderKeyIdLength")]
        SignatureInputHeaderKeyIdLength,
        #[serde(rename = "SignatureInputHeaderInvalidParameter")]
        SignatureInputHeaderInvalidParameter,
        #[serde(rename = "SignatureInputHeaderMissingRequiredParameters")]
        SignatureInputHeaderMissingRequiredParameters,
        #[serde(rename = "ValidationFailedSignatureExpired")]
        ValidationFailedSignatureExpired,
        #[serde(rename = "ValidationFailedInvalidLength")]
        ValidationFailedInvalidLength,
        #[serde(rename = "ValidationFailedSignatureMismatch")]
        ValidationFailedSignatureMismatch,
        #[serde(rename = "ValidationFailedIntegrityMismatch")]
        ValidationFailedIntegrityMismatch,
    }
    impl From<&str> for SRIMessageSignatureError {
        fn from(s: &str) -> Self {
            match s {
                "MissingSignatureHeader" => Self::MissingSignatureHeader,
                "MissingSignatureInputHeader" => Self::MissingSignatureInputHeader,
                "InvalidSignatureHeader" => Self::InvalidSignatureHeader,
                "InvalidSignatureInputHeader" => Self::InvalidSignatureInputHeader,
                "SignatureHeaderValueIsNotByteSequence" => {
                    Self::SignatureHeaderValueIsNotByteSequence
                }
                "SignatureHeaderValueIsParameterized" => Self::SignatureHeaderValueIsParameterized,
                "SignatureHeaderValueIsIncorrectLength" => {
                    Self::SignatureHeaderValueIsIncorrectLength
                }
                "SignatureInputHeaderMissingLabel" => Self::SignatureInputHeaderMissingLabel,
                "SignatureInputHeaderValueNotInnerList" => {
                    Self::SignatureInputHeaderValueNotInnerList
                }
                "SignatureInputHeaderValueMissingComponents" => {
                    Self::SignatureInputHeaderValueMissingComponents
                }
                "SignatureInputHeaderInvalidComponentType" => {
                    Self::SignatureInputHeaderInvalidComponentType
                }
                "SignatureInputHeaderInvalidComponentName" => {
                    Self::SignatureInputHeaderInvalidComponentName
                }
                "SignatureInputHeaderInvalidHeaderComponentParameter" => {
                    Self::SignatureInputHeaderInvalidHeaderComponentParameter
                }
                "SignatureInputHeaderInvalidDerivedComponentParameter" => {
                    Self::SignatureInputHeaderInvalidDerivedComponentParameter
                }
                "SignatureInputHeaderKeyIdLength" => Self::SignatureInputHeaderKeyIdLength,
                "SignatureInputHeaderInvalidParameter" => {
                    Self::SignatureInputHeaderInvalidParameter
                }
                "SignatureInputHeaderMissingRequiredParameters" => {
                    Self::SignatureInputHeaderMissingRequiredParameters
                }
                "ValidationFailedSignatureExpired" => Self::ValidationFailedSignatureExpired,
                "ValidationFailedInvalidLength" => Self::ValidationFailedInvalidLength,
                "ValidationFailedSignatureMismatch" => Self::ValidationFailedSignatureMismatch,
                "ValidationFailedIntegrityMismatch" => Self::ValidationFailedIntegrityMismatch,
                _ => Self::MissingSignatureHeader,
            }
        }
    }
    impl From<String> for SRIMessageSignatureError {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum UnencodedDigestError {
        #[serde(rename = "MalformedDictionary")]
        MalformedDictionary,
        #[serde(rename = "UnknownAlgorithm")]
        UnknownAlgorithm,
        #[serde(rename = "IncorrectDigestType")]
        IncorrectDigestType,
        #[serde(rename = "IncorrectDigestLength")]
        IncorrectDigestLength,
    }
    impl From<&str> for UnencodedDigestError {
        fn from(s: &str) -> Self {
            match s {
                "MalformedDictionary" => Self::MalformedDictionary,
                "UnknownAlgorithm" => Self::UnknownAlgorithm,
                "IncorrectDigestType" => Self::IncorrectDigestType,
                "IncorrectDigestLength" => Self::IncorrectDigestLength,
                _ => Self::MalformedDictionary,
            }
        }
    }
    impl From<String> for UnencodedDigestError {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Details for issues around "Attribution Reporting API" usage. Explainer: https://github.com/WICG/attribution-reporting-api
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingIssueDetails {
        #[serde(rename = "violationType")]
        pub violation_type: AttributionReportingIssueType,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub request: Option<AffectedRequest>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<dom::BackendNodeId>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "invalidParameter")]
        pub invalid_parameter: Option<String>,
    }

    /// Details for issues about documents in Quirks Mode or Limited Quirks Mode that affects page layouting.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QuirksModeIssueDetails {
        /// If false, it means the document's mode is "quirks" instead of "limited-quirks".
        #[serde(rename = "isLimitedQuirksMode")]
        pub is_limited_quirks_mode: bool,
        #[serde(rename = "documentNodeId")]
        pub document_node_id: dom::BackendNodeId,
        pub url: String,
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
    }

    #[deprecated]
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NavigatorUserAgentIssueDetails {
        pub url: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub location: Option<SourceCodeLocation>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedDictionaryIssueDetails {
        #[serde(rename = "sharedDictionaryError")]
        pub shared_dictionary_error: SharedDictionaryError,
        pub request: AffectedRequest,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SRIMessageSignatureIssueDetails {
        pub error: SRIMessageSignatureError,
        #[serde(rename = "signatureBase")]
        pub signature_base: String,
        #[serde(rename = "integrityAssertions")]
        pub integrity_assertions: Vec<String>,
        pub request: AffectedRequest,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UnencodedDigestIssueDetails {
        pub error: UnencodedDigestError,
        pub request: AffectedRequest,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum GenericIssueErrorType {
        #[serde(rename = "FormLabelForNameError")]
        FormLabelForNameError,
        #[serde(rename = "FormDuplicateIdForInputError")]
        FormDuplicateIdForInputError,
        #[serde(rename = "FormInputWithNoLabelError")]
        FormInputWithNoLabelError,
        #[serde(rename = "FormAutocompleteAttributeEmptyError")]
        FormAutocompleteAttributeEmptyError,
        #[serde(rename = "FormEmptyIdAndNameAttributesForInputError")]
        FormEmptyIdAndNameAttributesForInputError,
        #[serde(rename = "FormAriaLabelledByToNonExistingIdError")]
        FormAriaLabelledByToNonExistingIdError,
        #[serde(rename = "FormInputAssignedAutocompleteValueToIdOrNameAttributeError")]
        FormInputAssignedAutocompleteValueToIdOrNameAttributeError,
        #[serde(rename = "FormLabelHasNeitherForNorNestedInputError")]
        FormLabelHasNeitherForNorNestedInputError,
        #[serde(rename = "FormLabelForMatchesNonExistingIdError")]
        FormLabelForMatchesNonExistingIdError,
        #[serde(rename = "FormInputHasWrongButWellIntendedAutocompleteValueError")]
        FormInputHasWrongButWellIntendedAutocompleteValueError,
        #[serde(rename = "ResponseWasBlockedByORB")]
        ResponseWasBlockedByOrb,
        #[serde(rename = "NavigationEntryMarkedSkippable")]
        NavigationEntryMarkedSkippable,
        #[serde(rename = "AutofillAndManualTextPolicyControlledFeaturesInfo")]
        AutofillAndManualTextPolicyControlledFeaturesInfo,
        #[serde(rename = "AutofillPolicyControlledFeatureInfo")]
        AutofillPolicyControlledFeatureInfo,
        #[serde(rename = "ManualTextPolicyControlledFeatureInfo")]
        ManualTextPolicyControlledFeatureInfo,
    }
    impl From<&str> for GenericIssueErrorType {
        fn from(s: &str) -> Self {
            match s {
                "FormLabelForNameError" => Self::FormLabelForNameError,
                "FormDuplicateIdForInputError" => Self::FormDuplicateIdForInputError,
                "FormInputWithNoLabelError" => Self::FormInputWithNoLabelError,
                "FormAutocompleteAttributeEmptyError" => Self::FormAutocompleteAttributeEmptyError,
                "FormEmptyIdAndNameAttributesForInputError" => {
                    Self::FormEmptyIdAndNameAttributesForInputError
                }
                "FormAriaLabelledByToNonExistingIdError" => {
                    Self::FormAriaLabelledByToNonExistingIdError
                }
                "FormInputAssignedAutocompleteValueToIdOrNameAttributeError" => {
                    Self::FormInputAssignedAutocompleteValueToIdOrNameAttributeError
                }
                "FormLabelHasNeitherForNorNestedInputError" => {
                    Self::FormLabelHasNeitherForNorNestedInputError
                }
                "FormLabelForMatchesNonExistingIdError" => {
                    Self::FormLabelForMatchesNonExistingIdError
                }
                "FormInputHasWrongButWellIntendedAutocompleteValueError" => {
                    Self::FormInputHasWrongButWellIntendedAutocompleteValueError
                }
                "ResponseWasBlockedByORB" => Self::ResponseWasBlockedByOrb,
                "NavigationEntryMarkedSkippable" => Self::NavigationEntryMarkedSkippable,
                "AutofillAndManualTextPolicyControlledFeaturesInfo" => {
                    Self::AutofillAndManualTextPolicyControlledFeaturesInfo
                }
                "AutofillPolicyControlledFeatureInfo" => Self::AutofillPolicyControlledFeatureInfo,
                "ManualTextPolicyControlledFeatureInfo" => {
                    Self::ManualTextPolicyControlledFeatureInfo
                }
                _ => Self::FormLabelForNameError,
            }
        }
    }
    impl From<String> for GenericIssueErrorType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Depending on the concrete errorType, different properties are set.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GenericIssueDetails {
        /// Issues with the same errorType are aggregated in the frontend.
        #[serde(rename = "errorType")]
        pub error_type: GenericIssueErrorType,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "violatingNodeId")]
        pub violating_node_id: Option<dom::BackendNodeId>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "violatingNodeAttribute")]
        pub violating_node_attribute: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub request: Option<AffectedRequest>,
    }

    /// This issue tracks information needed to print a deprecation message. https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeprecationIssueDetails {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "affectedFrame")]
        pub affected_frame: Option<AffectedFrame>,
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        /// One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
        #[serde(rename = "type")]
        pub type_: String,
    }

    /// This issue warns about sites in the redirect chain of a finished navigation that may be flagged as trackers and have their state cleared if they don't receive a user interaction. Note that in this context 'site' means eTLD+1. For example, if the URL `https://example.test:80/bounce` was in the redirect chain, the site reported would be `example.test`.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BounceTrackingIssueDetails {
        #[serde(rename = "trackingSites")]
        pub tracking_sites: Vec<String>,
    }

    /// This issue warns about third-party sites that are accessing cookies on the current page, and have been permitted due to having a global metadata grant. Note that in this context 'site' means eTLD+1. For example, if the URL `https://example.test:80/web_page` was accessing cookies, the site reported would be `example.test`.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CookieDeprecationMetadataIssueDetails {
        #[serde(rename = "allowedSites")]
        pub allowed_sites: Vec<String>,
        #[serde(rename = "optOutPercentage")]
        pub opt_out_percentage: f64,
        #[serde(rename = "isOptOutTopLevel")]
        pub is_opt_out_top_level: bool,
        pub operation: CookieOperation,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ClientHintIssueReason {
        #[serde(rename = "MetaTagAllowListInvalidOrigin")]
        MetaTagAllowListInvalidOrigin,
        #[serde(rename = "MetaTagModifiedHTML")]
        MetaTagModifiedHtml,
    }
    impl From<&str> for ClientHintIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "MetaTagAllowListInvalidOrigin" => Self::MetaTagAllowListInvalidOrigin,
                "MetaTagModifiedHTML" => Self::MetaTagModifiedHtml,
                _ => Self::MetaTagAllowListInvalidOrigin,
            }
        }
    }
    impl From<String> for ClientHintIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FederatedAuthRequestIssueDetails {
        #[serde(rename = "federatedAuthRequestIssueReason")]
        pub federated_auth_request_issue_reason: FederatedAuthRequestIssueReason,
    }

    /// Represents the failure reason when a federated authentication reason fails. Should be updated alongside RequestIdTokenStatus in third_party/blink/public/mojom/devtools/inspector_issue.mojom to include all cases except for success.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum FederatedAuthRequestIssueReason {
        #[serde(rename = "ShouldEmbargo")]
        ShouldEmbargo,
        #[serde(rename = "TooManyRequests")]
        TooManyRequests,
        #[serde(rename = "WellKnownHttpNotFound")]
        WellKnownHttpNotFound,
        #[serde(rename = "WellKnownNoResponse")]
        WellKnownNoResponse,
        #[serde(rename = "WellKnownInvalidResponse")]
        WellKnownInvalidResponse,
        #[serde(rename = "WellKnownListEmpty")]
        WellKnownListEmpty,
        #[serde(rename = "WellKnownInvalidContentType")]
        WellKnownInvalidContentType,
        #[serde(rename = "ConfigNotInWellKnown")]
        ConfigNotInWellKnown,
        #[serde(rename = "WellKnownTooBig")]
        WellKnownTooBig,
        #[serde(rename = "ConfigHttpNotFound")]
        ConfigHttpNotFound,
        #[serde(rename = "ConfigNoResponse")]
        ConfigNoResponse,
        #[serde(rename = "ConfigInvalidResponse")]
        ConfigInvalidResponse,
        #[serde(rename = "ConfigInvalidContentType")]
        ConfigInvalidContentType,
        #[serde(rename = "ClientMetadataHttpNotFound")]
        ClientMetadataHttpNotFound,
        #[serde(rename = "ClientMetadataNoResponse")]
        ClientMetadataNoResponse,
        #[serde(rename = "ClientMetadataInvalidResponse")]
        ClientMetadataInvalidResponse,
        #[serde(rename = "ClientMetadataInvalidContentType")]
        ClientMetadataInvalidContentType,
        #[serde(rename = "IdpNotPotentiallyTrustworthy")]
        IdpNotPotentiallyTrustworthy,
        #[serde(rename = "DisabledInSettings")]
        DisabledInSettings,
        #[serde(rename = "DisabledInFlags")]
        DisabledInFlags,
        #[serde(rename = "ErrorFetchingSignin")]
        ErrorFetchingSignin,
        #[serde(rename = "InvalidSigninResponse")]
        InvalidSigninResponse,
        #[serde(rename = "AccountsHttpNotFound")]
        AccountsHttpNotFound,
        #[serde(rename = "AccountsNoResponse")]
        AccountsNoResponse,
        #[serde(rename = "AccountsInvalidResponse")]
        AccountsInvalidResponse,
        #[serde(rename = "AccountsListEmpty")]
        AccountsListEmpty,
        #[serde(rename = "AccountsInvalidContentType")]
        AccountsInvalidContentType,
        #[serde(rename = "IdTokenHttpNotFound")]
        IdTokenHttpNotFound,
        #[serde(rename = "IdTokenNoResponse")]
        IdTokenNoResponse,
        #[serde(rename = "IdTokenInvalidResponse")]
        IdTokenInvalidResponse,
        #[serde(rename = "IdTokenIdpErrorResponse")]
        IdTokenIdpErrorResponse,
        #[serde(rename = "IdTokenCrossSiteIdpErrorResponse")]
        IdTokenCrossSiteIdpErrorResponse,
        #[serde(rename = "IdTokenInvalidRequest")]
        IdTokenInvalidRequest,
        #[serde(rename = "IdTokenInvalidContentType")]
        IdTokenInvalidContentType,
        #[serde(rename = "ErrorIdToken")]
        ErrorIdToken,
        #[serde(rename = "Canceled")]
        Canceled,
        #[serde(rename = "RpPageNotVisible")]
        RpPageNotVisible,
        #[serde(rename = "SilentMediationFailure")]
        SilentMediationFailure,
        #[serde(rename = "ThirdPartyCookiesBlocked")]
        ThirdPartyCookiesBlocked,
        #[serde(rename = "NotSignedInWithIdp")]
        NotSignedInWithIdp,
        #[serde(rename = "MissingTransientUserActivation")]
        MissingTransientUserActivation,
        #[serde(rename = "ReplacedByActiveMode")]
        ReplacedByActiveMode,
        #[serde(rename = "InvalidFieldsSpecified")]
        InvalidFieldsSpecified,
        #[serde(rename = "RelyingPartyOriginIsOpaque")]
        RelyingPartyOriginIsOpaque,
        #[serde(rename = "TypeNotMatching")]
        TypeNotMatching,
        #[serde(rename = "UiDismissedNoEmbargo")]
        UiDismissedNoEmbargo,
        #[serde(rename = "CorsError")]
        CorsError,
        #[serde(rename = "SuppressedBySegmentationPlatform")]
        SuppressedBySegmentationPlatform,
    }
    impl From<&str> for FederatedAuthRequestIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "ShouldEmbargo" => Self::ShouldEmbargo,
                "TooManyRequests" => Self::TooManyRequests,
                "WellKnownHttpNotFound" => Self::WellKnownHttpNotFound,
                "WellKnownNoResponse" => Self::WellKnownNoResponse,
                "WellKnownInvalidResponse" => Self::WellKnownInvalidResponse,
                "WellKnownListEmpty" => Self::WellKnownListEmpty,
                "WellKnownInvalidContentType" => Self::WellKnownInvalidContentType,
                "ConfigNotInWellKnown" => Self::ConfigNotInWellKnown,
                "WellKnownTooBig" => Self::WellKnownTooBig,
                "ConfigHttpNotFound" => Self::ConfigHttpNotFound,
                "ConfigNoResponse" => Self::ConfigNoResponse,
                "ConfigInvalidResponse" => Self::ConfigInvalidResponse,
                "ConfigInvalidContentType" => Self::ConfigInvalidContentType,
                "ClientMetadataHttpNotFound" => Self::ClientMetadataHttpNotFound,
                "ClientMetadataNoResponse" => Self::ClientMetadataNoResponse,
                "ClientMetadataInvalidResponse" => Self::ClientMetadataInvalidResponse,
                "ClientMetadataInvalidContentType" => Self::ClientMetadataInvalidContentType,
                "IdpNotPotentiallyTrustworthy" => Self::IdpNotPotentiallyTrustworthy,
                "DisabledInSettings" => Self::DisabledInSettings,
                "DisabledInFlags" => Self::DisabledInFlags,
                "ErrorFetchingSignin" => Self::ErrorFetchingSignin,
                "InvalidSigninResponse" => Self::InvalidSigninResponse,
                "AccountsHttpNotFound" => Self::AccountsHttpNotFound,
                "AccountsNoResponse" => Self::AccountsNoResponse,
                "AccountsInvalidResponse" => Self::AccountsInvalidResponse,
                "AccountsListEmpty" => Self::AccountsListEmpty,
                "AccountsInvalidContentType" => Self::AccountsInvalidContentType,
                "IdTokenHttpNotFound" => Self::IdTokenHttpNotFound,
                "IdTokenNoResponse" => Self::IdTokenNoResponse,
                "IdTokenInvalidResponse" => Self::IdTokenInvalidResponse,
                "IdTokenIdpErrorResponse" => Self::IdTokenIdpErrorResponse,
                "IdTokenCrossSiteIdpErrorResponse" => Self::IdTokenCrossSiteIdpErrorResponse,
                "IdTokenInvalidRequest" => Self::IdTokenInvalidRequest,
                "IdTokenInvalidContentType" => Self::IdTokenInvalidContentType,
                "ErrorIdToken" => Self::ErrorIdToken,
                "Canceled" => Self::Canceled,
                "RpPageNotVisible" => Self::RpPageNotVisible,
                "SilentMediationFailure" => Self::SilentMediationFailure,
                "ThirdPartyCookiesBlocked" => Self::ThirdPartyCookiesBlocked,
                "NotSignedInWithIdp" => Self::NotSignedInWithIdp,
                "MissingTransientUserActivation" => Self::MissingTransientUserActivation,
                "ReplacedByActiveMode" => Self::ReplacedByActiveMode,
                "InvalidFieldsSpecified" => Self::InvalidFieldsSpecified,
                "RelyingPartyOriginIsOpaque" => Self::RelyingPartyOriginIsOpaque,
                "TypeNotMatching" => Self::TypeNotMatching,
                "UiDismissedNoEmbargo" => Self::UiDismissedNoEmbargo,
                "CorsError" => Self::CorsError,
                "SuppressedBySegmentationPlatform" => Self::SuppressedBySegmentationPlatform,
                _ => Self::ShouldEmbargo,
            }
        }
    }
    impl From<String> for FederatedAuthRequestIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FederatedAuthUserInfoRequestIssueDetails {
        #[serde(rename = "federatedAuthUserInfoRequestIssueReason")]
        pub federated_auth_user_info_request_issue_reason: FederatedAuthUserInfoRequestIssueReason,
    }

    /// Represents the failure reason when a getUserInfo() call fails. Should be updated alongside FederatedAuthUserInfoRequestResult in third_party/blink/public/mojom/devtools/inspector_issue.mojom.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum FederatedAuthUserInfoRequestIssueReason {
        #[serde(rename = "NotSameOrigin")]
        NotSameOrigin,
        #[serde(rename = "NotIframe")]
        NotIframe,
        #[serde(rename = "NotPotentiallyTrustworthy")]
        NotPotentiallyTrustworthy,
        #[serde(rename = "NoApiPermission")]
        NoApiPermission,
        #[serde(rename = "NotSignedInWithIdp")]
        NotSignedInWithIdp,
        #[serde(rename = "NoAccountSharingPermission")]
        NoAccountSharingPermission,
        #[serde(rename = "InvalidConfigOrWellKnown")]
        InvalidConfigOrWellKnown,
        #[serde(rename = "InvalidAccountsResponse")]
        InvalidAccountsResponse,
        #[serde(rename = "NoReturningUserFromFetchedAccounts")]
        NoReturningUserFromFetchedAccounts,
    }
    impl From<&str> for FederatedAuthUserInfoRequestIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "NotSameOrigin" => Self::NotSameOrigin,
                "NotIframe" => Self::NotIframe,
                "NotPotentiallyTrustworthy" => Self::NotPotentiallyTrustworthy,
                "NoApiPermission" => Self::NoApiPermission,
                "NotSignedInWithIdp" => Self::NotSignedInWithIdp,
                "NoAccountSharingPermission" => Self::NoAccountSharingPermission,
                "InvalidConfigOrWellKnown" => Self::InvalidConfigOrWellKnown,
                "InvalidAccountsResponse" => Self::InvalidAccountsResponse,
                "NoReturningUserFromFetchedAccounts" => Self::NoReturningUserFromFetchedAccounts,
                _ => Self::NotSameOrigin,
            }
        }
    }
    impl From<String> for FederatedAuthUserInfoRequestIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue tracks client hints related issues. It's used to deprecate old features, encourage the use of new ones, and provide general guidance.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClientHintIssueDetails {
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        #[serde(rename = "clientHintIssueReason")]
        pub client_hint_issue_reason: ClientHintIssueReason,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FailedRequestInfo {
        /// The URL that failed to load.
        pub url: String,
        /// The failure message for the failed request.
        #[serde(rename = "failureMessage")]
        pub failure_message: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestId")]
        pub request_id: Option<network::RequestId>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PartitioningBlobURLInfo {
        #[serde(rename = "BlockedCrossPartitionFetching")]
        BlockedCrossPartitionFetching,
        #[serde(rename = "EnforceNoopenerForNavigation")]
        EnforceNoopenerForNavigation,
    }
    impl From<&str> for PartitioningBlobURLInfo {
        fn from(s: &str) -> Self {
            match s {
                "BlockedCrossPartitionFetching" => Self::BlockedCrossPartitionFetching,
                "EnforceNoopenerForNavigation" => Self::EnforceNoopenerForNavigation,
                _ => Self::BlockedCrossPartitionFetching,
            }
        }
    }
    impl From<String> for PartitioningBlobURLInfo {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PartitioningBlobURLIssueDetails {
        /// The BlobURL that failed to load.
        pub url: String,
        /// Additional information about the Partitioning Blob URL issue.
        #[serde(rename = "partitioningBlobURLInfo")]
        pub partitioning_blob_url_info: PartitioningBlobURLInfo,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ElementAccessibilityIssueReason {
        #[serde(rename = "DisallowedSelectChild")]
        DisallowedSelectChild,
        #[serde(rename = "DisallowedOptGroupChild")]
        DisallowedOptGroupChild,
        #[serde(rename = "NonPhrasingContentOptionChild")]
        NonPhrasingContentOptionChild,
        #[serde(rename = "InteractiveContentOptionChild")]
        InteractiveContentOptionChild,
        #[serde(rename = "InteractiveContentLegendChild")]
        InteractiveContentLegendChild,
        #[serde(rename = "InteractiveContentSummaryDescendant")]
        InteractiveContentSummaryDescendant,
    }
    impl From<&str> for ElementAccessibilityIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "DisallowedSelectChild" => Self::DisallowedSelectChild,
                "DisallowedOptGroupChild" => Self::DisallowedOptGroupChild,
                "NonPhrasingContentOptionChild" => Self::NonPhrasingContentOptionChild,
                "InteractiveContentOptionChild" => Self::InteractiveContentOptionChild,
                "InteractiveContentLegendChild" => Self::InteractiveContentLegendChild,
                "InteractiveContentSummaryDescendant" => Self::InteractiveContentSummaryDescendant,
                _ => Self::DisallowedSelectChild,
            }
        }
    }
    impl From<String> for ElementAccessibilityIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue warns about errors in the select or summary element content model.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ElementAccessibilityIssueDetails {
        #[serde(rename = "nodeId")]
        pub node_id: dom::BackendNodeId,
        #[serde(rename = "elementAccessibilityIssueReason")]
        pub element_accessibility_issue_reason: ElementAccessibilityIssueReason,
        #[serde(rename = "hasDisallowedAttributes")]
        pub has_disallowed_attributes: bool,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StyleSheetLoadingIssueReason {
        #[serde(rename = "LateImportRule")]
        LateImportRule,
        #[serde(rename = "RequestFailed")]
        RequestFailed,
    }
    impl From<&str> for StyleSheetLoadingIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "LateImportRule" => Self::LateImportRule,
                "RequestFailed" => Self::RequestFailed,
                _ => Self::LateImportRule,
            }
        }
    }
    impl From<String> for StyleSheetLoadingIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue warns when a referenced stylesheet couldn't be loaded.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StylesheetLoadingIssueDetails {
        /// Source code position that referenced the failing stylesheet.
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        /// Reason why the stylesheet couldn't be loaded.
        #[serde(rename = "styleSheetLoadingIssueReason")]
        pub style_sheet_loading_issue_reason: StyleSheetLoadingIssueReason,
        /// Contains additional info when the failure was due to a request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "failedRequestInfo")]
        pub failed_request_info: Option<FailedRequestInfo>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PropertyRuleIssueReason {
        #[serde(rename = "InvalidSyntax")]
        InvalidSyntax,
        #[serde(rename = "InvalidInitialValue")]
        InvalidInitialValue,
        #[serde(rename = "InvalidInherits")]
        InvalidInherits,
        #[serde(rename = "InvalidName")]
        InvalidName,
    }
    impl From<&str> for PropertyRuleIssueReason {
        fn from(s: &str) -> Self {
            match s {
                "InvalidSyntax" => Self::InvalidSyntax,
                "InvalidInitialValue" => Self::InvalidInitialValue,
                "InvalidInherits" => Self::InvalidInherits,
                "InvalidName" => Self::InvalidName,
                _ => Self::InvalidSyntax,
            }
        }
    }
    impl From<String> for PropertyRuleIssueReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue warns about errors in property rules that lead to property registrations being ignored.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PropertyRuleIssueDetails {
        /// Source code position of the property rule.
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: SourceCodeLocation,
        /// Reason why the property rule was discarded.
        #[serde(rename = "propertyRuleIssueReason")]
        pub property_rule_issue_reason: PropertyRuleIssueReason,
        /// The value of the property rule property that failed to parse
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "propertyValue")]
        pub property_value: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum UserReidentificationIssueType {
        #[serde(rename = "BlockedFrameNavigation")]
        BlockedFrameNavigation,
        #[serde(rename = "BlockedSubresource")]
        BlockedSubresource,
        #[serde(rename = "NoisedCanvasReadback")]
        NoisedCanvasReadback,
    }
    impl From<&str> for UserReidentificationIssueType {
        fn from(s: &str) -> Self {
            match s {
                "BlockedFrameNavigation" => Self::BlockedFrameNavigation,
                "BlockedSubresource" => Self::BlockedSubresource,
                "NoisedCanvasReadback" => Self::NoisedCanvasReadback,
                _ => Self::BlockedFrameNavigation,
            }
        }
    }
    impl From<String> for UserReidentificationIssueType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue warns about uses of APIs that may be considered misuse to re-identify users.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UserReidentificationIssueDetails {
        #[serde(rename = "type")]
        pub type_: UserReidentificationIssueType,
        /// Applies to BlockedFrameNavigation and BlockedSubresource issue types.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub request: Option<AffectedRequest>,
        /// Applies to NoisedCanvasReadback issue type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceCodeLocation")]
        pub source_code_location: Option<SourceCodeLocation>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PermissionElementIssueType {
        #[serde(rename = "InvalidType")]
        InvalidType,
        #[serde(rename = "FencedFrameDisallowed")]
        FencedFrameDisallowed,
        #[serde(rename = "CspFrameAncestorsMissing")]
        CspFrameAncestorsMissing,
        #[serde(rename = "PermissionsPolicyBlocked")]
        PermissionsPolicyBlocked,
        #[serde(rename = "PaddingRightUnsupported")]
        PaddingRightUnsupported,
        #[serde(rename = "PaddingBottomUnsupported")]
        PaddingBottomUnsupported,
        #[serde(rename = "InsetBoxShadowUnsupported")]
        InsetBoxShadowUnsupported,
        #[serde(rename = "RequestInProgress")]
        RequestInProgress,
        #[serde(rename = "UntrustedEvent")]
        UntrustedEvent,
        #[serde(rename = "RegistrationFailed")]
        RegistrationFailed,
        #[serde(rename = "TypeNotSupported")]
        TypeNotSupported,
        #[serde(rename = "InvalidTypeActivation")]
        InvalidTypeActivation,
        #[serde(rename = "SecurityChecksFailed")]
        SecurityChecksFailed,
        #[serde(rename = "ActivationDisabled")]
        ActivationDisabled,
        #[serde(rename = "GeolocationDeprecated")]
        GeolocationDeprecated,
        #[serde(rename = "InvalidDisplayStyle")]
        InvalidDisplayStyle,
        #[serde(rename = "NonOpaqueColor")]
        NonOpaqueColor,
        #[serde(rename = "LowContrast")]
        LowContrast,
        #[serde(rename = "FontSizeTooSmall")]
        FontSizeTooSmall,
        #[serde(rename = "FontSizeTooLarge")]
        FontSizeTooLarge,
        #[serde(rename = "InvalidSizeValue")]
        InvalidSizeValue,
    }
    impl From<&str> for PermissionElementIssueType {
        fn from(s: &str) -> Self {
            match s {
                "InvalidType" => Self::InvalidType,
                "FencedFrameDisallowed" => Self::FencedFrameDisallowed,
                "CspFrameAncestorsMissing" => Self::CspFrameAncestorsMissing,
                "PermissionsPolicyBlocked" => Self::PermissionsPolicyBlocked,
                "PaddingRightUnsupported" => Self::PaddingRightUnsupported,
                "PaddingBottomUnsupported" => Self::PaddingBottomUnsupported,
                "InsetBoxShadowUnsupported" => Self::InsetBoxShadowUnsupported,
                "RequestInProgress" => Self::RequestInProgress,
                "UntrustedEvent" => Self::UntrustedEvent,
                "RegistrationFailed" => Self::RegistrationFailed,
                "TypeNotSupported" => Self::TypeNotSupported,
                "InvalidTypeActivation" => Self::InvalidTypeActivation,
                "SecurityChecksFailed" => Self::SecurityChecksFailed,
                "ActivationDisabled" => Self::ActivationDisabled,
                "GeolocationDeprecated" => Self::GeolocationDeprecated,
                "InvalidDisplayStyle" => Self::InvalidDisplayStyle,
                "NonOpaqueColor" => Self::NonOpaqueColor,
                "LowContrast" => Self::LowContrast,
                "FontSizeTooSmall" => Self::FontSizeTooSmall,
                "FontSizeTooLarge" => Self::FontSizeTooLarge,
                "InvalidSizeValue" => Self::InvalidSizeValue,
                _ => Self::InvalidType,
            }
        }
    }
    impl From<String> for PermissionElementIssueType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This issue warns about improper usage of the <permission> element.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PermissionElementIssueDetails {
        #[serde(rename = "issueType")]
        pub issue_type: PermissionElementIssueType,
        /// The value of the type attribute.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "type")]
        pub type_: Option<String>,
        /// The node ID of the <permission> element.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        pub node_id: Option<dom::BackendNodeId>,
        /// True if the issue is a warning, false if it is an error.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isWarning")]
        pub is_warning: Option<bool>,
        /// Fields for message construction: Used for messages that reference a specific permission name
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "permissionName")]
        pub permission_name: Option<String>,
        /// Used for messages about occlusion
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "occluderNodeInfo")]
        pub occluder_node_info: Option<String>,
        /// Used for messages about occluder's parent
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "occluderParentNodeInfo")]
        pub occluder_parent_node_info: Option<String>,
        /// Used for messages about activation disabled reason
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "disableReason")]
        pub disable_reason: Option<String>,
    }

    /// A unique identifier for the type of issue. Each type may use one of the optional fields in InspectorIssueDetails to convey more specific information about the kind of issue.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InspectorIssueCode {
        #[serde(rename = "CookieIssue")]
        CookieIssue,
        #[serde(rename = "MixedContentIssue")]
        MixedContentIssue,
        #[serde(rename = "BlockedByResponseIssue")]
        BlockedByResponseIssue,
        #[serde(rename = "HeavyAdIssue")]
        HeavyAdIssue,
        #[serde(rename = "ContentSecurityPolicyIssue")]
        ContentSecurityPolicyIssue,
        #[serde(rename = "SharedArrayBufferIssue")]
        SharedArrayBufferIssue,
        #[serde(rename = "LowTextContrastIssue")]
        LowTextContrastIssue,
        #[serde(rename = "CorsIssue")]
        CorsIssue,
        #[serde(rename = "AttributionReportingIssue")]
        AttributionReportingIssue,
        #[serde(rename = "QuirksModeIssue")]
        QuirksModeIssue,
        #[serde(rename = "PartitioningBlobURLIssue")]
        PartitioningBlobUrlIssue,
        #[serde(rename = "NavigatorUserAgentIssue")]
        NavigatorUserAgentIssue,
        #[serde(rename = "GenericIssue")]
        GenericIssue,
        #[serde(rename = "DeprecationIssue")]
        DeprecationIssue,
        #[serde(rename = "ClientHintIssue")]
        ClientHintIssue,
        #[serde(rename = "FederatedAuthRequestIssue")]
        FederatedAuthRequestIssue,
        #[serde(rename = "BounceTrackingIssue")]
        BounceTrackingIssue,
        #[serde(rename = "CookieDeprecationMetadataIssue")]
        CookieDeprecationMetadataIssue,
        #[serde(rename = "StylesheetLoadingIssue")]
        StylesheetLoadingIssue,
        #[serde(rename = "FederatedAuthUserInfoRequestIssue")]
        FederatedAuthUserInfoRequestIssue,
        #[serde(rename = "PropertyRuleIssue")]
        PropertyRuleIssue,
        #[serde(rename = "SharedDictionaryIssue")]
        SharedDictionaryIssue,
        #[serde(rename = "ElementAccessibilityIssue")]
        ElementAccessibilityIssue,
        #[serde(rename = "SRIMessageSignatureIssue")]
        SriMessageSignatureIssue,
        #[serde(rename = "UnencodedDigestIssue")]
        UnencodedDigestIssue,
        #[serde(rename = "UserReidentificationIssue")]
        UserReidentificationIssue,
        #[serde(rename = "PermissionElementIssue")]
        PermissionElementIssue,
    }
    impl From<&str> for InspectorIssueCode {
        fn from(s: &str) -> Self {
            match s {
                "CookieIssue" => Self::CookieIssue,
                "MixedContentIssue" => Self::MixedContentIssue,
                "BlockedByResponseIssue" => Self::BlockedByResponseIssue,
                "HeavyAdIssue" => Self::HeavyAdIssue,
                "ContentSecurityPolicyIssue" => Self::ContentSecurityPolicyIssue,
                "SharedArrayBufferIssue" => Self::SharedArrayBufferIssue,
                "LowTextContrastIssue" => Self::LowTextContrastIssue,
                "CorsIssue" => Self::CorsIssue,
                "AttributionReportingIssue" => Self::AttributionReportingIssue,
                "QuirksModeIssue" => Self::QuirksModeIssue,
                "PartitioningBlobURLIssue" => Self::PartitioningBlobUrlIssue,
                "NavigatorUserAgentIssue" => Self::NavigatorUserAgentIssue,
                "GenericIssue" => Self::GenericIssue,
                "DeprecationIssue" => Self::DeprecationIssue,
                "ClientHintIssue" => Self::ClientHintIssue,
                "FederatedAuthRequestIssue" => Self::FederatedAuthRequestIssue,
                "BounceTrackingIssue" => Self::BounceTrackingIssue,
                "CookieDeprecationMetadataIssue" => Self::CookieDeprecationMetadataIssue,
                "StylesheetLoadingIssue" => Self::StylesheetLoadingIssue,
                "FederatedAuthUserInfoRequestIssue" => Self::FederatedAuthUserInfoRequestIssue,
                "PropertyRuleIssue" => Self::PropertyRuleIssue,
                "SharedDictionaryIssue" => Self::SharedDictionaryIssue,
                "ElementAccessibilityIssue" => Self::ElementAccessibilityIssue,
                "SRIMessageSignatureIssue" => Self::SriMessageSignatureIssue,
                "UnencodedDigestIssue" => Self::UnencodedDigestIssue,
                "UserReidentificationIssue" => Self::UserReidentificationIssue,
                "PermissionElementIssue" => Self::PermissionElementIssue,
                _ => Self::CookieIssue,
            }
        }
    }
    impl From<String> for InspectorIssueCode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// This struct holds a list of optional fields with additional information specific to the kind of issue. When adding a new issue code, please also add a new optional field to this type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InspectorIssueDetails {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cookieIssueDetails")]
        pub cookie_issue_details: Option<CookieIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "mixedContentIssueDetails")]
        pub mixed_content_issue_details: Option<MixedContentIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "blockedByResponseIssueDetails")]
        pub blocked_by_response_issue_details: Option<BlockedByResponseIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "heavyAdIssueDetails")]
        pub heavy_ad_issue_details: Option<HeavyAdIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentSecurityPolicyIssueDetails")]
        pub content_security_policy_issue_details: Option<ContentSecurityPolicyIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sharedArrayBufferIssueDetails")]
        pub shared_array_buffer_issue_details: Option<SharedArrayBufferIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lowTextContrastIssueDetails")]
        pub low_text_contrast_issue_details: Option<LowTextContrastIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "corsIssueDetails")]
        pub cors_issue_details: Option<CorsIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "attributionReportingIssueDetails")]
        pub attribution_reporting_issue_details: Option<AttributionReportingIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "quirksModeIssueDetails")]
        pub quirks_mode_issue_details: Option<QuirksModeIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitioningBlobURLIssueDetails")]
        pub partitioning_blob_url_issue_details: Option<PartitioningBlobURLIssueDetails>,
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "navigatorUserAgentIssueDetails")]
        pub navigator_user_agent_issue_details: Option<NavigatorUserAgentIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "genericIssueDetails")]
        pub generic_issue_details: Option<GenericIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deprecationIssueDetails")]
        pub deprecation_issue_details: Option<DeprecationIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clientHintIssueDetails")]
        pub client_hint_issue_details: Option<ClientHintIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "federatedAuthRequestIssueDetails")]
        pub federated_auth_request_issue_details: Option<FederatedAuthRequestIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bounceTrackingIssueDetails")]
        pub bounce_tracking_issue_details: Option<BounceTrackingIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cookieDeprecationMetadataIssueDetails")]
        pub cookie_deprecation_metadata_issue_details:
            Option<CookieDeprecationMetadataIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "stylesheetLoadingIssueDetails")]
        pub stylesheet_loading_issue_details: Option<StylesheetLoadingIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "propertyRuleIssueDetails")]
        pub property_rule_issue_details: Option<PropertyRuleIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "federatedAuthUserInfoRequestIssueDetails")]
        pub federated_auth_user_info_request_issue_details:
            Option<FederatedAuthUserInfoRequestIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sharedDictionaryIssueDetails")]
        pub shared_dictionary_issue_details: Option<SharedDictionaryIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "elementAccessibilityIssueDetails")]
        pub element_accessibility_issue_details: Option<ElementAccessibilityIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sriMessageSignatureIssueDetails")]
        pub sri_message_signature_issue_details: Option<SRIMessageSignatureIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "unencodedDigestIssueDetails")]
        pub unencoded_digest_issue_details: Option<UnencodedDigestIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userReidentificationIssueDetails")]
        pub user_reidentification_issue_details: Option<UserReidentificationIssueDetails>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "permissionElementIssueDetails")]
        pub permission_element_issue_details: Option<PermissionElementIssueDetails>,
    }

    /// A unique id for a DevTools inspector issue. Allows other entities (e.g. exceptions, CDP message, console messages, etc.) to reference an issue.
    pub type IssueId = String;

    /// An inspector issue reported from the back-end.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InspectorIssue {
        pub code: InspectorIssueCode,
        pub details: InspectorIssueDetails,
        /// A unique id for this issue. May be omitted if no other entity (e.g. exception, CDP message, etc.) is referencing this issue.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "issueId")]
        pub issue_id: Option<IssueId>,
    }

    /// Returns the response body and size if it were re-encoded with the specified settings. Only applies to images.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEncodedResponse {
        /// Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        request_id: network::RequestId,
        /// The encoding to use.
        encoding: String,
        /// The quality of the encoding (0-1). (defaults to 1)
        #[serde(skip_serializing_if = "Option::is_none")]
        quality: Option<f64>,
        /// Whether to only return the size information (defaults to false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sizeOnly")]
        size_only: Option<bool>,
    }

    impl GetEncodedResponse {
        pub fn new(request_id: impl Into<network::RequestId>, encoding: impl Into<String>) -> Self {
            Self {
                request_id: request_id.into(),
                encoding: encoding.into(),
                quality: None,
                size_only: None,
            }
        }

        pub fn with_quality(mut self, quality: impl Into<f64>) -> Self {
            self.quality = Some(quality.into());
            self
        }

        pub fn with_size_only(mut self, size_only: impl Into<bool>) -> Self {
            self.size_only = Some(size_only.into());
            self
        }
    }

    impl Command for GetEncodedResponse {
        type Response = GetEncodedResponseResult;
        const METHOD: &'static str = "Audits.getEncodedResponse";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEncodedResponseResult {
        /// The encoded body as a base64 string. Omitted if sizeOnly is true. (Encoded as a base64 string when passed over JSON)
        pub body: Option<String>,
        /// Size before re-encoding.
        #[serde(rename = "originalSize")]
        pub original_size: i64,
        /// Size after re-encoding.
        #[serde(rename = "encodedSize")]
        pub encoded_size: i64,
    }

    /// Disables issues domain, prevents further issues from being reported to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Audits.disable";
    }

    /// Enables issues domain, sends the issues collected so far to the client by means of the `issueAdded` event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Audits.enable";
    }

    /// Runs the contrast check for the target page. Found issues are reported using Audits.issueAdded event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CheckContrast {
        /// Whether to report WCAG AAA level issues. Default is false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportAAA")]
        report_aaa: Option<bool>,
    }

    impl CheckContrast {
        pub fn new() -> Self {
            Self { report_aaa: None }
        }

        pub fn with_report_aaa(mut self, report_aaa: impl Into<bool>) -> Self {
            self.report_aaa = Some(report_aaa.into());
            self
        }
    }

    impl Command for CheckContrast {
        type Response = ();
        const METHOD: &'static str = "Audits.checkContrast";
    }

    /// Runs the form issues check for the target page. Found issues are reported using Audits.issueAdded event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CheckFormsIssues {}

    impl CheckFormsIssues {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CheckFormsIssues {
        type Response = CheckFormsIssuesResult;
        const METHOD: &'static str = "Audits.checkFormsIssues";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CheckFormsIssuesResult {
        #[serde(rename = "formIssues")]
        pub form_issues: Vec<GenericIssueDetails>,
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IssueAdded {
        pub issue: InspectorIssue,
    }

    impl IssueAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Audits.issueAdded")
        }
    }
}

pub mod autofill {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreditCard {
        /// 16-digit credit card number.
        pub number: String,
        /// Name of the credit card owner.
        pub name: String,
        /// 2-digit expiry month.
        #[serde(rename = "expiryMonth")]
        pub expiry_month: String,
        /// 4-digit expiry year.
        #[serde(rename = "expiryYear")]
        pub expiry_year: String,
        /// 3-digit card verification code.
        pub cvc: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddressField {
        /// address field name, for example GIVEN_NAME. The full list of supported field names: https://source.chromium.org/chromium/chromium/src/+/main:components/autofill/core/browser/field_types.cc;l=38
        pub name: String,
        /// address field value, for example Jon Doe.
        pub value: String,
    }

    /// A list of address fields.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddressFields {
        pub fields: Vec<AddressField>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Address {
        /// fields and values defining an address.
        pub fields: Vec<AddressField>,
    }

    /// Defines how an address can be displayed like in chrome://settings/addresses. Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such. The following address UI for instance: [[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]] should allow the receiver to render: Jon Doe Munich 81456
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddressUI {
        /// A two dimension array containing the representation of values from an address profile.
        #[serde(rename = "addressFields")]
        pub address_fields: Vec<AddressFields>,
    }

    /// Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum FillingStrategy {
        #[serde(rename = "autocompleteAttribute")]
        AutocompleteAttribute,
        #[serde(rename = "autofillInferred")]
        AutofillInferred,
    }
    impl From<&str> for FillingStrategy {
        fn from(s: &str) -> Self {
            match s {
                "autocompleteAttribute" => Self::AutocompleteAttribute,
                "autofillInferred" => Self::AutofillInferred,
                _ => Self::AutocompleteAttribute,
            }
        }
    }
    impl From<String> for FillingStrategy {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FilledField {
        /// The type of the field, e.g text, password etc.
        #[serde(rename = "htmlType")]
        pub html_type: String,
        /// the html id
        pub id: String,
        /// the html name
        pub name: String,
        /// the field value
        pub value: String,
        /// The actual field type, e.g FAMILY_NAME
        #[serde(rename = "autofillType")]
        pub autofill_type: String,
        /// The filling strategy
        #[serde(rename = "fillingStrategy")]
        pub filling_strategy: FillingStrategy,
        /// The frame the field belongs to
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// The form field's DOM node
        #[serde(rename = "fieldId")]
        pub field_id: dom::BackendNodeId,
    }

    /// Trigger autofill on a form identified by the fieldId. If the field and related form cannot be autofilled, returns an error.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Trigger {
        /// Identifies a field that serves as an anchor for autofill.
        #[serde(rename = "fieldId")]
        field_id: dom::BackendNodeId,
        /// Identifies the frame that field belongs to.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
        /// Credit card information to fill out the form. Credit card data is not saved. Mutually exclusive with `address`.
        #[serde(skip_serializing_if = "Option::is_none")]
        card: Option<CreditCard>,
        /// Address to fill out the form. Address data is not saved. Mutually exclusive with `card`.
        #[serde(skip_serializing_if = "Option::is_none")]
        address: Option<Address>,
    }

    impl Trigger {
        pub fn new(field_id: impl Into<dom::BackendNodeId>) -> Self {
            Self {
                field_id: field_id.into(),
                frame_id: None,
                card: None,
                address: None,
            }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }

        pub fn with_card(mut self, card: impl Into<CreditCard>) -> Self {
            self.card = Some(card.into());
            self
        }

        pub fn with_address(mut self, address: impl Into<Address>) -> Self {
            self.address = Some(address.into());
            self
        }
    }

    impl Command for Trigger {
        type Response = ();
        const METHOD: &'static str = "Autofill.trigger";
    }

    /// Set addresses so that developers can verify their forms implementation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAddresses {
        addresses: Vec<Address>,
    }

    impl SetAddresses {
        pub fn new(addresses: impl Into<Vec<Address>>) -> Self {
            Self {
                addresses: addresses.into(),
            }
        }
    }

    impl Command for SetAddresses {
        type Response = ();
        const METHOD: &'static str = "Autofill.setAddresses";
    }

    /// Disables autofill domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Autofill.disable";
    }

    /// Enables autofill domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Autofill.enable";
    }

    /// Emitted when an address form is filled.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddressFormFilled {
        /// Information about the fields that were filled
        #[serde(rename = "filledFields")]
        pub filled_fields: Vec<FilledField>,
        /// An UI representation of the address used to fill the form. Consists of a 2D array where each child represents an address/profile line.
        #[serde(rename = "addressUi")]
        pub address_ui: AddressUI,
    }

    impl AddressFormFilled {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Autofill.addressFormFilled")
        }
    }
}

pub mod background_service {
    use super::*;

    /// The Background Service that will be associated with the commands/events. Every Background Service operates independently, but they share the same API.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ServiceName {
        #[serde(rename = "backgroundFetch")]
        BackgroundFetch,
        #[serde(rename = "backgroundSync")]
        BackgroundSync,
        #[serde(rename = "pushMessaging")]
        PushMessaging,
        #[serde(rename = "notifications")]
        Notifications,
        #[serde(rename = "paymentHandler")]
        PaymentHandler,
        #[serde(rename = "periodicBackgroundSync")]
        PeriodicBackgroundSync,
    }
    impl From<&str> for ServiceName {
        fn from(s: &str) -> Self {
            match s {
                "backgroundFetch" => Self::BackgroundFetch,
                "backgroundSync" => Self::BackgroundSync,
                "pushMessaging" => Self::PushMessaging,
                "notifications" => Self::Notifications,
                "paymentHandler" => Self::PaymentHandler,
                "periodicBackgroundSync" => Self::PeriodicBackgroundSync,
                _ => Self::BackgroundFetch,
            }
        }
    }
    impl From<String> for ServiceName {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A key-value pair for additional event information to pass along.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EventMetadata {
        pub key: String,
        pub value: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackgroundServiceEvent {
        /// Timestamp of the event (in seconds).
        pub timestamp: network::TimeSinceEpoch,
        /// The origin this event belongs to.
        pub origin: String,
        /// The Service Worker ID that initiated the event.
        #[serde(rename = "serviceWorkerRegistrationId")]
        pub service_worker_registration_id: serviceworker::RegistrationID,
        /// The Background Service this event belongs to.
        pub service: ServiceName,
        /// A description of the event.
        #[serde(rename = "eventName")]
        pub event_name: String,
        /// An identifier that groups related events together.
        #[serde(rename = "instanceId")]
        pub instance_id: String,
        /// A list of event-specific information.
        #[serde(rename = "eventMetadata")]
        pub event_metadata: Vec<EventMetadata>,
        /// Storage key this event belongs to.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
    }

    /// Enables event updates for the service.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartObserving {
        service: ServiceName,
    }

    impl StartObserving {
        pub fn new(service: impl Into<ServiceName>) -> Self {
            Self {
                service: service.into(),
            }
        }
    }

    impl Command for StartObserving {
        type Response = ();
        const METHOD: &'static str = "BackgroundService.startObserving";
    }

    /// Disables event updates for the service.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopObserving {
        service: ServiceName,
    }

    impl StopObserving {
        pub fn new(service: impl Into<ServiceName>) -> Self {
            Self {
                service: service.into(),
            }
        }
    }

    impl Command for StopObserving {
        type Response = ();
        const METHOD: &'static str = "BackgroundService.stopObserving";
    }

    /// Set the recording state for the service.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRecording {
        #[serde(rename = "shouldRecord")]
        should_record: bool,
        service: ServiceName,
    }

    impl SetRecording {
        pub fn new(should_record: impl Into<bool>, service: impl Into<ServiceName>) -> Self {
            Self {
                should_record: should_record.into(),
                service: service.into(),
            }
        }
    }

    impl Command for SetRecording {
        type Response = ();
        const METHOD: &'static str = "BackgroundService.setRecording";
    }

    /// Clears all stored data for the service.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearEvents {
        service: ServiceName,
    }

    impl ClearEvents {
        pub fn new(service: impl Into<ServiceName>) -> Self {
            Self {
                service: service.into(),
            }
        }
    }

    impl Command for ClearEvents {
        type Response = ();
        const METHOD: &'static str = "BackgroundService.clearEvents";
    }

    /// Called when the recording state for the service has been updated.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RecordingStateChanged {
        #[serde(rename = "isRecording")]
        pub is_recording: bool,
        pub service: ServiceName,
    }

    impl RecordingStateChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("BackgroundService.recordingStateChanged")
        }
    }

    /// Called with all existing backgroundServiceEvents when enabled, and all new events afterwards if enabled and recording.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackgroundServiceEventReceived {
        #[serde(rename = "backgroundServiceEvent")]
        pub background_service_event: BackgroundServiceEvent,
    }

    impl BackgroundServiceEventReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("BackgroundService.backgroundServiceEventReceived")
        }
    }
}

pub mod bluetooth_emulation {
    use super::*;

    /// Indicates the various states of Central.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CentralState {
        #[serde(rename = "absent")]
        Absent,
        #[serde(rename = "powered-off")]
        PoweredOff,
        #[serde(rename = "powered-on")]
        PoweredOn,
    }
    impl From<&str> for CentralState {
        fn from(s: &str) -> Self {
            match s {
                "absent" => Self::Absent,
                "powered-off" => Self::PoweredOff,
                "powered-on" => Self::PoweredOn,
                _ => Self::Absent,
            }
        }
    }
    impl From<String> for CentralState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates the various types of GATT event.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum GATTOperationType {
        #[serde(rename = "connection")]
        Connection,
        #[serde(rename = "discovery")]
        Discovery,
    }
    impl From<&str> for GATTOperationType {
        fn from(s: &str) -> Self {
            match s {
                "connection" => Self::Connection,
                "discovery" => Self::Discovery,
                _ => Self::Connection,
            }
        }
    }
    impl From<String> for GATTOperationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates the various types of characteristic write.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CharacteristicWriteType {
        #[serde(rename = "write-default-deprecated")]
        WriteDefaultDeprecated,
        #[serde(rename = "write-with-response")]
        WriteWithResponse,
        #[serde(rename = "write-without-response")]
        WriteWithoutResponse,
    }
    impl From<&str> for CharacteristicWriteType {
        fn from(s: &str) -> Self {
            match s {
                "write-default-deprecated" => Self::WriteDefaultDeprecated,
                "write-with-response" => Self::WriteWithResponse,
                "write-without-response" => Self::WriteWithoutResponse,
                _ => Self::WriteDefaultDeprecated,
            }
        }
    }
    impl From<String> for CharacteristicWriteType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates the various types of characteristic operation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CharacteristicOperationType {
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "subscribe-to-notifications")]
        SubscribeToNotifications,
        #[serde(rename = "unsubscribe-from-notifications")]
        UnsubscribeFromNotifications,
    }
    impl From<&str> for CharacteristicOperationType {
        fn from(s: &str) -> Self {
            match s {
                "read" => Self::Read,
                "write" => Self::Write,
                "subscribe-to-notifications" => Self::SubscribeToNotifications,
                "unsubscribe-from-notifications" => Self::UnsubscribeFromNotifications,
                _ => Self::Read,
            }
        }
    }
    impl From<String> for CharacteristicOperationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates the various types of descriptor operation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DescriptorOperationType {
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "write")]
        Write,
    }
    impl From<&str> for DescriptorOperationType {
        fn from(s: &str) -> Self {
            match s {
                "read" => Self::Read,
                "write" => Self::Write,
                _ => Self::Read,
            }
        }
    }
    impl From<String> for DescriptorOperationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Stores the manufacturer data
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ManufacturerData {
        /// Company identifier https://bitbucket.org/bluetooth-SIG/public/src/main/assigned_numbers/company_identifiers/company_identifiers.yaml https://usb.org/developers
        pub key: i64,
        /// Manufacturer-specific data (Encoded as a base64 string when passed over JSON)
        pub data: String,
    }

    /// Stores the byte data of the advertisement packet sent by a Bluetooth device.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScanRecord {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub uuids: Option<Vec<String>>,
        /// Stores the external appearance description of the device.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub appearance: Option<i64>,
        /// Stores the transmission power of a broadcasting device.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "txPower")]
        pub tx_power: Option<i64>,
        /// Key is the company identifier and the value is an array of bytes of manufacturer specific data.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "manufacturerData")]
        pub manufacturer_data: Option<Vec<ManufacturerData>>,
    }

    /// Stores the advertisement packet information that is sent by a Bluetooth device.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScanEntry {
        #[serde(rename = "deviceAddress")]
        pub device_address: String,
        pub rssi: i64,
        #[serde(rename = "scanRecord")]
        pub scan_record: ScanRecord,
    }

    /// Describes the properties of a characteristic. This follows Bluetooth Core Specification BT 4.2 Vol 3 Part G 3.3.1. Characteristic Properties.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CharacteristicProperties {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub broadcast: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub read: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "writeWithoutResponse")]
        pub write_without_response: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub write: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub notify: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub indicate: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "authenticatedSignedWrites")]
        pub authenticated_signed_writes: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "extendedProperties")]
        pub extended_properties: Option<bool>,
    }

    /// Enable the BluetoothEmulation domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// State of the simulated central.
        state: CentralState,
        /// If the simulated central supports low-energy.
        #[serde(rename = "leSupported")]
        le_supported: bool,
    }

    impl Enable {
        pub fn new(state: impl Into<CentralState>, le_supported: impl Into<bool>) -> Self {
            Self {
                state: state.into(),
                le_supported: le_supported.into(),
            }
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.enable";
    }

    /// Set the state of the simulated central.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSimulatedCentralState {
        /// State of the simulated central.
        state: CentralState,
    }

    impl SetSimulatedCentralState {
        pub fn new(state: impl Into<CentralState>) -> Self {
            Self {
                state: state.into(),
            }
        }
    }

    impl Command for SetSimulatedCentralState {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.setSimulatedCentralState";
    }

    /// Disable the BluetoothEmulation domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.disable";
    }

    /// Simulates a peripheral with |address|, |name| and |knownServiceUuids| that has already been connected to the system.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulatePreconnectedPeripheral {
        address: String,
        name: String,
        #[serde(rename = "manufacturerData")]
        manufacturer_data: Vec<ManufacturerData>,
        #[serde(rename = "knownServiceUuids")]
        known_service_uuids: Vec<String>,
    }

    impl SimulatePreconnectedPeripheral {
        pub fn new(
            address: impl Into<String>,
            name: impl Into<String>,
            manufacturer_data: impl Into<Vec<ManufacturerData>>,
            known_service_uuids: impl Into<Vec<String>>,
        ) -> Self {
            Self {
                address: address.into(),
                name: name.into(),
                manufacturer_data: manufacturer_data.into(),
                known_service_uuids: known_service_uuids.into(),
            }
        }
    }

    impl Command for SimulatePreconnectedPeripheral {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulatePreconnectedPeripheral";
    }

    /// Simulates an advertisement packet described in |entry| being received by the central.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulateAdvertisement {
        entry: ScanEntry,
    }

    impl SimulateAdvertisement {
        pub fn new(entry: impl Into<ScanEntry>) -> Self {
            Self {
                entry: entry.into(),
            }
        }
    }

    impl Command for SimulateAdvertisement {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulateAdvertisement";
    }

    /// Simulates the response code from the peripheral with |address| for a GATT operation of |type|. The |code| value follows the HCI Error Codes from Bluetooth Core Specification Vol 2 Part D 1.3 List Of Error Codes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulateGattOperationResponse {
        address: String,
        #[serde(rename = "type")]
        type_: GATTOperationType,
        code: i64,
    }

    impl SimulateGattOperationResponse {
        pub fn new(
            address: impl Into<String>,
            type_: impl Into<GATTOperationType>,
            code: impl Into<i64>,
        ) -> Self {
            Self {
                address: address.into(),
                type_: type_.into(),
                code: code.into(),
            }
        }
    }

    impl Command for SimulateGattOperationResponse {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulateGATTOperationResponse";
    }

    /// Simulates the response from the characteristic with |characteristicId| for a characteristic operation of |type|. The |code| value follows the Error Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response. The |data| is expected to exist when simulating a successful read operation response.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulateCharacteristicOperationResponse {
        #[serde(rename = "characteristicId")]
        characteristic_id: String,
        #[serde(rename = "type")]
        type_: CharacteristicOperationType,
        code: i64,
        #[serde(skip_serializing_if = "Option::is_none")]
        data: Option<String>,
    }

    impl SimulateCharacteristicOperationResponse {
        pub fn new(
            characteristic_id: impl Into<String>,
            type_: impl Into<CharacteristicOperationType>,
            code: impl Into<i64>,
        ) -> Self {
            Self {
                characteristic_id: characteristic_id.into(),
                type_: type_.into(),
                code: code.into(),
                data: None,
            }
        }

        pub fn with_data(mut self, data: impl Into<String>) -> Self {
            self.data = Some(data.into());
            self
        }
    }

    impl Command for SimulateCharacteristicOperationResponse {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulateCharacteristicOperationResponse";
    }

    /// Simulates the response from the descriptor with |descriptorId| for a descriptor operation of |type|. The |code| value follows the Error Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response. The |data| is expected to exist when simulating a successful read operation response.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulateDescriptorOperationResponse {
        #[serde(rename = "descriptorId")]
        descriptor_id: String,
        #[serde(rename = "type")]
        type_: DescriptorOperationType,
        code: i64,
        #[serde(skip_serializing_if = "Option::is_none")]
        data: Option<String>,
    }

    impl SimulateDescriptorOperationResponse {
        pub fn new(
            descriptor_id: impl Into<String>,
            type_: impl Into<DescriptorOperationType>,
            code: impl Into<i64>,
        ) -> Self {
            Self {
                descriptor_id: descriptor_id.into(),
                type_: type_.into(),
                code: code.into(),
                data: None,
            }
        }

        pub fn with_data(mut self, data: impl Into<String>) -> Self {
            self.data = Some(data.into());
            self
        }
    }

    impl Command for SimulateDescriptorOperationResponse {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulateDescriptorOperationResponse";
    }

    /// Adds a service with |serviceUuid| to the peripheral with |address|.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddService {
        address: String,
        #[serde(rename = "serviceUuid")]
        service_uuid: String,
    }

    impl AddService {
        pub fn new(address: impl Into<String>, service_uuid: impl Into<String>) -> Self {
            Self {
                address: address.into(),
                service_uuid: service_uuid.into(),
            }
        }
    }

    impl Command for AddService {
        type Response = AddServiceResult;
        const METHOD: &'static str = "BluetoothEmulation.addService";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddServiceResult {
        /// An identifier that uniquely represents this service.
        #[serde(rename = "serviceId")]
        pub service_id: String,
    }

    /// Removes the service respresented by |serviceId| from the simulated central.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveService {
        #[serde(rename = "serviceId")]
        service_id: String,
    }

    impl RemoveService {
        pub fn new(service_id: impl Into<String>) -> Self {
            Self {
                service_id: service_id.into(),
            }
        }
    }

    impl Command for RemoveService {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.removeService";
    }

    /// Adds a characteristic with |characteristicUuid| and |properties| to the service represented by |serviceId|.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddCharacteristic {
        #[serde(rename = "serviceId")]
        service_id: String,
        #[serde(rename = "characteristicUuid")]
        characteristic_uuid: String,
        properties: CharacteristicProperties,
    }

    impl AddCharacteristic {
        pub fn new(
            service_id: impl Into<String>,
            characteristic_uuid: impl Into<String>,
            properties: impl Into<CharacteristicProperties>,
        ) -> Self {
            Self {
                service_id: service_id.into(),
                characteristic_uuid: characteristic_uuid.into(),
                properties: properties.into(),
            }
        }
    }

    impl Command for AddCharacteristic {
        type Response = AddCharacteristicResult;
        const METHOD: &'static str = "BluetoothEmulation.addCharacteristic";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddCharacteristicResult {
        /// An identifier that uniquely represents this characteristic.
        #[serde(rename = "characteristicId")]
        pub characteristic_id: String,
    }

    /// Removes the characteristic respresented by |characteristicId| from the simulated central.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveCharacteristic {
        #[serde(rename = "characteristicId")]
        characteristic_id: String,
    }

    impl RemoveCharacteristic {
        pub fn new(characteristic_id: impl Into<String>) -> Self {
            Self {
                characteristic_id: characteristic_id.into(),
            }
        }
    }

    impl Command for RemoveCharacteristic {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.removeCharacteristic";
    }

    /// Adds a descriptor with |descriptorUuid| to the characteristic respresented by |characteristicId|.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddDescriptor {
        #[serde(rename = "characteristicId")]
        characteristic_id: String,
        #[serde(rename = "descriptorUuid")]
        descriptor_uuid: String,
    }

    impl AddDescriptor {
        pub fn new(
            characteristic_id: impl Into<String>,
            descriptor_uuid: impl Into<String>,
        ) -> Self {
            Self {
                characteristic_id: characteristic_id.into(),
                descriptor_uuid: descriptor_uuid.into(),
            }
        }
    }

    impl Command for AddDescriptor {
        type Response = AddDescriptorResult;
        const METHOD: &'static str = "BluetoothEmulation.addDescriptor";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddDescriptorResult {
        /// An identifier that uniquely represents this descriptor.
        #[serde(rename = "descriptorId")]
        pub descriptor_id: String,
    }

    /// Removes the descriptor with |descriptorId| from the simulated central.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveDescriptor {
        #[serde(rename = "descriptorId")]
        descriptor_id: String,
    }

    impl RemoveDescriptor {
        pub fn new(descriptor_id: impl Into<String>) -> Self {
            Self {
                descriptor_id: descriptor_id.into(),
            }
        }
    }

    impl Command for RemoveDescriptor {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.removeDescriptor";
    }

    /// Simulates a GATT disconnection from the peripheral with |address|.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulateGattDisconnection {
        address: String,
    }

    impl SimulateGattDisconnection {
        pub fn new(address: impl Into<String>) -> Self {
            Self {
                address: address.into(),
            }
        }
    }

    impl Command for SimulateGattDisconnection {
        type Response = ();
        const METHOD: &'static str = "BluetoothEmulation.simulateGATTDisconnection";
    }

    /// Event for when a GATT operation of |type| to the peripheral with |address| happened.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GattOperationReceived {
        pub address: String,
        #[serde(rename = "type")]
        pub type_: GATTOperationType,
    }

    impl GattOperationReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("BluetoothEmulation.gattOperationReceived")
        }
    }

    /// Event for when a characteristic operation of |type| to the characteristic respresented by |characteristicId| happened. |data| and |writeType| is expected to exist when |type| is write.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CharacteristicOperationReceived {
        #[serde(rename = "characteristicId")]
        pub characteristic_id: String,
        #[serde(rename = "type")]
        pub type_: CharacteristicOperationType,
        pub data: Option<String>,
        #[serde(rename = "writeType")]
        pub write_type: Option<CharacteristicWriteType>,
    }

    impl CharacteristicOperationReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("BluetoothEmulation.characteristicOperationReceived")
        }
    }

    /// Event for when a descriptor operation of |type| to the descriptor respresented by |descriptorId| happened. |data| is expected to exist when |type| is write.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DescriptorOperationReceived {
        #[serde(rename = "descriptorId")]
        pub descriptor_id: String,
        #[serde(rename = "type")]
        pub type_: DescriptorOperationType,
        pub data: Option<String>,
    }

    impl DescriptorOperationReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("BluetoothEmulation.descriptorOperationReceived")
        }
    }
}

pub mod browser {
    use super::*;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type BrowserContextID = String;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type WindowID = i64;

    /// The state of the browser window.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum WindowState {
        #[serde(rename = "normal")]
        Normal,
        #[serde(rename = "minimized")]
        Minimized,
        #[serde(rename = "maximized")]
        Maximized,
        #[serde(rename = "fullscreen")]
        Fullscreen,
    }
    impl From<&str> for WindowState {
        fn from(s: &str) -> Self {
            match s {
                "normal" => Self::Normal,
                "minimized" => Self::Minimized,
                "maximized" => Self::Maximized,
                "fullscreen" => Self::Fullscreen,
                _ => Self::Normal,
            }
        }
    }
    impl From<String> for WindowState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Browser window bounds information
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Bounds {
        /// The offset from the left edge of the screen to the window in pixels.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub left: Option<i64>,
        /// The offset from the top edge of the screen to the window in pixels.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub top: Option<i64>,
        /// The window width in pixels.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub width: Option<i64>,
        /// The window height in pixels.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub height: Option<i64>,
        /// The window state. Default to normal.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "windowState")]
        pub window_state: Option<WindowState>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PermissionType {
        #[serde(rename = "ar")]
        Ar,
        #[serde(rename = "audioCapture")]
        AudioCapture,
        #[serde(rename = "automaticFullscreen")]
        AutomaticFullscreen,
        #[serde(rename = "backgroundFetch")]
        BackgroundFetch,
        #[serde(rename = "backgroundSync")]
        BackgroundSync,
        #[serde(rename = "cameraPanTiltZoom")]
        CameraPanTiltZoom,
        #[serde(rename = "capturedSurfaceControl")]
        CapturedSurfaceControl,
        #[serde(rename = "clipboardReadWrite")]
        ClipboardReadWrite,
        #[serde(rename = "clipboardSanitizedWrite")]
        ClipboardSanitizedWrite,
        #[serde(rename = "displayCapture")]
        DisplayCapture,
        #[serde(rename = "durableStorage")]
        DurableStorage,
        #[serde(rename = "geolocation")]
        Geolocation,
        #[serde(rename = "handTracking")]
        HandTracking,
        #[serde(rename = "idleDetection")]
        IdleDetection,
        #[serde(rename = "keyboardLock")]
        KeyboardLock,
        #[serde(rename = "localFonts")]
        LocalFonts,
        #[serde(rename = "localNetwork")]
        LocalNetwork,
        #[serde(rename = "localNetworkAccess")]
        LocalNetworkAccess,
        #[serde(rename = "loopbackNetwork")]
        LoopbackNetwork,
        #[serde(rename = "midi")]
        Midi,
        #[serde(rename = "midiSysex")]
        MidiSysex,
        #[serde(rename = "nfc")]
        Nfc,
        #[serde(rename = "notifications")]
        Notifications,
        #[serde(rename = "paymentHandler")]
        PaymentHandler,
        #[serde(rename = "periodicBackgroundSync")]
        PeriodicBackgroundSync,
        #[serde(rename = "pointerLock")]
        PointerLock,
        #[serde(rename = "protectedMediaIdentifier")]
        ProtectedMediaIdentifier,
        #[serde(rename = "sensors")]
        Sensors,
        #[serde(rename = "smartCard")]
        SmartCard,
        #[serde(rename = "speakerSelection")]
        SpeakerSelection,
        #[serde(rename = "storageAccess")]
        StorageAccess,
        #[serde(rename = "topLevelStorageAccess")]
        TopLevelStorageAccess,
        #[serde(rename = "videoCapture")]
        VideoCapture,
        #[serde(rename = "vr")]
        Vr,
        #[serde(rename = "wakeLockScreen")]
        WakeLockScreen,
        #[serde(rename = "wakeLockSystem")]
        WakeLockSystem,
        #[serde(rename = "webAppInstallation")]
        WebAppInstallation,
        #[serde(rename = "webPrinting")]
        WebPrinting,
        #[serde(rename = "windowManagement")]
        WindowManagement,
    }
    impl From<&str> for PermissionType {
        fn from(s: &str) -> Self {
            match s {
                "ar" => Self::Ar,
                "audioCapture" => Self::AudioCapture,
                "automaticFullscreen" => Self::AutomaticFullscreen,
                "backgroundFetch" => Self::BackgroundFetch,
                "backgroundSync" => Self::BackgroundSync,
                "cameraPanTiltZoom" => Self::CameraPanTiltZoom,
                "capturedSurfaceControl" => Self::CapturedSurfaceControl,
                "clipboardReadWrite" => Self::ClipboardReadWrite,
                "clipboardSanitizedWrite" => Self::ClipboardSanitizedWrite,
                "displayCapture" => Self::DisplayCapture,
                "durableStorage" => Self::DurableStorage,
                "geolocation" => Self::Geolocation,
                "handTracking" => Self::HandTracking,
                "idleDetection" => Self::IdleDetection,
                "keyboardLock" => Self::KeyboardLock,
                "localFonts" => Self::LocalFonts,
                "localNetwork" => Self::LocalNetwork,
                "localNetworkAccess" => Self::LocalNetworkAccess,
                "loopbackNetwork" => Self::LoopbackNetwork,
                "midi" => Self::Midi,
                "midiSysex" => Self::MidiSysex,
                "nfc" => Self::Nfc,
                "notifications" => Self::Notifications,
                "paymentHandler" => Self::PaymentHandler,
                "periodicBackgroundSync" => Self::PeriodicBackgroundSync,
                "pointerLock" => Self::PointerLock,
                "protectedMediaIdentifier" => Self::ProtectedMediaIdentifier,
                "sensors" => Self::Sensors,
                "smartCard" => Self::SmartCard,
                "speakerSelection" => Self::SpeakerSelection,
                "storageAccess" => Self::StorageAccess,
                "topLevelStorageAccess" => Self::TopLevelStorageAccess,
                "videoCapture" => Self::VideoCapture,
                "vr" => Self::Vr,
                "wakeLockScreen" => Self::WakeLockScreen,
                "wakeLockSystem" => Self::WakeLockSystem,
                "webAppInstallation" => Self::WebAppInstallation,
                "webPrinting" => Self::WebPrinting,
                "windowManagement" => Self::WindowManagement,
                _ => Self::Ar,
            }
        }
    }
    impl From<String> for PermissionType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PermissionSetting {
        #[serde(rename = "granted")]
        Granted,
        #[serde(rename = "denied")]
        Denied,
        #[serde(rename = "prompt")]
        Prompt,
    }
    impl From<&str> for PermissionSetting {
        fn from(s: &str) -> Self {
            match s {
                "granted" => Self::Granted,
                "denied" => Self::Denied,
                "prompt" => Self::Prompt,
                _ => Self::Granted,
            }
        }
    }
    impl From<String> for PermissionSetting {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Definition of PermissionDescriptor defined in the Permissions API: https://w3c.github.io/permissions/#dom-permissiondescriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PermissionDescriptor {
        /// Name of permission. See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
        pub name: String,
        /// For "midi" permission, may also specify sysex control.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub sysex: Option<bool>,
        /// For "push" permission, may specify userVisibleOnly. Note that userVisibleOnly = true is the only currently supported type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userVisibleOnly")]
        pub user_visible_only: Option<bool>,
        /// For "clipboard" permission, may specify allowWithoutSanitization.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "allowWithoutSanitization")]
        pub allow_without_sanitization: Option<bool>,
        /// For "fullscreen" permission, must specify allowWithoutGesture:true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "allowWithoutGesture")]
        pub allow_without_gesture: Option<bool>,
        /// For "camera" permission, may specify panTiltZoom.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "panTiltZoom")]
        pub pan_tilt_zoom: Option<bool>,
    }

    /// Browser command ids used by executeBrowserCommand.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum BrowserCommandId {
        #[serde(rename = "openTabSearch")]
        OpenTabSearch,
        #[serde(rename = "closeTabSearch")]
        CloseTabSearch,
        #[serde(rename = "openGlic")]
        OpenGlic,
    }
    impl From<&str> for BrowserCommandId {
        fn from(s: &str) -> Self {
            match s {
                "openTabSearch" => Self::OpenTabSearch,
                "closeTabSearch" => Self::CloseTabSearch,
                "openGlic" => Self::OpenGlic,
                _ => Self::OpenTabSearch,
            }
        }
    }
    impl From<String> for BrowserCommandId {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Chrome histogram bucket.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Bucket {
        /// Minimum value (inclusive).
        pub low: i64,
        /// Maximum value (exclusive).
        pub high: i64,
        /// Number of samples.
        pub count: i64,
    }

    /// Chrome histogram.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Histogram {
        /// Name.
        pub name: String,
        /// Sum of sample values.
        pub sum: i64,
        /// Total number of samples.
        pub count: i64,
        /// Buckets.
        pub buckets: Vec<Bucket>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PrivacySandboxAPI {
        #[serde(rename = "BiddingAndAuctionServices")]
        BiddingAndAuctionServices,
        #[serde(rename = "TrustedKeyValue")]
        TrustedKeyValue,
    }
    impl From<&str> for PrivacySandboxAPI {
        fn from(s: &str) -> Self {
            match s {
                "BiddingAndAuctionServices" => Self::BiddingAndAuctionServices,
                "TrustedKeyValue" => Self::TrustedKeyValue,
                _ => Self::BiddingAndAuctionServices,
            }
        }
    }
    impl From<String> for PrivacySandboxAPI {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Set permission settings for given embedding and embedded origins.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPermission {
        /// Descriptor of permission to override.
        permission: PermissionDescriptor,
        /// Setting of the permission.
        setting: PermissionSetting,
        /// Embedding origin the permission applies to, all origins if not specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        origin: Option<String>,
        /// Embedded origin the permission applies to. It is ignored unless the embedding origin is present and valid. If the embedding origin is provided but the embedded origin isn't, the embedding origin is used as the embedded origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "embeddedOrigin")]
        embedded_origin: Option<String>,
        /// Context to override. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
    }

    impl SetPermission {
        pub fn new(
            permission: impl Into<PermissionDescriptor>,
            setting: impl Into<PermissionSetting>,
        ) -> Self {
            Self {
                permission: permission.into(),
                setting: setting.into(),
                origin: None,
                embedded_origin: None,
                browser_context_id: None,
            }
        }

        pub fn with_origin(mut self, origin: impl Into<String>) -> Self {
            self.origin = Some(origin.into());
            self
        }

        pub fn with_embedded_origin(mut self, embedded_origin: impl Into<String>) -> Self {
            self.embedded_origin = Some(embedded_origin.into());
            self
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for SetPermission {
        type Response = ();
        const METHOD: &'static str = "Browser.setPermission";
    }

    /// Grant specific permissions to the given origin and reject all others. Deprecated. Use setPermission instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GrantPermissions {
        permissions: Vec<PermissionType>,
        /// Origin the permission applies to, all origins if not specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        origin: Option<String>,
        /// BrowserContext to override permissions. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
    }

    impl GrantPermissions {
        pub fn new(permissions: impl Into<Vec<PermissionType>>) -> Self {
            Self {
                permissions: permissions.into(),
                origin: None,
                browser_context_id: None,
            }
        }

        pub fn with_origin(mut self, origin: impl Into<String>) -> Self {
            self.origin = Some(origin.into());
            self
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for GrantPermissions {
        type Response = ();
        const METHOD: &'static str = "Browser.grantPermissions";
    }

    /// Reset all permission management for all origins.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetPermissions {
        /// BrowserContext to reset permissions. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
    }

    impl ResetPermissions {
        pub fn new() -> Self {
            Self {
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for ResetPermissions {
        type Response = ();
        const METHOD: &'static str = "Browser.resetPermissions";
    }

    /// Set the behavior when downloading a file.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDownloadBehavior {
        /// Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny). |allowAndName| allows download and names files according to their download guids.
        behavior: String,
        /// BrowserContext to set download behavior. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
        /// The default path to save downloaded files to. This is required if behavior is set to 'allow' or 'allowAndName'.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "downloadPath")]
        download_path: Option<String>,
        /// Whether to emit download events (defaults to false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "eventsEnabled")]
        events_enabled: Option<bool>,
    }

    impl SetDownloadBehavior {
        pub fn new(behavior: impl Into<String>) -> Self {
            Self {
                behavior: behavior.into(),
                browser_context_id: None,
                download_path: None,
                events_enabled: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }

        pub fn with_download_path(mut self, download_path: impl Into<String>) -> Self {
            self.download_path = Some(download_path.into());
            self
        }

        pub fn with_events_enabled(mut self, events_enabled: impl Into<bool>) -> Self {
            self.events_enabled = Some(events_enabled.into());
            self
        }
    }

    impl Command for SetDownloadBehavior {
        type Response = ();
        const METHOD: &'static str = "Browser.setDownloadBehavior";
    }

    /// Cancel a download if in progress
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CancelDownload {
        /// Global unique identifier of the download.
        guid: String,
        /// BrowserContext to perform the action in. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
    }

    impl CancelDownload {
        pub fn new(guid: impl Into<String>) -> Self {
            Self {
                guid: guid.into(),
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for CancelDownload {
        type Response = ();
        const METHOD: &'static str = "Browser.cancelDownload";
    }

    /// Close browser gracefully.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Close {}

    impl Close {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Close {
        type Response = ();
        const METHOD: &'static str = "Browser.close";
    }

    /// Crashes browser on the main thread.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Crash {}

    impl Crash {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Crash {
        type Response = ();
        const METHOD: &'static str = "Browser.crash";
    }

    /// Crashes GPU process.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CrashGpuProcess {}

    impl CrashGpuProcess {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CrashGpuProcess {
        type Response = ();
        const METHOD: &'static str = "Browser.crashGpuProcess";
    }

    /// Returns version information.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetVersion {}

    impl GetVersion {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetVersion {
        type Response = GetVersionResult;
        const METHOD: &'static str = "Browser.getVersion";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetVersionResult {
        /// Protocol version.
        #[serde(rename = "protocolVersion")]
        pub protocol_version: String,
        /// Product name.
        pub product: String,
        /// Product revision.
        pub revision: String,
        /// User-Agent.
        #[serde(rename = "userAgent")]
        pub user_agent: String,
        /// V8 version.
        #[serde(rename = "jsVersion")]
        pub js_version: String,
    }

    /// Returns the command line switches for the browser process if, and only if --enable-automation is on the commandline.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserCommandLine {}

    impl GetBrowserCommandLine {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetBrowserCommandLine {
        type Response = GetBrowserCommandLineResult;
        const METHOD: &'static str = "Browser.getBrowserCommandLine";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserCommandLineResult {
        /// Commandline parameters
        pub arguments: Vec<String>,
    }

    /// Get Chrome histograms.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHistograms {
        /// Requested substring in name. Only histograms which have query as a substring in their name are extracted. An empty or absent query returns all histograms.
        #[serde(skip_serializing_if = "Option::is_none")]
        query: Option<String>,
        /// If true, retrieve delta since last delta call.
        #[serde(skip_serializing_if = "Option::is_none")]
        delta: Option<bool>,
    }

    impl GetHistograms {
        pub fn new() -> Self {
            Self {
                query: None,
                delta: None,
            }
        }

        pub fn with_query(mut self, query: impl Into<String>) -> Self {
            self.query = Some(query.into());
            self
        }

        pub fn with_delta(mut self, delta: impl Into<bool>) -> Self {
            self.delta = Some(delta.into());
            self
        }
    }

    impl Command for GetHistograms {
        type Response = GetHistogramsResult;
        const METHOD: &'static str = "Browser.getHistograms";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHistogramsResult {
        /// Histograms.
        pub histograms: Vec<Histogram>,
    }

    /// Get a Chrome histogram by name.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHistogram {
        /// Requested histogram name.
        name: String,
        /// If true, retrieve delta since last delta call.
        #[serde(skip_serializing_if = "Option::is_none")]
        delta: Option<bool>,
    }

    impl GetHistogram {
        pub fn new(name: impl Into<String>) -> Self {
            Self {
                name: name.into(),
                delta: None,
            }
        }

        pub fn with_delta(mut self, delta: impl Into<bool>) -> Self {
            self.delta = Some(delta.into());
            self
        }
    }

    impl Command for GetHistogram {
        type Response = GetHistogramResult;
        const METHOD: &'static str = "Browser.getHistogram";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHistogramResult {
        /// Histogram.
        pub histogram: Histogram,
    }

    /// Get position and size of the browser window.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWindowBounds {
        /// Browser window id.
        #[serde(rename = "windowId")]
        window_id: WindowID,
    }

    impl GetWindowBounds {
        pub fn new(window_id: impl Into<WindowID>) -> Self {
            Self {
                window_id: window_id.into(),
            }
        }
    }

    impl Command for GetWindowBounds {
        type Response = GetWindowBoundsResult;
        const METHOD: &'static str = "Browser.getWindowBounds";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWindowBoundsResult {
        /// Bounds information of the window. When window state is 'minimized', the restored window position and size are returned.
        pub bounds: Bounds,
    }

    /// Get the browser window that contains the devtools target.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWindowForTarget {
        /// Devtools agent host id. If called as a part of the session, associated targetId is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetId")]
        target_id: Option<target::TargetID>,
    }

    impl GetWindowForTarget {
        pub fn new() -> Self {
            Self { target_id: None }
        }

        pub fn with_target_id(mut self, target_id: impl Into<target::TargetID>) -> Self {
            self.target_id = Some(target_id.into());
            self
        }
    }

    impl Command for GetWindowForTarget {
        type Response = GetWindowForTargetResult;
        const METHOD: &'static str = "Browser.getWindowForTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWindowForTargetResult {
        /// Browser window id.
        #[serde(rename = "windowId")]
        pub window_id: WindowID,
        /// Bounds information of the window. When window state is 'minimized', the restored window position and size are returned.
        pub bounds: Bounds,
    }

    /// Set position and/or size of the browser window.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetWindowBounds {
        /// Browser window id.
        #[serde(rename = "windowId")]
        window_id: WindowID,
        /// New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
        bounds: Bounds,
    }

    impl SetWindowBounds {
        pub fn new(window_id: impl Into<WindowID>, bounds: impl Into<Bounds>) -> Self {
            Self {
                window_id: window_id.into(),
                bounds: bounds.into(),
            }
        }
    }

    impl Command for SetWindowBounds {
        type Response = ();
        const METHOD: &'static str = "Browser.setWindowBounds";
    }

    /// Set size of the browser contents resizing browser window as necessary.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetContentsSize {
        /// Browser window id.
        #[serde(rename = "windowId")]
        window_id: WindowID,
        /// The window contents width in DIP. Assumes current width if omitted. Must be specified if 'height' is omitted.
        #[serde(skip_serializing_if = "Option::is_none")]
        width: Option<i64>,
        /// The window contents height in DIP. Assumes current height if omitted. Must be specified if 'width' is omitted.
        #[serde(skip_serializing_if = "Option::is_none")]
        height: Option<i64>,
    }

    impl SetContentsSize {
        pub fn new(window_id: impl Into<WindowID>) -> Self {
            Self {
                window_id: window_id.into(),
                width: None,
                height: None,
            }
        }

        pub fn with_width(mut self, width: impl Into<i64>) -> Self {
            self.width = Some(width.into());
            self
        }

        pub fn with_height(mut self, height: impl Into<i64>) -> Self {
            self.height = Some(height.into());
            self
        }
    }

    impl Command for SetContentsSize {
        type Response = ();
        const METHOD: &'static str = "Browser.setContentsSize";
    }

    /// Set dock tile details, platform-specific.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDockTile {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "badgeLabel")]
        badge_label: Option<String>,
        /// Png encoded image. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        image: Option<String>,
    }

    impl SetDockTile {
        pub fn new() -> Self {
            Self {
                badge_label: None,
                image: None,
            }
        }

        pub fn with_badge_label(mut self, badge_label: impl Into<String>) -> Self {
            self.badge_label = Some(badge_label.into());
            self
        }

        pub fn with_image(mut self, image: impl Into<String>) -> Self {
            self.image = Some(image.into());
            self
        }
    }

    impl Command for SetDockTile {
        type Response = ();
        const METHOD: &'static str = "Browser.setDockTile";
    }

    /// Invoke custom browser commands used by telemetry.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExecuteBrowserCommand {
        #[serde(rename = "commandId")]
        command_id: BrowserCommandId,
    }

    impl ExecuteBrowserCommand {
        pub fn new(command_id: impl Into<BrowserCommandId>) -> Self {
            Self {
                command_id: command_id.into(),
            }
        }
    }

    impl Command for ExecuteBrowserCommand {
        type Response = ();
        const METHOD: &'static str = "Browser.executeBrowserCommand";
    }

    /// Allows a site to use privacy sandbox features that require enrollment without the site actually being enrolled. Only supported on page targets.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddPrivacySandboxEnrollmentOverride {
        url: String,
    }

    impl AddPrivacySandboxEnrollmentOverride {
        pub fn new(url: impl Into<String>) -> Self {
            Self { url: url.into() }
        }
    }

    impl Command for AddPrivacySandboxEnrollmentOverride {
        type Response = ();
        const METHOD: &'static str = "Browser.addPrivacySandboxEnrollmentOverride";
    }

    /// Configures encryption keys used with a given privacy sandbox API to talk to a trusted coordinator. Since this is intended for test automation only, coordinatorOrigin must be a .test domain. No existing coordinator configuration for the origin may exist.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddPrivacySandboxCoordinatorKeyConfig {
        api: PrivacySandboxAPI,
        #[serde(rename = "coordinatorOrigin")]
        coordinator_origin: String,
        #[serde(rename = "keyConfig")]
        key_config: String,
        /// BrowserContext to perform the action in. When omitted, default browser context is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<BrowserContextID>,
    }

    impl AddPrivacySandboxCoordinatorKeyConfig {
        pub fn new(
            api: impl Into<PrivacySandboxAPI>,
            coordinator_origin: impl Into<String>,
            key_config: impl Into<String>,
        ) -> Self {
            Self {
                api: api.into(),
                coordinator_origin: coordinator_origin.into(),
                key_config: key_config.into(),
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for AddPrivacySandboxCoordinatorKeyConfig {
        type Response = ();
        const METHOD: &'static str = "Browser.addPrivacySandboxCoordinatorKeyConfig";
    }

    /// Fired when page is about to start a download.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DownloadWillBegin {
        /// Id of the frame that caused the download to begin.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// Global unique identifier of the download.
        pub guid: String,
        /// URL of the resource being downloaded.
        pub url: String,
        /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
        #[serde(rename = "suggestedFilename")]
        pub suggested_filename: String,
    }

    impl DownloadWillBegin {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Browser.downloadWillBegin")
        }
    }

    /// Fired when download makes progress. Last call has |done| == true.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DownloadProgress {
        /// Global unique identifier of the download.
        pub guid: String,
        /// Total expected bytes to download.
        #[serde(rename = "totalBytes")]
        pub total_bytes: f64,
        /// Total bytes received.
        #[serde(rename = "receivedBytes")]
        pub received_bytes: f64,
        /// Download status.
        pub state: String,
        /// If download is "completed", provides the path of the downloaded file. Depending on the platform, it is not guaranteed to be set, nor the file is guaranteed to exist.
        /// **EXPERIMENTAL**
        #[serde(rename = "filePath")]
        pub file_path: Option<String>,
    }

    impl DownloadProgress {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Browser.downloadProgress")
        }
    }
}

pub mod css {
    use super::*;

    /// Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StyleSheetOrigin {
        #[serde(rename = "injected")]
        Injected,
        #[serde(rename = "user-agent")]
        UserAgent,
        #[serde(rename = "inspector")]
        Inspector,
        #[serde(rename = "regular")]
        Regular,
    }
    impl From<&str> for StyleSheetOrigin {
        fn from(s: &str) -> Self {
            match s {
                "injected" => Self::Injected,
                "user-agent" => Self::UserAgent,
                "inspector" => Self::Inspector,
                "regular" => Self::Regular,
                _ => Self::Injected,
            }
        }
    }
    impl From<String> for StyleSheetOrigin {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// CSS rule collection for a single pseudo style.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PseudoElementMatches {
        /// Pseudo element type.
        #[serde(rename = "pseudoType")]
        pub pseudo_type: dom::PseudoType,
        /// Pseudo element custom ident.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<String>,
        /// Matches of CSS rules applicable to the pseudo style.
        pub matches: Vec<RuleMatch>,
    }

    /// CSS style coming from animations with the name of the animation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSAnimationStyle {
        /// The name of the animation.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// The style coming from the animation.
        pub style: CSSStyle,
    }

    /// Inherited CSS rule collection from ancestor node.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InheritedStyleEntry {
        /// The ancestor node's inline style, if any, in the style inheritance chain.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CSSStyle>,
        /// Matches of CSS rules matching the ancestor node in the style inheritance chain.
        #[serde(rename = "matchedCSSRules")]
        pub matched_css_rules: Vec<RuleMatch>,
    }

    /// Inherited CSS style collection for animated styles from ancestor node.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InheritedAnimatedStyleEntry {
        /// Styles coming from the animations of the ancestor, if any, in the style inheritance chain.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "animationStyles")]
        pub animation_styles: Option<Vec<CSSAnimationStyle>>,
        /// The style coming from the transitions of the ancestor, if any, in the style inheritance chain.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "transitionsStyle")]
        pub transitions_style: Option<CSSStyle>,
    }

    /// Inherited pseudo element matches from pseudos of an ancestor node.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InheritedPseudoElementMatches {
        /// Matches of pseudo styles from the pseudos of an ancestor node.
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Vec<PseudoElementMatches>,
    }

    /// Match data for a CSS rule.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RuleMatch {
        /// CSS rule in the match.
        pub rule: CSSRule,
        /// Matching selector indices in the rule's selectorList selectors (0-based).
        #[serde(rename = "matchingSelectors")]
        pub matching_selectors: Vec<i64>,
    }

    /// Data for a simple selector (these are delimited by commas in a selector list).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Value {
        /// Value text.
        pub text: String,
        /// Value range in the underlying resource (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Specificity of the selector.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub specificity: Option<Specificity>,
    }

    /// Specificity: https://drafts.csswg.org/selectors/#specificity-rules
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Specificity {
        /// The a component, which represents the number of ID selectors.
        pub a: i64,
        /// The b component, which represents the number of class selectors, attributes selectors, and pseudo-classes.
        pub b: i64,
        /// The c component, which represents the number of type selectors and pseudo-elements.
        pub c: i64,
    }

    /// Selector list data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SelectorList {
        /// Selectors in the list.
        pub selectors: Vec<Value>,
        /// Rule selector text.
        pub text: String,
    }

    /// CSS stylesheet metainformation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSStyleSheetHeader {
        /// The stylesheet identifier.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
        /// Owner frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// Stylesheet resource URL. Empty if this is a constructed stylesheet created using new CSSStyleSheet() (but non-empty if this is a constructed stylesheet imported as a CSS module script).
        #[serde(rename = "sourceURL")]
        pub source_url: String,
        /// URL of source map associated with the stylesheet (if any).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        /// Stylesheet origin.
        pub origin: StyleSheetOrigin,
        /// Stylesheet title.
        pub title: String,
        /// The backend id for the owner node of the stylesheet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ownerNode")]
        pub owner_node: Option<dom::BackendNodeId>,
        /// Denotes whether the stylesheet is disabled.
        pub disabled: bool,
        /// Whether the sourceURL field value comes from the sourceURL comment.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        /// Whether this stylesheet is created for STYLE tag by parser. This flag is not set for document.written STYLE tags.
        #[serde(rename = "isInline")]
        pub is_inline: bool,
        /// Whether this stylesheet is mutable. Inline stylesheets become mutable after they have been modified via CSSOM API. `<link>` element's stylesheets become mutable only if DevTools modifies them. Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
        #[serde(rename = "isMutable")]
        pub is_mutable: bool,
        /// True if this stylesheet is created through new CSSStyleSheet() or imported as a CSS module script.
        #[serde(rename = "isConstructed")]
        pub is_constructed: bool,
        /// Line offset of the stylesheet within the resource (zero based).
        #[serde(rename = "startLine")]
        pub start_line: f64,
        /// Column offset of the stylesheet within the resource (zero based).
        #[serde(rename = "startColumn")]
        pub start_column: f64,
        /// Size of the content (in characters).
        pub length: f64,
        /// Line offset of the end of the stylesheet within the resource (zero based).
        #[serde(rename = "endLine")]
        pub end_line: f64,
        /// Column offset of the end of the stylesheet within the resource (zero based).
        #[serde(rename = "endColumn")]
        pub end_column: f64,
        /// If the style sheet was loaded from a network resource, this indicates when the resource failed to load
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "loadingFailed")]
        pub loading_failed: Option<bool>,
    }

    /// CSS rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSRule {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Rule selector data.
        #[serde(rename = "selectorList")]
        pub selector_list: SelectorList,
        /// Array of selectors from ancestor style rules, sorted by distance from the current rule.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nestingSelectors")]
        pub nesting_selectors: Option<Vec<String>>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated style declaration.
        pub style: CSSStyle,
        /// The BackendNodeId of the DOM node that constitutes the origin tree scope of this rule.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "originTreeScopeNodeId")]
        pub origin_tree_scope_node_id: Option<dom::BackendNodeId>,
        /// Media list array (for rules involving media queries). The array enumerates media queries starting with the innermost one, going outwards.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub media: Option<Vec<CSSMedia>>,
        /// Container query list array (for rules involving container queries). The array enumerates container queries starting with the innermost one, going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerQueries")]
        pub container_queries: Option<Vec<CSSContainerQuery>>,
        /// @supports CSS at-rule array. The array enumerates @supports at-rules starting with the innermost one, going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub supports: Option<Vec<CSSSupports>>,
        /// Cascade layer array. Contains the layer hierarchy that this rule belongs to starting with the innermost layer and going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub layers: Option<Vec<CSSLayer>>,
        /// @scope CSS at-rule array. The array enumerates @scope at-rules starting with the innermost one, going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub scopes: Option<Vec<CSSScope>>,
        /// The array keeps the types of ancestor CSSRules from the innermost going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ruleTypes")]
        pub rule_types: Option<Vec<CSSRuleType>>,
        /// @starting-style CSS at-rule array. The array enumerates @starting-style at-rules starting with the innermost one, going outwards.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "startingStyles")]
        pub starting_styles: Option<Vec<CSSStartingStyle>>,
    }

    /// Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors. This list only contains rule types that are collected during the ancestor rule collection.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CSSRuleType {
        #[serde(rename = "MediaRule")]
        MediaRule,
        #[serde(rename = "SupportsRule")]
        SupportsRule,
        #[serde(rename = "ContainerRule")]
        ContainerRule,
        #[serde(rename = "LayerRule")]
        LayerRule,
        #[serde(rename = "ScopeRule")]
        ScopeRule,
        #[serde(rename = "StyleRule")]
        StyleRule,
        #[serde(rename = "StartingStyleRule")]
        StartingStyleRule,
    }
    impl From<&str> for CSSRuleType {
        fn from(s: &str) -> Self {
            match s {
                "MediaRule" => Self::MediaRule,
                "SupportsRule" => Self::SupportsRule,
                "ContainerRule" => Self::ContainerRule,
                "LayerRule" => Self::LayerRule,
                "ScopeRule" => Self::ScopeRule,
                "StyleRule" => Self::StyleRule,
                "StartingStyleRule" => Self::StartingStyleRule,
                _ => Self::MediaRule,
            }
        }
    }
    impl From<String> for CSSRuleType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// CSS coverage information.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RuleUsage {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
        /// Offset of the start of the rule (including selector) from the beginning of the stylesheet.
        #[serde(rename = "startOffset")]
        pub start_offset: f64,
        /// Offset of the end of the rule body from the beginning of the stylesheet.
        #[serde(rename = "endOffset")]
        pub end_offset: f64,
        /// Indicates whether the rule was actually used by some element in the page.
        pub used: bool,
    }

    /// Text range within a resource. All numbers are zero-based.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SourceRange {
        /// Start line of range.
        #[serde(rename = "startLine")]
        pub start_line: i64,
        /// Start column of range (inclusive).
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        /// End line of range
        #[serde(rename = "endLine")]
        pub end_line: i64,
        /// End column of range (exclusive).
        #[serde(rename = "endColumn")]
        pub end_column: i64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ShorthandEntry {
        /// Shorthand name.
        pub name: String,
        /// Shorthand value.
        pub value: String,
        /// Whether the property has "!important" annotation (implies `false` if absent).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub important: Option<bool>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSComputedStyleProperty {
        /// Computed style property name.
        pub name: String,
        /// Computed style property value.
        pub value: String,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ComputedStyleExtraFields {
        /// Returns whether or not this node is being rendered with base appearance, which happens when it has its appearance property set to base/base-select or it is in the subtree of an element being rendered with base appearance.
        #[serde(rename = "isAppearanceBase")]
        pub is_appearance_base: bool,
    }

    /// CSS style representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSStyle {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// CSS properties in the style.
        #[serde(rename = "cssProperties")]
        pub css_properties: Vec<CSSProperty>,
        /// Computed values for all shorthands found in the style.
        #[serde(rename = "shorthandEntries")]
        pub shorthand_entries: Vec<ShorthandEntry>,
        /// Style declaration text (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cssText")]
        pub css_text: Option<String>,
        /// Style declaration range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
    }

    /// CSS property declaration data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSProperty {
        /// The property name.
        pub name: String,
        /// The property value.
        pub value: String,
        /// Whether the property has "!important" annotation (implies `false` if absent).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub important: Option<bool>,
        /// Whether the property is implicit (implies `false` if absent).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub implicit: Option<bool>,
        /// The full property text as specified in the style.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub text: Option<String>,
        /// Whether the property is understood by the browser (implies `true` if absent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parsedOk")]
        pub parsed_ok: Option<bool>,
        /// Whether the property is disabled by the user (present for source-based properties only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        /// The entire property range in the enclosing style declaration (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Parsed longhand components of this property if it is a shorthand. This field will be empty if the given property is not a shorthand.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "longhandProperties")]
        pub longhand_properties: Option<Vec<CSSProperty>>,
    }

    /// CSS media rule descriptor.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSMedia {
        /// Media query text.
        pub text: String,
        /// Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline stylesheet's STYLE tag.
        pub source: String,
        /// URL of the document containing the media query description.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceURL")]
        pub source_url: Option<String>,
        /// The associated rule (@media or @import) header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Array of media queries.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "mediaList")]
        pub media_list: Option<Vec<MediaQuery>>,
    }

    /// Media query descriptor.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MediaQuery {
        /// Array of media query expressions.
        pub expressions: Vec<MediaQueryExpression>,
        /// Whether the media query condition is satisfied.
        pub active: bool,
    }

    /// Media query expression descriptor.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MediaQueryExpression {
        /// Media query expression value.
        pub value: f64,
        /// Media query expression units.
        pub unit: String,
        /// Media query expression feature.
        pub feature: String,
        /// The associated range of the value text in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "valueRange")]
        pub value_range: Option<SourceRange>,
        /// Computed length of media query expression (if applicable).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "computedLength")]
        pub computed_length: Option<f64>,
    }

    /// CSS container query rule descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSContainerQuery {
        /// Container query text.
        pub text: String,
        /// The associated rule header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Optional name for the container.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// Optional physical axes queried for the container.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "physicalAxes")]
        pub physical_axes: Option<dom::PhysicalAxes>,
        /// Optional logical axes queried for the container.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "logicalAxes")]
        pub logical_axes: Option<dom::LogicalAxes>,
        /// true if the query contains scroll-state() queries.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "queriesScrollState")]
        pub queries_scroll_state: Option<bool>,
        /// true if the query contains anchored() queries.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "queriesAnchored")]
        pub queries_anchored: Option<bool>,
    }

    /// CSS Supports at-rule descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSSupports {
        /// Supports rule text.
        pub text: String,
        /// Whether the supports condition is satisfied.
        pub active: bool,
        /// The associated rule header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
    }

    /// CSS Scope at-rule descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSScope {
        /// Scope rule text.
        pub text: String,
        /// The associated rule header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
    }

    /// CSS Layer at-rule descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSLayer {
        /// Layer name.
        pub text: String,
        /// The associated rule header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
    }

    /// CSS Starting Style at-rule descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSStartingStyle {
        /// The associated rule header range in the enclosing stylesheet (if available).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub range: Option<SourceRange>,
        /// Identifier of the stylesheet containing this object (if exists).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
    }

    /// CSS Layer data.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSLayerData {
        /// Layer name.
        pub name: String,
        /// Direct sub-layers
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "subLayers")]
        pub sub_layers: Option<Vec<CSSLayerData>>,
        /// Layer order. The order determines the order of the layer in the cascade order. A higher number has higher priority in the cascade order.
        pub order: f64,
    }

    /// Information about amount of glyphs that were rendered with given font.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlatformFontUsage {
        /// Font's family name reported by platform.
        #[serde(rename = "familyName")]
        pub family_name: String,
        /// Font's PostScript name reported by platform.
        #[serde(rename = "postScriptName")]
        pub post_script_name: String,
        /// Indicates if the font was downloaded or resolved locally.
        #[serde(rename = "isCustomFont")]
        pub is_custom_font: bool,
        /// Amount of glyphs that were rendered with this font.
        #[serde(rename = "glyphCount")]
        pub glyph_count: f64,
    }

    /// Information about font variation axes for variable fonts
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FontVariationAxis {
        /// The font-variation-setting tag (a.k.a. "axis tag").
        pub tag: String,
        /// Human-readable variation name in the default language (normally, "en").
        pub name: String,
        /// The minimum value (inclusive) the font supports for this tag.
        #[serde(rename = "minValue")]
        pub min_value: f64,
        /// The maximum value (inclusive) the font supports for this tag.
        #[serde(rename = "maxValue")]
        pub max_value: f64,
        /// The default value.
        #[serde(rename = "defaultValue")]
        pub default_value: f64,
    }

    /// Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions and additional information such as platformFontFamily and fontVariationAxes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FontFace {
        /// The font-family.
        #[serde(rename = "fontFamily")]
        pub font_family: String,
        /// The font-style.
        #[serde(rename = "fontStyle")]
        pub font_style: String,
        /// The font-variant.
        #[serde(rename = "fontVariant")]
        pub font_variant: String,
        /// The font-weight.
        #[serde(rename = "fontWeight")]
        pub font_weight: String,
        /// The font-stretch.
        #[serde(rename = "fontStretch")]
        pub font_stretch: String,
        /// The font-display.
        #[serde(rename = "fontDisplay")]
        pub font_display: String,
        /// The unicode-range.
        #[serde(rename = "unicodeRange")]
        pub unicode_range: String,
        /// The src.
        pub src: String,
        /// The resolved platform font family
        #[serde(rename = "platformFontFamily")]
        pub platform_font_family: String,
        /// Available variation settings (a.k.a. "axes").
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fontVariationAxes")]
        pub font_variation_axes: Option<Vec<FontVariationAxis>>,
    }

    /// CSS try rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSTryRule {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated style declaration.
        pub style: CSSStyle,
    }

    /// CSS @position-try rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSPositionTryRule {
        /// The prelude dashed-ident name
        pub name: Value,
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated style declaration.
        pub style: CSSStyle,
        pub active: bool,
    }

    /// CSS keyframes rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSKeyframesRule {
        /// Animation name.
        #[serde(rename = "animationName")]
        pub animation_name: Value,
        /// List of keyframes.
        pub keyframes: Vec<CSSKeyframeRule>,
    }

    /// Representation of a custom property registration through CSS.registerProperty
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSPropertyRegistration {
        #[serde(rename = "propertyName")]
        pub property_name: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "initialValue")]
        pub initial_value: Option<Value>,
        pub inherits: bool,
        pub syntax: String,
    }

    /// CSS generic @rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSAtRule {
        /// Type of at-rule.
        #[serde(rename = "type")]
        pub type_: String,
        /// Subsection of font-feature-values, if this is a subsection.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub subsection: Option<String>,
        /// LINT.ThenChange(//third_party/blink/renderer/core/inspector/inspector_style_sheet.cc:FontVariantAlternatesFeatureType,//third_party/blink/renderer/core/inspector/inspector_css_agent.cc:FontVariantAlternatesFeatureType) Associated name, if applicable.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<Value>,
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated style declaration.
        pub style: CSSStyle,
    }

    /// CSS property at-rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSPropertyRule {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated property name.
        #[serde(rename = "propertyName")]
        pub property_name: Value,
        /// Associated style declaration.
        pub style: CSSStyle,
    }

    /// CSS function argument representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSFunctionParameter {
        /// The parameter name.
        pub name: String,
        /// The parameter type.
        #[serde(rename = "type")]
        pub type_: String,
    }

    /// CSS function conditional block representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSFunctionConditionNode {
        /// Media query for this conditional block. Only one type of condition should be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub media: Option<CSSMedia>,
        /// Container query for this conditional block. Only one type of condition should be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerQueries")]
        pub container_queries: Option<CSSContainerQuery>,
        /// @supports CSS at-rule condition. Only one type of condition should be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub supports: Option<CSSSupports>,
        /// Block body.
        pub children: Vec<CSSFunctionNode>,
        /// The condition text.
        #[serde(rename = "conditionText")]
        pub condition_text: String,
    }

    /// Section of the body of a CSS function rule.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSFunctionNode {
        /// A conditional block. If set, style should not be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub condition: Option<CSSFunctionConditionNode>,
        /// Values set by this node. If set, condition should not be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub style: Option<CSSStyle>,
    }

    /// CSS function at-rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSFunctionRule {
        /// Name of the function.
        pub name: Value,
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// List of parameters.
        pub parameters: Vec<CSSFunctionParameter>,
        /// Function body.
        pub children: Vec<CSSFunctionNode>,
    }

    /// CSS keyframe rule representation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSKeyframeRule {
        /// The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: Option<dom::StyleSheetId>,
        /// Parent stylesheet's origin.
        pub origin: StyleSheetOrigin,
        /// Associated key text.
        #[serde(rename = "keyText")]
        pub key_text: Value,
        /// Associated style declaration.
        pub style: CSSStyle,
    }

    /// A descriptor of operation to mutate style declaration text.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StyleDeclarationEdit {
        /// The css style sheet identifier.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
        /// The range of the style text in the enclosing stylesheet.
        pub range: SourceRange,
        /// New style text.
        pub text: String,
    }

    /// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the position specified by `location`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddRule {
        /// The css style sheet identifier where a new rule should be inserted.
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        /// The text of a new rule.
        #[serde(rename = "ruleText")]
        rule_text: String,
        /// Text position of a new rule in the target style sheet.
        location: SourceRange,
        /// NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeForPropertySyntaxValidation")]
        node_for_property_syntax_validation: Option<dom::NodeId>,
    }

    impl AddRule {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            rule_text: impl Into<String>,
            location: impl Into<SourceRange>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                rule_text: rule_text.into(),
                location: location.into(),
                node_for_property_syntax_validation: None,
            }
        }

        pub fn with_node_for_property_syntax_validation(
            mut self,
            node_for_property_syntax_validation: impl Into<dom::NodeId>,
        ) -> Self {
            self.node_for_property_syntax_validation =
                Some(node_for_property_syntax_validation.into());
            self
        }
    }

    impl Command for AddRule {
        type Response = AddRuleResult;
        const METHOD: &'static str = "CSS.addRule";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddRuleResult {
        /// The newly created rule.
        pub rule: CSSRule,
    }

    /// Returns all class names from specified stylesheet.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CollectClassNames {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
    }

    impl CollectClassNames {
        pub fn new(style_sheet_id: impl Into<dom::StyleSheetId>) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
            }
        }
    }

    impl Command for CollectClassNames {
        type Response = CollectClassNamesResult;
        const METHOD: &'static str = "CSS.collectClassNames";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CollectClassNamesResult {
        /// Class name list.
        #[serde(rename = "classNames")]
        pub class_names: Vec<String>,
    }

    /// Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateStyleSheet {
        /// Identifier of the frame where "via-inspector" stylesheet should be created.
        #[serde(rename = "frameId")]
        frame_id: page::FrameId,
        /// If true, creates a new stylesheet for every call. If false, returns a stylesheet previously created by a call with force=false for the frame's document if it exists or creates a new stylesheet (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        force: Option<bool>,
    }

    impl CreateStyleSheet {
        pub fn new(frame_id: impl Into<page::FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
                force: None,
            }
        }

        pub fn with_force(mut self, force: impl Into<bool>) -> Self {
            self.force = Some(force.into());
            self
        }
    }

    impl Command for CreateStyleSheet {
        type Response = CreateStyleSheetResult;
        const METHOD: &'static str = "CSS.createStyleSheet";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateStyleSheetResult {
        /// Identifier of the created "via-inspector" stylesheet.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
    }

    /// Disables the CSS agent for the given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "CSS.disable";
    }

    /// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "CSS.enable";
    }

    /// Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ForcePseudoState {
        /// The element id for which to force the pseudo state.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Element pseudo classes to force when computing the element's style.
        #[serde(rename = "forcedPseudoClasses")]
        forced_pseudo_classes: Vec<String>,
    }

    impl ForcePseudoState {
        pub fn new(
            node_id: impl Into<dom::NodeId>,
            forced_pseudo_classes: impl Into<Vec<String>>,
        ) -> Self {
            Self {
                node_id: node_id.into(),
                forced_pseudo_classes: forced_pseudo_classes.into(),
            }
        }
    }

    impl Command for ForcePseudoState {
        type Response = ();
        const METHOD: &'static str = "CSS.forcePseudoState";
    }

    /// Ensures that the given node is in its starting-style state.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ForceStartingStyle {
        /// The element id for which to force the starting-style state.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Boolean indicating if this is on or off.
        forced: bool,
    }

    impl ForceStartingStyle {
        pub fn new(node_id: impl Into<dom::NodeId>, forced: impl Into<bool>) -> Self {
            Self {
                node_id: node_id.into(),
                forced: forced.into(),
            }
        }
    }

    impl Command for ForceStartingStyle {
        type Response = ();
        const METHOD: &'static str = "CSS.forceStartingStyle";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBackgroundColors {
        /// Id of the node to get background colors for.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetBackgroundColors {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetBackgroundColors {
        type Response = GetBackgroundColorsResult;
        const METHOD: &'static str = "CSS.getBackgroundColors";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBackgroundColorsResult {
        /// The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).
        #[serde(rename = "backgroundColors")]
        pub background_colors: Option<Vec<String>>,
        /// The computed font size for this node, as a CSS computed value string (e.g. '12px').
        #[serde(rename = "computedFontSize")]
        pub computed_font_size: Option<String>,
        /// The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or '100').
        #[serde(rename = "computedFontWeight")]
        pub computed_font_weight: Option<String>,
    }

    /// Returns the computed style for a DOM node identified by `nodeId`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetComputedStyleForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetComputedStyleForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetComputedStyleForNode {
        type Response = GetComputedStyleForNodeResult;
        const METHOD: &'static str = "CSS.getComputedStyleForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetComputedStyleForNodeResult {
        /// Computed style for the specified DOM node.
        #[serde(rename = "computedStyle")]
        pub computed_style: Vec<CSSComputedStyleProperty>,
        /// A list of non-standard "extra fields" which blink stores alongside each computed style.
        /// **EXPERIMENTAL**
        #[serde(rename = "extraFields")]
        pub extra_fields: Option<ComputedStyleExtraFields>,
    }

    /// Resolve the specified values in the context of the provided element. For example, a value of '1em' is evaluated according to the computed 'font-size' of the element and a value 'calc(1px + 2px)' will be resolved to '3px'. If the `propertyName` was specified the `values` are resolved as if they were property's declaration. If a value cannot be parsed according to the provided property syntax, the value is parsed using combined syntax as if null `propertyName` was provided. If the value cannot be resolved even then, return the provided value without any changes. Note: this function currently does not resolve CSS random() function, it returns unmodified random() function parts.`
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveValues {
        /// Cascade-dependent keywords (revert/revert-layer) do not work.
        values: Vec<String>,
        /// Id of the node in whose context the expression is evaluated
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Only longhands and custom property names are accepted.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "propertyName")]
        property_name: Option<String>,
        /// Pseudo element type, only works for pseudo elements that generate elements in the tree, such as ::before and ::after.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoType")]
        pseudo_type: Option<dom::PseudoType>,
        /// Pseudo element custom ident.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoIdentifier")]
        pseudo_identifier: Option<String>,
    }

    impl ResolveValues {
        pub fn new(values: impl Into<Vec<String>>, node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                values: values.into(),
                node_id: node_id.into(),
                property_name: None,
                pseudo_type: None,
                pseudo_identifier: None,
            }
        }

        pub fn with_property_name(mut self, property_name: impl Into<String>) -> Self {
            self.property_name = Some(property_name.into());
            self
        }

        pub fn with_pseudo_type(mut self, pseudo_type: impl Into<dom::PseudoType>) -> Self {
            self.pseudo_type = Some(pseudo_type.into());
            self
        }

        pub fn with_pseudo_identifier(mut self, pseudo_identifier: impl Into<String>) -> Self {
            self.pseudo_identifier = Some(pseudo_identifier.into());
            self
        }
    }

    impl Command for ResolveValues {
        type Response = ResolveValuesResult;
        const METHOD: &'static str = "CSS.resolveValues";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveValuesResult {
        pub results: Vec<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLonghandProperties {
        #[serde(rename = "shorthandName")]
        shorthand_name: String,
        value: String,
    }

    impl GetLonghandProperties {
        pub fn new(shorthand_name: impl Into<String>, value: impl Into<String>) -> Self {
            Self {
                shorthand_name: shorthand_name.into(),
                value: value.into(),
            }
        }
    }

    impl Command for GetLonghandProperties {
        type Response = GetLonghandPropertiesResult;
        const METHOD: &'static str = "CSS.getLonghandProperties";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLonghandPropertiesResult {
        #[serde(rename = "longhandProperties")]
        pub longhand_properties: Vec<CSSProperty>,
    }

    /// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by `nodeId`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInlineStylesForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetInlineStylesForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetInlineStylesForNode {
        type Response = GetInlineStylesForNodeResult;
        const METHOD: &'static str = "CSS.getInlineStylesForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInlineStylesForNodeResult {
        /// Inline style for the specified DOM node.
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CSSStyle>,
        /// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
        #[serde(rename = "attributesStyle")]
        pub attributes_style: Option<CSSStyle>,
    }

    /// Returns the styles coming from animations & transitions including the animation & transition styles coming from inheritance chain.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnimatedStylesForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetAnimatedStylesForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetAnimatedStylesForNode {
        type Response = GetAnimatedStylesForNodeResult;
        const METHOD: &'static str = "CSS.getAnimatedStylesForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnimatedStylesForNodeResult {
        /// Styles coming from animations.
        #[serde(rename = "animationStyles")]
        pub animation_styles: Option<Vec<CSSAnimationStyle>>,
        /// Style coming from transitions.
        #[serde(rename = "transitionsStyle")]
        pub transitions_style: Option<CSSStyle>,
        /// Inherited style entries for animationsStyle and transitionsStyle from the inheritance chain of the element.
        pub inherited: Option<Vec<InheritedAnimatedStyleEntry>>,
    }

    /// Returns requested styles for a DOM node identified by `nodeId`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMatchedStylesForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetMatchedStylesForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetMatchedStylesForNode {
        type Response = GetMatchedStylesForNodeResult;
        const METHOD: &'static str = "CSS.getMatchedStylesForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMatchedStylesForNodeResult {
        /// Inline style for the specified DOM node.
        #[serde(rename = "inlineStyle")]
        pub inline_style: Option<CSSStyle>,
        /// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
        #[serde(rename = "attributesStyle")]
        pub attributes_style: Option<CSSStyle>,
        /// CSS rules matching this node, from all applicable stylesheets.
        #[serde(rename = "matchedCSSRules")]
        pub matched_css_rules: Option<Vec<RuleMatch>>,
        /// Pseudo style matches for this node.
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Option<Vec<PseudoElementMatches>>,
        /// A chain of inherited styles (from the immediate node parent up to the DOM tree root).
        pub inherited: Option<Vec<InheritedStyleEntry>>,
        /// A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
        #[serde(rename = "inheritedPseudoElements")]
        pub inherited_pseudo_elements: Option<Vec<InheritedPseudoElementMatches>>,
        /// A list of CSS keyframed animations matching this node.
        #[serde(rename = "cssKeyframesRules")]
        pub css_keyframes_rules: Option<Vec<CSSKeyframesRule>>,
        /// A list of CSS @position-try rules matching this node, based on the position-try-fallbacks property.
        #[serde(rename = "cssPositionTryRules")]
        pub css_position_try_rules: Option<Vec<CSSPositionTryRule>>,
        /// Index of the active fallback in the applied position-try-fallback property, will not be set if there is no active position-try fallback.
        #[serde(rename = "activePositionFallbackIndex")]
        pub active_position_fallback_index: Option<i64>,
        /// A list of CSS at-property rules matching this node.
        #[serde(rename = "cssPropertyRules")]
        pub css_property_rules: Option<Vec<CSSPropertyRule>>,
        /// A list of CSS property registrations matching this node.
        #[serde(rename = "cssPropertyRegistrations")]
        pub css_property_registrations: Option<Vec<CSSPropertyRegistration>>,
        /// A list of simple @rules matching this node or its pseudo-elements.
        #[serde(rename = "cssAtRules")]
        pub css_at_rules: Option<Vec<CSSAtRule>>,
        /// Id of the first parent element that does not have display: contents.
        /// **EXPERIMENTAL**
        #[serde(rename = "parentLayoutNodeId")]
        pub parent_layout_node_id: Option<dom::NodeId>,
        /// A list of CSS at-function rules referenced by styles of this node.
        /// **EXPERIMENTAL**
        #[serde(rename = "cssFunctionRules")]
        pub css_function_rules: Option<Vec<CSSFunctionRule>>,
    }

    /// Returns the values of the default UA-defined environment variables used in env()
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEnvironmentVariables {}

    impl GetEnvironmentVariables {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetEnvironmentVariables {
        type Response = GetEnvironmentVariablesResult;
        const METHOD: &'static str = "CSS.getEnvironmentVariables";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEnvironmentVariablesResult {
        #[serde(rename = "environmentVariables")]
        pub environment_variables: serde_json::Value,
    }

    /// Returns all media queries parsed by the rendering engine.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMediaQueries {}

    impl GetMediaQueries {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetMediaQueries {
        type Response = GetMediaQueriesResult;
        const METHOD: &'static str = "CSS.getMediaQueries";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMediaQueriesResult {
        pub medias: Vec<CSSMedia>,
    }

    /// Requests information about platform fonts which we used to render child TextNodes in the given node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPlatformFontsForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetPlatformFontsForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetPlatformFontsForNode {
        type Response = GetPlatformFontsForNodeResult;
        const METHOD: &'static str = "CSS.getPlatformFontsForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPlatformFontsForNodeResult {
        /// Usage statistics for every employed platform font.
        pub fonts: Vec<PlatformFontUsage>,
    }

    /// Returns the current textual content for a stylesheet.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStyleSheetText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
    }

    impl GetStyleSheetText {
        pub fn new(style_sheet_id: impl Into<dom::StyleSheetId>) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
            }
        }
    }

    impl Command for GetStyleSheetText {
        type Response = GetStyleSheetTextResult;
        const METHOD: &'static str = "CSS.getStyleSheetText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStyleSheetTextResult {
        /// The stylesheet text.
        pub text: String,
    }

    /// Returns all layers parsed by the rendering engine for the tree scope of a node. Given a DOM element identified by nodeId, getLayersForNode returns the root layer for the nearest ancestor document or shadow root. The layer root contains the full layer tree for the tree scope and their ordering.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLayersForNode {
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetLayersForNode {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetLayersForNode {
        type Response = GetLayersForNodeResult;
        const METHOD: &'static str = "CSS.getLayersForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLayersForNodeResult {
        #[serde(rename = "rootLayer")]
        pub root_layer: CSSLayerData,
    }

    /// Given a CSS selector text and a style sheet ID, getLocationForSelector returns an array of locations of the CSS selector in the style sheet.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLocationForSelector {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        #[serde(rename = "selectorText")]
        selector_text: String,
    }

    impl GetLocationForSelector {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            selector_text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                selector_text: selector_text.into(),
            }
        }
    }

    impl Command for GetLocationForSelector {
        type Response = GetLocationForSelectorResult;
        const METHOD: &'static str = "CSS.getLocationForSelector";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLocationForSelectorResult {
        pub ranges: Vec<SourceRange>,
    }

    /// Starts tracking the given node for the computed style updates and whenever the computed style is updated for node, it queues a `computedStyleUpdated` event with throttling. There can only be 1 node tracked for computed style updates so passing a new node id removes tracking from the previous node. Pass `undefined` to disable tracking.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackComputedStyleUpdatesForNode {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
    }

    impl TrackComputedStyleUpdatesForNode {
        pub fn new() -> Self {
            Self { node_id: None }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }
    }

    impl Command for TrackComputedStyleUpdatesForNode {
        type Response = ();
        const METHOD: &'static str = "CSS.trackComputedStyleUpdatesForNode";
    }

    /// Starts tracking the given computed styles for updates. The specified array of properties replaces the one previously specified. Pass empty array to disable tracking. Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified. The changes to computed style properties are only tracked for nodes pushed to the front-end by the DOM agent. If no changes to the tracked properties occur after the node has been pushed to the front-end, no updates will be issued for the node.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackComputedStyleUpdates {
        #[serde(rename = "propertiesToTrack")]
        properties_to_track: Vec<CSSComputedStyleProperty>,
    }

    impl TrackComputedStyleUpdates {
        pub fn new(properties_to_track: impl Into<Vec<CSSComputedStyleProperty>>) -> Self {
            Self {
                properties_to_track: properties_to_track.into(),
            }
        }
    }

    impl Command for TrackComputedStyleUpdates {
        type Response = ();
        const METHOD: &'static str = "CSS.trackComputedStyleUpdates";
    }

    /// Polls the next batch of computed style updates.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeComputedStyleUpdates {}

    impl TakeComputedStyleUpdates {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for TakeComputedStyleUpdates {
        type Response = TakeComputedStyleUpdatesResult;
        const METHOD: &'static str = "CSS.takeComputedStyleUpdates";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeComputedStyleUpdatesResult {
        /// The list of node Ids that have their tracked computed styles updated.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<dom::NodeId>,
    }

    /// Find a rule with the given active property for the given node and set the new value for this property
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEffectivePropertyValueForNode {
        /// The element id for which to set property.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        #[serde(rename = "propertyName")]
        property_name: String,
        value: String,
    }

    impl SetEffectivePropertyValueForNode {
        pub fn new(
            node_id: impl Into<dom::NodeId>,
            property_name: impl Into<String>,
            value: impl Into<String>,
        ) -> Self {
            Self {
                node_id: node_id.into(),
                property_name: property_name.into(),
                value: value.into(),
            }
        }
    }

    impl Command for SetEffectivePropertyValueForNode {
        type Response = ();
        const METHOD: &'static str = "CSS.setEffectivePropertyValueForNode";
    }

    /// Modifies the property rule property name.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPropertyRulePropertyName {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        #[serde(rename = "propertyName")]
        property_name: String,
    }

    impl SetPropertyRulePropertyName {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            property_name: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                property_name: property_name.into(),
            }
        }
    }

    impl Command for SetPropertyRulePropertyName {
        type Response = SetPropertyRulePropertyNameResult;
        const METHOD: &'static str = "CSS.setPropertyRulePropertyName";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPropertyRulePropertyNameResult {
        /// The resulting key text after modification.
        #[serde(rename = "propertyName")]
        pub property_name: Value,
    }

    /// Modifies the keyframe rule key text.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetKeyframeKey {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        #[serde(rename = "keyText")]
        key_text: String,
    }

    impl SetKeyframeKey {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            key_text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                key_text: key_text.into(),
            }
        }
    }

    impl Command for SetKeyframeKey {
        type Response = SetKeyframeKeyResult;
        const METHOD: &'static str = "CSS.setKeyframeKey";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetKeyframeKeyResult {
        /// The resulting key text after modification.
        #[serde(rename = "keyText")]
        pub key_text: Value,
    }

    /// Modifies the rule selector.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetMediaText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        text: String,
    }

    impl SetMediaText {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                text: text.into(),
            }
        }
    }

    impl Command for SetMediaText {
        type Response = SetMediaTextResult;
        const METHOD: &'static str = "CSS.setMediaText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetMediaTextResult {
        /// The resulting CSS media rule after modification.
        pub media: CSSMedia,
    }

    /// Modifies the expression of a container query.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetContainerQueryText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        text: String,
    }

    impl SetContainerQueryText {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                text: text.into(),
            }
        }
    }

    impl Command for SetContainerQueryText {
        type Response = SetContainerQueryTextResult;
        const METHOD: &'static str = "CSS.setContainerQueryText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetContainerQueryTextResult {
        /// The resulting CSS container query rule after modification.
        #[serde(rename = "containerQuery")]
        pub container_query: CSSContainerQuery,
    }

    /// Modifies the expression of a supports at-rule.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSupportsText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        text: String,
    }

    impl SetSupportsText {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                text: text.into(),
            }
        }
    }

    impl Command for SetSupportsText {
        type Response = SetSupportsTextResult;
        const METHOD: &'static str = "CSS.setSupportsText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSupportsTextResult {
        /// The resulting CSS Supports rule after modification.
        pub supports: CSSSupports,
    }

    /// Modifies the expression of a scope at-rule.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScopeText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        text: String,
    }

    impl SetScopeText {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            text: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                text: text.into(),
            }
        }
    }

    impl Command for SetScopeText {
        type Response = SetScopeTextResult;
        const METHOD: &'static str = "CSS.setScopeText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScopeTextResult {
        /// The resulting CSS Scope rule after modification.
        pub scope: CSSScope,
    }

    /// Modifies the rule selector.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRuleSelector {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        range: SourceRange,
        selector: String,
    }

    impl SetRuleSelector {
        pub fn new(
            style_sheet_id: impl Into<dom::StyleSheetId>,
            range: impl Into<SourceRange>,
            selector: impl Into<String>,
        ) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                range: range.into(),
                selector: selector.into(),
            }
        }
    }

    impl Command for SetRuleSelector {
        type Response = SetRuleSelectorResult;
        const METHOD: &'static str = "CSS.setRuleSelector";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRuleSelectorResult {
        /// The resulting selector list after modification.
        #[serde(rename = "selectorList")]
        pub selector_list: SelectorList,
    }

    /// Sets the new stylesheet text.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStyleSheetText {
        #[serde(rename = "styleSheetId")]
        style_sheet_id: dom::StyleSheetId,
        text: String,
    }

    impl SetStyleSheetText {
        pub fn new(style_sheet_id: impl Into<dom::StyleSheetId>, text: impl Into<String>) -> Self {
            Self {
                style_sheet_id: style_sheet_id.into(),
                text: text.into(),
            }
        }
    }

    impl Command for SetStyleSheetText {
        type Response = SetStyleSheetTextResult;
        const METHOD: &'static str = "CSS.setStyleSheetText";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStyleSheetTextResult {
        /// URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
    }

    /// Applies specified style edits one after another in the given order.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStyleTexts {
        edits: Vec<StyleDeclarationEdit>,
        /// NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeForPropertySyntaxValidation")]
        node_for_property_syntax_validation: Option<dom::NodeId>,
    }

    impl SetStyleTexts {
        pub fn new(edits: impl Into<Vec<StyleDeclarationEdit>>) -> Self {
            Self {
                edits: edits.into(),
                node_for_property_syntax_validation: None,
            }
        }

        pub fn with_node_for_property_syntax_validation(
            mut self,
            node_for_property_syntax_validation: impl Into<dom::NodeId>,
        ) -> Self {
            self.node_for_property_syntax_validation =
                Some(node_for_property_syntax_validation.into());
            self
        }
    }

    impl Command for SetStyleTexts {
        type Response = SetStyleTextsResult;
        const METHOD: &'static str = "CSS.setStyleTexts";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStyleTextsResult {
        /// The resulting styles after modification.
        pub styles: Vec<CSSStyle>,
    }

    /// Enables the selector recording.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartRuleUsageTracking {}

    impl StartRuleUsageTracking {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StartRuleUsageTracking {
        type Response = ();
        const METHOD: &'static str = "CSS.startRuleUsageTracking";
    }

    /// Stop tracking rule usage and return the list of rules that were used since last call to `takeCoverageDelta` (or since start of coverage instrumentation).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopRuleUsageTracking {}

    impl StopRuleUsageTracking {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopRuleUsageTracking {
        type Response = StopRuleUsageTrackingResult;
        const METHOD: &'static str = "CSS.stopRuleUsageTracking";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopRuleUsageTrackingResult {
        #[serde(rename = "ruleUsage")]
        pub rule_usage: Vec<RuleUsage>,
    }

    /// Obtain list of rules that became used since last call to this method (or since start of coverage instrumentation).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeCoverageDelta {}

    impl TakeCoverageDelta {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for TakeCoverageDelta {
        type Response = TakeCoverageDeltaResult;
        const METHOD: &'static str = "CSS.takeCoverageDelta";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeCoverageDeltaResult {
        pub coverage: Vec<RuleUsage>,
        /// Monotonically increasing time, in seconds.
        pub timestamp: f64,
    }

    /// Enables/disables rendering of local CSS fonts (enabled by default).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetLocalFontsEnabled {
        /// Whether rendering of local fonts is enabled.
        enabled: bool,
    }

    impl SetLocalFontsEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetLocalFontsEnabled {
        type Response = ();
        const METHOD: &'static str = "CSS.setLocalFontsEnabled";
    }

    /// Fires whenever a web font is updated. A non-empty font parameter indicates a successfully loaded web font.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FontsUpdated {
        /// The web font that has loaded.
        pub font: Option<FontFace>,
    }

    impl FontsUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.fontsUpdated")
        }
    }

    /// Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MediaQueryResultChanged {}

    impl MediaQueryResultChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.mediaQueryResultChanged")
        }
    }

    /// Fired whenever an active document stylesheet is added.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StyleSheetAdded {
        /// Added stylesheet metainfo.
        pub header: CSSStyleSheetHeader,
    }

    impl StyleSheetAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.styleSheetAdded")
        }
    }

    /// Fired whenever a stylesheet is changed as a result of the client operation.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StyleSheetChanged {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
    }

    impl StyleSheetChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.styleSheetChanged")
        }
    }

    /// Fired whenever an active document stylesheet is removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StyleSheetRemoved {
        /// Identifier of the removed stylesheet.
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: dom::StyleSheetId,
    }

    impl StyleSheetRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.styleSheetRemoved")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ComputedStyleUpdated {
        /// The node id that has updated computed styles.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    impl ComputedStyleUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("CSS.computedStyleUpdated")
        }
    }
}

pub mod cache_storage {
    use super::*;

    /// Unique identifier of the Cache object.
    pub type CacheId = String;

    /// type of HTTP response cached
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CachedResponseType {
        #[serde(rename = "basic")]
        Basic,
        #[serde(rename = "cors")]
        Cors,
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "opaqueResponse")]
        OpaqueResponse,
        #[serde(rename = "opaqueRedirect")]
        OpaqueRedirect,
    }
    impl From<&str> for CachedResponseType {
        fn from(s: &str) -> Self {
            match s {
                "basic" => Self::Basic,
                "cors" => Self::Cors,
                "default" => Self::Default,
                "error" => Self::Error,
                "opaqueResponse" => Self::OpaqueResponse,
                "opaqueRedirect" => Self::OpaqueRedirect,
                _ => Self::Basic,
            }
        }
    }
    impl From<String> for CachedResponseType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Data entry.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DataEntry {
        /// Request URL.
        #[serde(rename = "requestURL")]
        pub request_url: String,
        /// Request method.
        #[serde(rename = "requestMethod")]
        pub request_method: String,
        /// Request headers
        #[serde(rename = "requestHeaders")]
        pub request_headers: Vec<Header>,
        /// Number of seconds since epoch.
        #[serde(rename = "responseTime")]
        pub response_time: f64,
        /// HTTP response status code.
        #[serde(rename = "responseStatus")]
        pub response_status: i64,
        /// HTTP response status text.
        #[serde(rename = "responseStatusText")]
        pub response_status_text: String,
        /// HTTP response type
        #[serde(rename = "responseType")]
        pub response_type: CachedResponseType,
        /// Response headers
        #[serde(rename = "responseHeaders")]
        pub response_headers: Vec<Header>,
    }

    /// Cache identifier.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Cache {
        /// An opaque unique id of the cache.
        #[serde(rename = "cacheId")]
        pub cache_id: CacheId,
        /// Security origin of the cache.
        #[serde(rename = "securityOrigin")]
        pub security_origin: String,
        /// Storage key of the cache.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        /// Storage bucket of the cache.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        pub storage_bucket: Option<storage::StorageBucket>,
        /// The name of the cache.
        #[serde(rename = "cacheName")]
        pub cache_name: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Header {
        pub name: String,
        pub value: String,
    }

    /// Cached response
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CachedResponse {
        /// Entry content, base64-encoded. (Encoded as a base64 string when passed over JSON)
        pub body: String,
    }

    /// Deletes a cache.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteCache {
        /// Id of cache for deletion.
        #[serde(rename = "cacheId")]
        cache_id: CacheId,
    }

    impl DeleteCache {
        pub fn new(cache_id: impl Into<CacheId>) -> Self {
            Self {
                cache_id: cache_id.into(),
            }
        }
    }

    impl Command for DeleteCache {
        type Response = ();
        const METHOD: &'static str = "CacheStorage.deleteCache";
    }

    /// Deletes a cache entry.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteEntry {
        /// Id of cache where the entry will be deleted.
        #[serde(rename = "cacheId")]
        cache_id: CacheId,
        /// URL spec of the request.
        request: String,
    }

    impl DeleteEntry {
        pub fn new(cache_id: impl Into<CacheId>, request: impl Into<String>) -> Self {
            Self {
                cache_id: cache_id.into(),
                request: request.into(),
            }
        }
    }

    impl Command for DeleteEntry {
        type Response = ();
        const METHOD: &'static str = "CacheStorage.deleteEntry";
    }

    /// Requests cache names.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestCacheNames {
        /// At least and at most one of securityOrigin, storageKey, storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
    }

    impl RequestCacheNames {
        pub fn new() -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for RequestCacheNames {
        type Response = RequestCacheNamesResult;
        const METHOD: &'static str = "CacheStorage.requestCacheNames";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestCacheNamesResult {
        /// Caches for the security origin.
        pub caches: Vec<Cache>,
    }

    /// Fetches cache entry.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestCachedResponse {
        /// Id of cache that contains the entry.
        #[serde(rename = "cacheId")]
        cache_id: CacheId,
        /// URL spec of the request.
        #[serde(rename = "requestURL")]
        request_url: String,
        /// headers of the request.
        #[serde(rename = "requestHeaders")]
        request_headers: Vec<Header>,
    }

    impl RequestCachedResponse {
        pub fn new(
            cache_id: impl Into<CacheId>,
            request_url: impl Into<String>,
            request_headers: impl Into<Vec<Header>>,
        ) -> Self {
            Self {
                cache_id: cache_id.into(),
                request_url: request_url.into(),
                request_headers: request_headers.into(),
            }
        }
    }

    impl Command for RequestCachedResponse {
        type Response = RequestCachedResponseResult;
        const METHOD: &'static str = "CacheStorage.requestCachedResponse";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestCachedResponseResult {
        /// Response read from the cache.
        pub response: CachedResponse,
    }

    /// Requests data from cache.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestEntries {
        /// ID of cache to get entries from.
        #[serde(rename = "cacheId")]
        cache_id: CacheId,
        /// Number of records to skip.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "skipCount")]
        skip_count: Option<i64>,
        /// Number of records to fetch.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pageSize")]
        page_size: Option<i64>,
        /// If present, only return the entries containing this substring in the path
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pathFilter")]
        path_filter: Option<String>,
    }

    impl RequestEntries {
        pub fn new(cache_id: impl Into<CacheId>) -> Self {
            Self {
                cache_id: cache_id.into(),
                skip_count: None,
                page_size: None,
                path_filter: None,
            }
        }

        pub fn with_skip_count(mut self, skip_count: impl Into<i64>) -> Self {
            self.skip_count = Some(skip_count.into());
            self
        }

        pub fn with_page_size(mut self, page_size: impl Into<i64>) -> Self {
            self.page_size = Some(page_size.into());
            self
        }

        pub fn with_path_filter(mut self, path_filter: impl Into<String>) -> Self {
            self.path_filter = Some(path_filter.into());
            self
        }
    }

    impl Command for RequestEntries {
        type Response = RequestEntriesResult;
        const METHOD: &'static str = "CacheStorage.requestEntries";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestEntriesResult {
        /// Array of object store data entries.
        #[serde(rename = "cacheDataEntries")]
        pub cache_data_entries: Vec<DataEntry>,
        /// Count of returned entries from this storage. If pathFilter is empty, it is the count of all entries from this storage.
        #[serde(rename = "returnCount")]
        pub return_count: f64,
    }
}

pub mod cast {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Sink {
        pub name: String,
        pub id: String,
        /// Text describing the current session. Present only if there is an active session on the sink.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub session: Option<String>,
    }

    /// Starts observing for sinks that can be used for tab mirroring, and if set, sinks compatible with |presentationUrl| as well. When sinks are found, a |sinksUpdated| event is fired. Also starts observing for issue messages. When an issue is added or removed, an |issueUpdated| event is fired.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "presentationUrl")]
        presentation_url: Option<String>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                presentation_url: None,
            }
        }

        pub fn with_presentation_url(mut self, presentation_url: impl Into<String>) -> Self {
            self.presentation_url = Some(presentation_url.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Cast.enable";
    }

    /// Stops observing for sinks and issues.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Cast.disable";
    }

    /// Sets a sink to be used when the web page requests the browser to choose a sink via Presentation API, Remote Playback API, or Cast SDK.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSinkToUse {
        #[serde(rename = "sinkName")]
        sink_name: String,
    }

    impl SetSinkToUse {
        pub fn new(sink_name: impl Into<String>) -> Self {
            Self {
                sink_name: sink_name.into(),
            }
        }
    }

    impl Command for SetSinkToUse {
        type Response = ();
        const METHOD: &'static str = "Cast.setSinkToUse";
    }

    /// Starts mirroring the desktop to the sink.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartDesktopMirroring {
        #[serde(rename = "sinkName")]
        sink_name: String,
    }

    impl StartDesktopMirroring {
        pub fn new(sink_name: impl Into<String>) -> Self {
            Self {
                sink_name: sink_name.into(),
            }
        }
    }

    impl Command for StartDesktopMirroring {
        type Response = ();
        const METHOD: &'static str = "Cast.startDesktopMirroring";
    }

    /// Starts mirroring the tab to the sink.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartTabMirroring {
        #[serde(rename = "sinkName")]
        sink_name: String,
    }

    impl StartTabMirroring {
        pub fn new(sink_name: impl Into<String>) -> Self {
            Self {
                sink_name: sink_name.into(),
            }
        }
    }

    impl Command for StartTabMirroring {
        type Response = ();
        const METHOD: &'static str = "Cast.startTabMirroring";
    }

    /// Stops the active Cast session on the sink.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopCasting {
        #[serde(rename = "sinkName")]
        sink_name: String,
    }

    impl StopCasting {
        pub fn new(sink_name: impl Into<String>) -> Self {
            Self {
                sink_name: sink_name.into(),
            }
        }
    }

    impl Command for StopCasting {
        type Response = ();
        const METHOD: &'static str = "Cast.stopCasting";
    }

    /// This is fired whenever the list of available sinks changes. A sink is a device or a software surface that you can cast to.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SinksUpdated {
        pub sinks: Vec<Sink>,
    }

    impl SinksUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Cast.sinksUpdated")
        }
    }

    /// This is fired whenever the outstanding issue/error message changes. |issueMessage| is empty if there is no issue.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IssueUpdated {
        #[serde(rename = "issueMessage")]
        pub issue_message: String,
    }

    impl IssueUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Cast.issueUpdated")
        }
    }
}

pub mod dom {
    use super::*;

    /// Unique DOM node identifier.
    pub type NodeId = i64;

    /// Unique DOM node identifier used to reference a node that may not have been pushed to the front-end.
    pub type BackendNodeId = i64;

    /// Unique identifier for a CSS stylesheet.
    pub type StyleSheetId = String;

    /// Backend node with a friendly name.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackendNode {
        /// `Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        /// `Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
    }

    /// Pseudo element type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PseudoType {
        #[serde(rename = "first-line")]
        FirstLine,
        #[serde(rename = "first-letter")]
        FirstLetter,
        #[serde(rename = "checkmark")]
        Checkmark,
        #[serde(rename = "before")]
        Before,
        #[serde(rename = "after")]
        After,
        #[serde(rename = "picker-icon")]
        PickerIcon,
        #[serde(rename = "interest-hint")]
        InterestHint,
        #[serde(rename = "marker")]
        Marker,
        #[serde(rename = "backdrop")]
        Backdrop,
        #[serde(rename = "column")]
        Column,
        #[serde(rename = "selection")]
        Selection,
        #[serde(rename = "search-text")]
        SearchText,
        #[serde(rename = "target-text")]
        TargetText,
        #[serde(rename = "spelling-error")]
        SpellingError,
        #[serde(rename = "grammar-error")]
        GrammarError,
        #[serde(rename = "highlight")]
        Highlight,
        #[serde(rename = "first-line-inherited")]
        FirstLineInherited,
        #[serde(rename = "scroll-marker")]
        ScrollMarker,
        #[serde(rename = "scroll-marker-group")]
        ScrollMarkerGroup,
        #[serde(rename = "scroll-button")]
        ScrollButton,
        #[serde(rename = "scrollbar")]
        Scrollbar,
        #[serde(rename = "scrollbar-thumb")]
        ScrollbarThumb,
        #[serde(rename = "scrollbar-button")]
        ScrollbarButton,
        #[serde(rename = "scrollbar-track")]
        ScrollbarTrack,
        #[serde(rename = "scrollbar-track-piece")]
        ScrollbarTrackPiece,
        #[serde(rename = "scrollbar-corner")]
        ScrollbarCorner,
        #[serde(rename = "resizer")]
        Resizer,
        #[serde(rename = "input-list-button")]
        InputListButton,
        #[serde(rename = "view-transition")]
        ViewTransition,
        #[serde(rename = "view-transition-group")]
        ViewTransitionGroup,
        #[serde(rename = "view-transition-image-pair")]
        ViewTransitionImagePair,
        #[serde(rename = "view-transition-group-children")]
        ViewTransitionGroupChildren,
        #[serde(rename = "view-transition-old")]
        ViewTransitionOld,
        #[serde(rename = "view-transition-new")]
        ViewTransitionNew,
        #[serde(rename = "placeholder")]
        Placeholder,
        #[serde(rename = "file-selector-button")]
        FileSelectorButton,
        #[serde(rename = "details-content")]
        DetailsContent,
        #[serde(rename = "picker")]
        Picker,
        #[serde(rename = "permission-icon")]
        PermissionIcon,
        #[serde(rename = "overscroll-area-parent")]
        OverscrollAreaParent,
    }
    impl From<&str> for PseudoType {
        fn from(s: &str) -> Self {
            match s {
                "first-line" => Self::FirstLine,
                "first-letter" => Self::FirstLetter,
                "checkmark" => Self::Checkmark,
                "before" => Self::Before,
                "after" => Self::After,
                "picker-icon" => Self::PickerIcon,
                "interest-hint" => Self::InterestHint,
                "marker" => Self::Marker,
                "backdrop" => Self::Backdrop,
                "column" => Self::Column,
                "selection" => Self::Selection,
                "search-text" => Self::SearchText,
                "target-text" => Self::TargetText,
                "spelling-error" => Self::SpellingError,
                "grammar-error" => Self::GrammarError,
                "highlight" => Self::Highlight,
                "first-line-inherited" => Self::FirstLineInherited,
                "scroll-marker" => Self::ScrollMarker,
                "scroll-marker-group" => Self::ScrollMarkerGroup,
                "scroll-button" => Self::ScrollButton,
                "scrollbar" => Self::Scrollbar,
                "scrollbar-thumb" => Self::ScrollbarThumb,
                "scrollbar-button" => Self::ScrollbarButton,
                "scrollbar-track" => Self::ScrollbarTrack,
                "scrollbar-track-piece" => Self::ScrollbarTrackPiece,
                "scrollbar-corner" => Self::ScrollbarCorner,
                "resizer" => Self::Resizer,
                "input-list-button" => Self::InputListButton,
                "view-transition" => Self::ViewTransition,
                "view-transition-group" => Self::ViewTransitionGroup,
                "view-transition-image-pair" => Self::ViewTransitionImagePair,
                "view-transition-group-children" => Self::ViewTransitionGroupChildren,
                "view-transition-old" => Self::ViewTransitionOld,
                "view-transition-new" => Self::ViewTransitionNew,
                "placeholder" => Self::Placeholder,
                "file-selector-button" => Self::FileSelectorButton,
                "details-content" => Self::DetailsContent,
                "picker" => Self::Picker,
                "permission-icon" => Self::PermissionIcon,
                "overscroll-area-parent" => Self::OverscrollAreaParent,
                _ => Self::FirstLine,
            }
        }
    }
    impl From<String> for PseudoType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Shadow root type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ShadowRootType {
        #[serde(rename = "user-agent")]
        UserAgent,
        #[serde(rename = "open")]
        Open,
        #[serde(rename = "closed")]
        Closed,
    }
    impl From<&str> for ShadowRootType {
        fn from(s: &str) -> Self {
            match s {
                "user-agent" => Self::UserAgent,
                "open" => Self::Open,
                "closed" => Self::Closed,
                _ => Self::UserAgent,
            }
        }
    }
    impl From<String> for ShadowRootType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Document compatibility mode.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CompatibilityMode {
        #[serde(rename = "QuirksMode")]
        QuirksMode,
        #[serde(rename = "LimitedQuirksMode")]
        LimitedQuirksMode,
        #[serde(rename = "NoQuirksMode")]
        NoQuirksMode,
    }
    impl From<&str> for CompatibilityMode {
        fn from(s: &str) -> Self {
            match s {
                "QuirksMode" => Self::QuirksMode,
                "LimitedQuirksMode" => Self::LimitedQuirksMode,
                "NoQuirksMode" => Self::NoQuirksMode,
                _ => Self::QuirksMode,
            }
        }
    }
    impl From<String> for CompatibilityMode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// ContainerSelector physical axes
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PhysicalAxes {
        #[serde(rename = "Horizontal")]
        Horizontal,
        #[serde(rename = "Vertical")]
        Vertical,
        #[serde(rename = "Both")]
        Both,
    }
    impl From<&str> for PhysicalAxes {
        fn from(s: &str) -> Self {
            match s {
                "Horizontal" => Self::Horizontal,
                "Vertical" => Self::Vertical,
                "Both" => Self::Both,
                _ => Self::Horizontal,
            }
        }
    }
    impl From<String> for PhysicalAxes {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// ContainerSelector logical axes
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LogicalAxes {
        #[serde(rename = "Inline")]
        Inline,
        #[serde(rename = "Block")]
        Block,
        #[serde(rename = "Both")]
        Both,
    }
    impl From<&str> for LogicalAxes {
        fn from(s: &str) -> Self {
            match s {
                "Inline" => Self::Inline,
                "Block" => Self::Block,
                "Both" => Self::Both,
                _ => Self::Inline,
            }
        }
    }
    impl From<String> for LogicalAxes {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Physical scroll orientation
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ScrollOrientation {
        #[serde(rename = "horizontal")]
        Horizontal,
        #[serde(rename = "vertical")]
        Vertical,
    }
    impl From<&str> for ScrollOrientation {
        fn from(s: &str) -> Self {
            match s {
                "horizontal" => Self::Horizontal,
                "vertical" => Self::Vertical,
                _ => Self::Horizontal,
            }
        }
    }
    impl From<String> for ScrollOrientation {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Node {
        /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend will only push node with given `id` once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// The id of the parent node if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentId")]
        pub parent_id: Option<NodeId>,
        /// The BackendNodeId for this node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        /// `Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        /// `Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        /// `Node`'s localName.
        #[serde(rename = "localName")]
        pub local_name: String,
        /// `Node`'s nodeValue.
        #[serde(rename = "nodeValue")]
        pub node_value: String,
        /// Child count for `Container` nodes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "childNodeCount")]
        pub child_node_count: Option<i64>,
        /// Child nodes of this node when requested with children.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub children: Option<Vec<Node>>,
        /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub attributes: Option<Vec<String>>,
        /// Document URL that `Document` or `FrameOwner` node points to.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "documentURL")]
        pub document_url: Option<String>,
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
        /// `DocumentType`'s publicId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "publicId")]
        pub public_id: Option<String>,
        /// `DocumentType`'s systemId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "systemId")]
        pub system_id: Option<String>,
        /// `DocumentType`'s internalSubset.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "internalSubset")]
        pub internal_subset: Option<String>,
        /// `Document`'s XML version in case of XML documents.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "xmlVersion")]
        pub xml_version: Option<String>,
        /// `Attr`'s name.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// `Attr`'s value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
        /// Pseudo element type for this node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<PseudoType>,
        /// Pseudo element identifier for this node. Only present if there is a valid pseudoType.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<String>,
        /// Shadow root type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<ShadowRootType>,
        /// Frame ID for frame owner elements.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
        /// Content document for frame owner elements.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentDocument")]
        pub content_document: Option<Box<Node>>,
        /// Shadow root list for given element host.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shadowRoots")]
        pub shadow_roots: Option<Vec<Node>>,
        /// Content document fragment for template elements.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "templateContent")]
        pub template_content: Option<Box<Node>>,
        /// Pseudo elements associated with this node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoElements")]
        pub pseudo_elements: Option<Vec<Node>>,
        /// Deprecated, as the HTML Imports API has been removed (crbug.com/937746). This property used to return the imported document for the HTMLImport links. The property is always undefined now.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "importedDocument")]
        pub imported_document: Option<Box<Node>>,
        /// Distributed nodes for given insertion point.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "distributedNodes")]
        pub distributed_nodes: Option<Vec<BackendNode>>,
        /// Whether the node is SVG.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isSVG")]
        pub is_svg: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "compatibilityMode")]
        pub compatibility_mode: Option<CompatibilityMode>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "assignedSlot")]
        pub assigned_slot: Option<BackendNode>,
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isScrollable")]
        pub is_scrollable: Option<bool>,
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "affectedByStartingStyles")]
        pub affected_by_starting_styles: Option<bool>,
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "adoptedStyleSheets")]
        pub adopted_style_sheets: Option<Vec<StyleSheetId>>,
    }

    /// A structure to hold the top-level node of a detached tree and an array of its retained descendants.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DetachedElementInfo {
        #[serde(rename = "treeNode")]
        pub tree_node: Node,
        #[serde(rename = "retainedNodeIds")]
        pub retained_node_ids: Vec<NodeId>,
    }

    /// A structure holding an RGBA color.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RGBA {
        /// The red component, in the [0-255] range.
        pub r: i64,
        /// The green component, in the [0-255] range.
        pub g: i64,
        /// The blue component, in the [0-255] range.
        pub b: i64,
        /// The alpha component, in the [0-1] range (default: 1).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub a: Option<f64>,
    }

    /// An array of quad vertices, x immediately followed by y for each point, points clock-wise.
    pub type Quad = Vec<f64>;

    /// Box model.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BoxModel {
        /// Content box
        pub content: Quad,
        /// Padding box
        pub padding: Quad,
        /// Border box
        pub border: Quad,
        /// Margin box
        pub margin: Quad,
        /// Node width
        pub width: i64,
        /// Node height
        pub height: i64,
        /// Shape outside coordinates
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shapeOutside")]
        pub shape_outside: Option<ShapeOutsideInfo>,
    }

    /// CSS Shape Outside details.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ShapeOutsideInfo {
        /// Shape bounds
        pub bounds: Quad,
        /// Shape coordinate details
        pub shape: Vec<serde_json::Value>,
        /// Margin shape bounds
        #[serde(rename = "marginShape")]
        pub margin_shape: Vec<serde_json::Value>,
    }

    /// Rectangle.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Rect {
        /// X coordinate
        pub x: f64,
        /// Y coordinate
        pub y: f64,
        /// Rectangle width
        pub width: f64,
        /// Rectangle height
        pub height: f64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CSSComputedStyleProperty {
        /// Computed style property name.
        pub name: String,
        /// Computed style property value.
        pub value: String,
    }

    /// Collects class names for the node with given id and all of it's child nodes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CollectClassNamesFromSubtree {
        /// Id of the node to collect class names.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl CollectClassNamesFromSubtree {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for CollectClassNamesFromSubtree {
        type Response = CollectClassNamesFromSubtreeResult;
        const METHOD: &'static str = "DOM.collectClassNamesFromSubtree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CollectClassNamesFromSubtreeResult {
        /// Class name list.
        #[serde(rename = "classNames")]
        pub class_names: Vec<String>,
    }

    /// Creates a deep copy of the specified node and places it into the target container before the given anchor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CopyTo {
        /// Id of the node to copy.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Id of the element to drop the copy into.
        #[serde(rename = "targetNodeId")]
        target_node_id: NodeId,
        /// Drop the copy before this node (if absent, the copy becomes the last child of `targetNodeId`).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "insertBeforeNodeId")]
        insert_before_node_id: Option<NodeId>,
    }

    impl CopyTo {
        pub fn new(node_id: impl Into<NodeId>, target_node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                target_node_id: target_node_id.into(),
                insert_before_node_id: None,
            }
        }

        pub fn with_insert_before_node_id(
            mut self,
            insert_before_node_id: impl Into<NodeId>,
        ) -> Self {
            self.insert_before_node_id = Some(insert_before_node_id.into());
            self
        }
    }

    impl Command for CopyTo {
        type Response = CopyToResult;
        const METHOD: &'static str = "DOM.copyTo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CopyToResult {
        /// Id of the node clone.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Describes node given its id, does not require domain to be enabled. Does not start tracking any objects, can be used for automation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DescribeNode {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl DescribeNode {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
                depth: None,
                pierce: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for DescribeNode {
        type Response = DescribeNodeResult;
        const METHOD: &'static str = "DOM.describeNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DescribeNodeResult {
        /// Node description.
        pub node: Node,
    }

    /// Scrolls the specified rect of the given node into view if not already visible. Note: exactly one between nodeId, backendNodeId and objectId should be passed to identify the node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScrollIntoViewIfNeeded {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView.
        #[serde(skip_serializing_if = "Option::is_none")]
        rect: Option<Rect>,
    }

    impl ScrollIntoViewIfNeeded {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
                rect: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_rect(mut self, rect: impl Into<Rect>) -> Self {
            self.rect = Some(rect.into());
            self
        }
    }

    impl Command for ScrollIntoViewIfNeeded {
        type Response = ();
        const METHOD: &'static str = "DOM.scrollIntoViewIfNeeded";
    }

    /// Disables DOM agent for the given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "DOM.disable";
    }

    /// Discards search results from the session with the given id. `getSearchResults` should no longer be called for that search.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DiscardSearchResults {
        /// Unique search session identifier.
        #[serde(rename = "searchId")]
        search_id: String,
    }

    impl DiscardSearchResults {
        pub fn new(search_id: impl Into<String>) -> Self {
            Self {
                search_id: search_id.into(),
            }
        }
    }

    impl Command for DiscardSearchResults {
        type Response = ();
        const METHOD: &'static str = "DOM.discardSearchResults";
    }

    /// Enables DOM agent for the given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// Whether to include whitespaces in the children array of returned Nodes.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeWhitespace")]
        include_whitespace: Option<String>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                include_whitespace: None,
            }
        }

        pub fn with_include_whitespace(mut self, include_whitespace: impl Into<String>) -> Self {
            self.include_whitespace = Some(include_whitespace.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "DOM.enable";
    }

    /// Focuses the given element.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Focus {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl Focus {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for Focus {
        type Response = ();
        const METHOD: &'static str = "DOM.focus";
    }

    /// Returns attributes for the specified node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAttributes {
        /// Id of the node to retrieve attributes for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl GetAttributes {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetAttributes {
        type Response = GetAttributesResult;
        const METHOD: &'static str = "DOM.getAttributes";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAttributesResult {
        /// An interleaved array of node attribute names and values.
        pub attributes: Vec<String>,
    }

    /// Returns boxes for the given node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBoxModel {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl GetBoxModel {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for GetBoxModel {
        type Response = GetBoxModelResult;
        const METHOD: &'static str = "DOM.getBoxModel";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBoxModelResult {
        /// Box model for the node.
        pub model: BoxModel,
    }

    /// Returns quads that describe node position on the page. This method might return multiple quads for inline nodes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetContentQuads {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl GetContentQuads {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for GetContentQuads {
        type Response = GetContentQuadsResult;
        const METHOD: &'static str = "DOM.getContentQuads";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetContentQuadsResult {
        /// Quads that describe node layout relative to viewport.
        pub quads: Vec<Quad>,
    }

    /// Returns the root DOM node (and optionally the subtree) to the caller. Implicitly enables the DOM domain events for the current target.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDocument {
        /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl GetDocument {
        pub fn new() -> Self {
            Self {
                depth: None,
                pierce: None,
            }
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for GetDocument {
        type Response = GetDocumentResult;
        const METHOD: &'static str = "DOM.getDocument";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDocumentResult {
        /// Resulting node.
        pub root: Node,
    }

    /// Returns the root DOM node (and optionally the subtree) to the caller. Deprecated, as it is not designed to work well with the rest of the DOM agent. Use DOMSnapshot.captureSnapshot instead.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFlattenedDocument {
        /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl GetFlattenedDocument {
        pub fn new() -> Self {
            Self {
                depth: None,
                pierce: None,
            }
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for GetFlattenedDocument {
        type Response = GetFlattenedDocumentResult;
        const METHOD: &'static str = "DOM.getFlattenedDocument";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFlattenedDocumentResult {
        /// Resulting node.
        pub nodes: Vec<Node>,
    }

    /// Finds nodes with a given computed style in a subtree.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodesForSubtreeByStyle {
        /// Node ID pointing to the root of a subtree.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// The style to filter nodes by (includes nodes if any of properties matches).
        #[serde(rename = "computedStyles")]
        computed_styles: Vec<CSSComputedStyleProperty>,
        /// Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false).
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl GetNodesForSubtreeByStyle {
        pub fn new(
            node_id: impl Into<NodeId>,
            computed_styles: impl Into<Vec<CSSComputedStyleProperty>>,
        ) -> Self {
            Self {
                node_id: node_id.into(),
                computed_styles: computed_styles.into(),
                pierce: None,
            }
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for GetNodesForSubtreeByStyle {
        type Response = GetNodesForSubtreeByStyleResult;
        const METHOD: &'static str = "DOM.getNodesForSubtreeByStyle";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodesForSubtreeByStyleResult {
        /// Resulting nodes.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is either returned or not.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodeForLocation {
        /// X coordinate.
        x: i64,
        /// Y coordinate.
        y: i64,
        /// False to skip to the nearest non-UA shadow root ancestor (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeUserAgentShadowDOM")]
        include_user_agent_shadow_dom: Option<bool>,
        /// Whether to ignore pointer-events: none on elements and hit test them.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ignorePointerEventsNone")]
        ignore_pointer_events_none: Option<bool>,
    }

    impl GetNodeForLocation {
        pub fn new(x: impl Into<i64>, y: impl Into<i64>) -> Self {
            Self {
                x: x.into(),
                y: y.into(),
                include_user_agent_shadow_dom: None,
                ignore_pointer_events_none: None,
            }
        }

        pub fn with_include_user_agent_shadow_dom(
            mut self,
            include_user_agent_shadow_dom: impl Into<bool>,
        ) -> Self {
            self.include_user_agent_shadow_dom = Some(include_user_agent_shadow_dom.into());
            self
        }

        pub fn with_ignore_pointer_events_none(
            mut self,
            ignore_pointer_events_none: impl Into<bool>,
        ) -> Self {
            self.ignore_pointer_events_none = Some(ignore_pointer_events_none.into());
            self
        }
    }

    impl Command for GetNodeForLocation {
        type Response = GetNodeForLocationResult;
        const METHOD: &'static str = "DOM.getNodeForLocation";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodeForLocationResult {
        /// Resulting node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        /// Frame this node belongs to.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// Id of the node at given coordinates, only when enabled and requested document.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }

    /// Returns node's HTML markup.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOuterHtml {
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// Include all shadow roots. Equals to false if not specified.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeShadowDOM")]
        include_shadow_dom: Option<bool>,
    }

    impl GetOuterHtml {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_id: None,
                include_shadow_dom: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_include_shadow_dom(mut self, include_shadow_dom: impl Into<bool>) -> Self {
            self.include_shadow_dom = Some(include_shadow_dom.into());
            self
        }
    }

    impl Command for GetOuterHtml {
        type Response = GetOuterHtmlResult;
        const METHOD: &'static str = "DOM.getOuterHTML";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOuterHtmlResult {
        /// Outer HTML markup.
        #[serde(rename = "outerHTML")]
        pub outer_html: String,
    }

    /// Returns the id of the nearest ancestor that is a relayout boundary.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRelayoutBoundary {
        /// Id of the node.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl GetRelayoutBoundary {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetRelayoutBoundary {
        type Response = GetRelayoutBoundaryResult;
        const METHOD: &'static str = "DOM.getRelayoutBoundary";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRelayoutBoundaryResult {
        /// Relayout boundary node id for the given node.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given identifier.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSearchResults {
        /// Unique search session identifier.
        #[serde(rename = "searchId")]
        search_id: String,
        /// Start index of the search result to be returned.
        #[serde(rename = "fromIndex")]
        from_index: i64,
        /// End index of the search result to be returned.
        #[serde(rename = "toIndex")]
        to_index: i64,
    }

    impl GetSearchResults {
        pub fn new(
            search_id: impl Into<String>,
            from_index: impl Into<i64>,
            to_index: impl Into<i64>,
        ) -> Self {
            Self {
                search_id: search_id.into(),
                from_index: from_index.into(),
                to_index: to_index.into(),
            }
        }
    }

    impl Command for GetSearchResults {
        type Response = GetSearchResultsResult;
        const METHOD: &'static str = "DOM.getSearchResults";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSearchResultsResult {
        /// Ids of the search result nodes.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Hides any highlight.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HideHighlight {}

    impl HideHighlight {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for HideHighlight {
        type Response = ();
        const METHOD: &'static str = "DOM.hideHighlight";
    }

    /// Highlights DOM node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightNode {}

    impl HighlightNode {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for HighlightNode {
        type Response = ();
        const METHOD: &'static str = "DOM.highlightNode";
    }

    /// Highlights given rectangle.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightRect {}

    impl HighlightRect {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for HighlightRect {
        type Response = ();
        const METHOD: &'static str = "DOM.highlightRect";
    }

    /// Marks last undoable state.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MarkUndoableState {}

    impl MarkUndoableState {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for MarkUndoableState {
        type Response = ();
        const METHOD: &'static str = "DOM.markUndoableState";
    }

    /// Moves node into the new container, places it before the given anchor.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MoveTo {
        /// Id of the node to move.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Id of the element to drop the moved node into.
        #[serde(rename = "targetNodeId")]
        target_node_id: NodeId,
        /// Drop node before this one (if absent, the moved node becomes the last child of `targetNodeId`).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "insertBeforeNodeId")]
        insert_before_node_id: Option<NodeId>,
    }

    impl MoveTo {
        pub fn new(node_id: impl Into<NodeId>, target_node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                target_node_id: target_node_id.into(),
                insert_before_node_id: None,
            }
        }

        pub fn with_insert_before_node_id(
            mut self,
            insert_before_node_id: impl Into<NodeId>,
        ) -> Self {
            self.insert_before_node_id = Some(insert_before_node_id.into());
            self
        }
    }

    impl Command for MoveTo {
        type Response = MoveToResult;
        const METHOD: &'static str = "DOM.moveTo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MoveToResult {
        /// New id of the moved node.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or `cancelSearch` to end this search session.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PerformSearch {
        /// Plain text or query selector or XPath search query.
        query: String,
        /// True to search in user agent shadow DOM.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeUserAgentShadowDOM")]
        include_user_agent_shadow_dom: Option<bool>,
    }

    impl PerformSearch {
        pub fn new(query: impl Into<String>) -> Self {
            Self {
                query: query.into(),
                include_user_agent_shadow_dom: None,
            }
        }

        pub fn with_include_user_agent_shadow_dom(
            mut self,
            include_user_agent_shadow_dom: impl Into<bool>,
        ) -> Self {
            self.include_user_agent_shadow_dom = Some(include_user_agent_shadow_dom.into());
            self
        }
    }

    impl Command for PerformSearch {
        type Response = PerformSearchResult;
        const METHOD: &'static str = "DOM.performSearch";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PerformSearchResult {
        /// Unique search session identifier.
        #[serde(rename = "searchId")]
        pub search_id: String,
        /// Number of search results.
        #[serde(rename = "resultCount")]
        pub result_count: i64,
    }

    /// Requests that the node is sent to the caller given its path. // FIXME, use XPath
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PushNodeByPathToFrontend {
        /// Path to node in the proprietary format.
        path: String,
    }

    impl PushNodeByPathToFrontend {
        pub fn new(path: impl Into<String>) -> Self {
            Self { path: path.into() }
        }
    }

    impl Command for PushNodeByPathToFrontend {
        type Response = PushNodeByPathToFrontendResult;
        const METHOD: &'static str = "DOM.pushNodeByPathToFrontend";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PushNodeByPathToFrontendResult {
        /// Id of the node for given path.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Requests that a batch of nodes is sent to the caller given their backend node ids.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PushNodesByBackendIdsToFrontend {
        /// The array of backend node ids.
        #[serde(rename = "backendNodeIds")]
        backend_node_ids: Vec<BackendNodeId>,
    }

    impl PushNodesByBackendIdsToFrontend {
        pub fn new(backend_node_ids: impl Into<Vec<BackendNodeId>>) -> Self {
            Self {
                backend_node_ids: backend_node_ids.into(),
            }
        }
    }

    impl Command for PushNodesByBackendIdsToFrontend {
        type Response = PushNodesByBackendIdsToFrontendResult;
        const METHOD: &'static str = "DOM.pushNodesByBackendIdsToFrontend";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PushNodesByBackendIdsToFrontendResult {
        /// The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Executes `querySelector` on a given node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QuerySelector {
        /// Id of the node to query upon.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Selector string.
        selector: String,
    }

    impl QuerySelector {
        pub fn new(node_id: impl Into<NodeId>, selector: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                selector: selector.into(),
            }
        }
    }

    impl Command for QuerySelector {
        type Response = QuerySelectorResult;
        const METHOD: &'static str = "DOM.querySelector";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QuerySelectorResult {
        /// Query selector result.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Executes `querySelectorAll` on a given node.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QuerySelectorAll {
        /// Id of the node to query upon.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Selector string.
        selector: String,
    }

    impl QuerySelectorAll {
        pub fn new(node_id: impl Into<NodeId>, selector: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                selector: selector.into(),
            }
        }
    }

    impl Command for QuerySelectorAll {
        type Response = QuerySelectorAllResult;
        const METHOD: &'static str = "DOM.querySelectorAll";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QuerySelectorAllResult {
        /// Query selector result.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Returns NodeIds of current top layer elements. Top layer is rendered closest to the user within a viewport, therefore its elements always appear on top of all other content.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTopLayerElements {}

    impl GetTopLayerElements {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetTopLayerElements {
        type Response = GetTopLayerElementsResult;
        const METHOD: &'static str = "DOM.getTopLayerElements";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTopLayerElementsResult {
        /// NodeIds of top layer elements
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Returns the NodeId of the matched element according to certain relations.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetElementByRelation {
        /// Id of the node from which to query the relation.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Type of relation to get.
        relation: String,
    }

    impl GetElementByRelation {
        pub fn new(node_id: impl Into<NodeId>, relation: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                relation: relation.into(),
            }
        }
    }

    impl Command for GetElementByRelation {
        type Response = GetElementByRelationResult;
        const METHOD: &'static str = "DOM.getElementByRelation";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetElementByRelationResult {
        /// NodeId of the element matching the queried relation.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Re-does the last undone action.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Redo {}

    impl Redo {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Redo {
        type Response = ();
        const METHOD: &'static str = "DOM.redo";
    }

    /// Removes attribute with given name from an element with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveAttribute {
        /// Id of the element to remove attribute from.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Name of the attribute to remove.
        name: String,
    }

    impl RemoveAttribute {
        pub fn new(node_id: impl Into<NodeId>, name: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                name: name.into(),
            }
        }
    }

    impl Command for RemoveAttribute {
        type Response = ();
        const METHOD: &'static str = "DOM.removeAttribute";
    }

    /// Removes node with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveNode {
        /// Id of the node to remove.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl RemoveNode {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for RemoveNode {
        type Response = ();
        const METHOD: &'static str = "DOM.removeNode";
    }

    /// Requests that children of the node with given id are returned to the caller in form of `setChildNodes` events where not only immediate children are retrieved, but all children down to the specified depth.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestChildNodes {
        /// Id of the node to get children for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl RequestChildNodes {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                depth: None,
                pierce: None,
            }
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for RequestChildNodes {
        type Response = ();
        const METHOD: &'static str = "DOM.requestChildNodes";
    }

    /// Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of `setChildNodes` notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestNode {
        /// JavaScript object id to convert into node.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
    }

    impl RequestNode {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
            }
        }
    }

    impl Command for RequestNode {
        type Response = RequestNodeResult;
        const METHOD: &'static str = "DOM.requestNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestNodeResult {
        /// Node id for given object.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveNode {
        /// Id of the node to resolve.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Backend identifier of the node to resolve.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// Symbolic group name that can be used to release multiple objects.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
        /// Execution context in which to resolve the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<runtime::ExecutionContextId>,
    }

    impl ResolveNode {
        pub fn new() -> Self {
            Self {
                node_id: None,
                backend_node_id: None,
                object_group: None,
                execution_context_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<runtime::ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }
    }

    impl Command for ResolveNode {
        type Response = ResolveNodeResult;
        const METHOD: &'static str = "DOM.resolveNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveNodeResult {
        /// JavaScript object wrapper for given node.
        pub object: runtime::RemoteObject,
    }

    /// Sets attribute for an element with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttributeValue {
        /// Id of the element to set attribute for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Attribute name.
        name: String,
        /// Attribute value.
        value: String,
    }

    impl SetAttributeValue {
        pub fn new(
            node_id: impl Into<NodeId>,
            name: impl Into<String>,
            value: impl Into<String>,
        ) -> Self {
            Self {
                node_id: node_id.into(),
                name: name.into(),
                value: value.into(),
            }
        }
    }

    impl Command for SetAttributeValue {
        type Response = ();
        const METHOD: &'static str = "DOM.setAttributeValue";
    }

    /// Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttributesAsText {
        /// Id of the element to set attributes for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Text with a number of attributes. Will parse this text using HTML parser.
        text: String,
        /// Attribute name to replace with new attributes derived from text in case text parsed successfully.
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    }

    impl SetAttributesAsText {
        pub fn new(node_id: impl Into<NodeId>, text: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                text: text.into(),
                name: None,
            }
        }

        pub fn with_name(mut self, name: impl Into<String>) -> Self {
            self.name = Some(name.into());
            self
        }
    }

    impl Command for SetAttributesAsText {
        type Response = ();
        const METHOD: &'static str = "DOM.setAttributesAsText";
    }

    /// Sets files for the given file input element.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetFileInputFiles {
        /// Array of file paths to set.
        files: Vec<String>,
        /// Identifier of the node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<NodeId>,
        /// Identifier of the backend node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<BackendNodeId>,
        /// JavaScript object id of the node wrapper.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl SetFileInputFiles {
        pub fn new(files: impl Into<Vec<String>>) -> Self {
            Self {
                files: files.into(),
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(mut self, backend_node_id: impl Into<BackendNodeId>) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for SetFileInputFiles {
        type Response = ();
        const METHOD: &'static str = "DOM.setFileInputFiles";
    }

    /// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetNodeStackTracesEnabled {
        /// Enable or disable.
        enable: bool,
    }

    impl SetNodeStackTracesEnabled {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for SetNodeStackTracesEnabled {
        type Response = ();
        const METHOD: &'static str = "DOM.setNodeStackTracesEnabled";
    }

    /// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodeStackTraces {
        /// Id of the node to get stack traces for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl GetNodeStackTraces {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetNodeStackTraces {
        type Response = GetNodeStackTracesResult;
        const METHOD: &'static str = "DOM.getNodeStackTraces";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNodeStackTracesResult {
        /// Creation stack trace, if available.
        pub creation: Option<runtime::StackTrace>,
    }

    /// Returns file information for the given File wrapper.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFileInfo {
        /// JavaScript object id of the node wrapper.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
    }

    impl GetFileInfo {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
            }
        }
    }

    impl Command for GetFileInfo {
        type Response = GetFileInfoResult;
        const METHOD: &'static str = "DOM.getFileInfo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFileInfoResult {
        pub path: String,
    }

    /// Returns list of detached nodes
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDetachedDomNodes {}

    impl GetDetachedDomNodes {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetDetachedDomNodes {
        type Response = GetDetachedDomNodesResult;
        const METHOD: &'static str = "DOM.getDetachedDomNodes";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDetachedDomNodesResult {
        /// The list of detached nodes
        #[serde(rename = "detachedNodes")]
        pub detached_nodes: Vec<DetachedElementInfo>,
    }

    /// Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInspectedNode {
        /// DOM node id to be accessible by means of $x command line API.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl SetInspectedNode {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for SetInspectedNode {
        type Response = ();
        const METHOD: &'static str = "DOM.setInspectedNode";
    }

    /// Sets node name for a node with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetNodeName {
        /// Id of the node to set name for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// New node's name.
        name: String,
    }

    impl SetNodeName {
        pub fn new(node_id: impl Into<NodeId>, name: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                name: name.into(),
            }
        }
    }

    impl Command for SetNodeName {
        type Response = SetNodeNameResult;
        const METHOD: &'static str = "DOM.setNodeName";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetNodeNameResult {
        /// New node's id.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// Sets node value for a node with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetNodeValue {
        /// Id of the node to set value for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// New node's value.
        value: String,
    }

    impl SetNodeValue {
        pub fn new(node_id: impl Into<NodeId>, value: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                value: value.into(),
            }
        }
    }

    impl Command for SetNodeValue {
        type Response = ();
        const METHOD: &'static str = "DOM.setNodeValue";
    }

    /// Sets node HTML markup, returns new node id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetOuterHtml {
        /// Id of the node to set markup for.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// Outer HTML markup to set.
        #[serde(rename = "outerHTML")]
        outer_html: String,
    }

    impl SetOuterHtml {
        pub fn new(node_id: impl Into<NodeId>, outer_html: impl Into<String>) -> Self {
            Self {
                node_id: node_id.into(),
                outer_html: outer_html.into(),
            }
        }
    }

    impl Command for SetOuterHtml {
        type Response = ();
        const METHOD: &'static str = "DOM.setOuterHTML";
    }

    /// Undoes the last performed action.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Undo {}

    impl Undo {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Undo {
        type Response = ();
        const METHOD: &'static str = "DOM.undo";
    }

    /// Returns iframe node that owns iframe with the given domain.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFrameOwner {
        #[serde(rename = "frameId")]
        frame_id: page::FrameId,
    }

    impl GetFrameOwner {
        pub fn new(frame_id: impl Into<page::FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
            }
        }
    }

    impl Command for GetFrameOwner {
        type Response = GetFrameOwnerResult;
        const METHOD: &'static str = "DOM.getFrameOwner";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFrameOwnerResult {
        /// Resulting node.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: BackendNodeId,
        /// Id of the node at given coordinates, only when enabled and requested document.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }

    /// Returns the query container of the given node based on container query conditions: containerName, physical and logical axes, and whether it queries scroll-state or anchored elements. If no axes are provided and queriesScrollState is false, the style container is returned, which is the direct parent or the closest element with a matching container-name.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetContainerForNode {
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerName")]
        container_name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "physicalAxes")]
        physical_axes: Option<PhysicalAxes>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "logicalAxes")]
        logical_axes: Option<LogicalAxes>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "queriesScrollState")]
        queries_scroll_state: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "queriesAnchored")]
        queries_anchored: Option<bool>,
    }

    impl GetContainerForNode {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                container_name: None,
                physical_axes: None,
                logical_axes: None,
                queries_scroll_state: None,
                queries_anchored: None,
            }
        }

        pub fn with_container_name(mut self, container_name: impl Into<String>) -> Self {
            self.container_name = Some(container_name.into());
            self
        }

        pub fn with_physical_axes(mut self, physical_axes: impl Into<PhysicalAxes>) -> Self {
            self.physical_axes = Some(physical_axes.into());
            self
        }

        pub fn with_logical_axes(mut self, logical_axes: impl Into<LogicalAxes>) -> Self {
            self.logical_axes = Some(logical_axes.into());
            self
        }

        pub fn with_queries_scroll_state(mut self, queries_scroll_state: impl Into<bool>) -> Self {
            self.queries_scroll_state = Some(queries_scroll_state.into());
            self
        }

        pub fn with_queries_anchored(mut self, queries_anchored: impl Into<bool>) -> Self {
            self.queries_anchored = Some(queries_anchored.into());
            self
        }
    }

    impl Command for GetContainerForNode {
        type Response = GetContainerForNodeResult;
        const METHOD: &'static str = "DOM.getContainerForNode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetContainerForNodeResult {
        /// The container node for the given node, or null if not found.
        #[serde(rename = "nodeId")]
        pub node_id: Option<NodeId>,
    }

    /// Returns the descendants of a container query container that have container queries against this container.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetQueryingDescendantsForContainer {
        /// Id of the container node to find querying descendants from.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
    }

    impl GetQueryingDescendantsForContainer {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetQueryingDescendantsForContainer {
        type Response = GetQueryingDescendantsForContainerResult;
        const METHOD: &'static str = "DOM.getQueryingDescendantsForContainer";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetQueryingDescendantsForContainerResult {
        /// Descendant nodes with container queries against the given container.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Returns the target anchor element of the given anchor query according to https://www.w3.org/TR/css-anchor-position-1/#target.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnchorElement {
        /// Id of the positioned element from which to find the anchor.
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// An optional anchor specifier, as defined in https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier. If not provided, it will return the implicit anchor element for the given positioned element.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "anchorSpecifier")]
        anchor_specifier: Option<String>,
    }

    impl GetAnchorElement {
        pub fn new(node_id: impl Into<NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                anchor_specifier: None,
            }
        }

        pub fn with_anchor_specifier(mut self, anchor_specifier: impl Into<String>) -> Self {
            self.anchor_specifier = Some(anchor_specifier.into());
            self
        }
    }

    impl Command for GetAnchorElement {
        type Response = GetAnchorElementResult;
        const METHOD: &'static str = "DOM.getAnchorElement";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnchorElementResult {
        /// The anchor element of the given anchor query.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    /// When enabling, this API force-opens the popover identified by nodeId and keeps it open until disabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ForceShowPopover {
        /// Id of the popover HTMLElement
        #[serde(rename = "nodeId")]
        node_id: NodeId,
        /// If true, opens the popover and keeps it open. If false, closes the popover if it was previously force-opened.
        enable: bool,
    }

    impl ForceShowPopover {
        pub fn new(node_id: impl Into<NodeId>, enable: impl Into<bool>) -> Self {
            Self {
                node_id: node_id.into(),
                enable: enable.into(),
            }
        }
    }

    impl Command for ForceShowPopover {
        type Response = ForceShowPopoverResult;
        const METHOD: &'static str = "DOM.forceShowPopover";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ForceShowPopoverResult {
        /// List of popovers that were closed in order to respect popover stacking order.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    /// Fired when `Element`'s attribute is modified.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributeModified {
        /// Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// Attribute name.
        pub name: String,
        /// Attribute value.
        pub value: String,
    }

    impl AttributeModified {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.attributeModified")
        }
    }

    /// Fired when `Element`'s adoptedStyleSheets are modified.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AdoptedStyleSheetsModified {
        /// Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// New adoptedStyleSheets array.
        /// **EXPERIMENTAL**
        #[serde(rename = "adoptedStyleSheets")]
        pub adopted_style_sheets: Vec<StyleSheetId>,
    }

    impl AdoptedStyleSheetsModified {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.adoptedStyleSheetsModified")
        }
    }

    /// Fired when `Element`'s attribute is removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributeRemoved {
        /// Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// A ttribute name.
        pub name: String,
    }

    impl AttributeRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.attributeRemoved")
        }
    }

    /// Mirrors `DOMCharacterDataModified` event.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CharacterDataModified {
        /// Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// New text value.
        #[serde(rename = "characterData")]
        pub character_data: String,
    }

    impl CharacterDataModified {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.characterDataModified")
        }
    }

    /// Fired when `Container`'s child node count has changed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ChildNodeCountUpdated {
        /// Id of the node that has changed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
        /// New node count.
        #[serde(rename = "childNodeCount")]
        pub child_node_count: i64,
    }

    impl ChildNodeCountUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.childNodeCountUpdated")
        }
    }

    /// Mirrors `DOMNodeInserted` event.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ChildNodeInserted {
        /// Id of the node that has changed.
        #[serde(rename = "parentNodeId")]
        pub parent_node_id: NodeId,
        /// Id of the previous sibling.
        #[serde(rename = "previousNodeId")]
        pub previous_node_id: NodeId,
        /// Inserted node data.
        pub node: Node,
    }

    impl ChildNodeInserted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.childNodeInserted")
        }
    }

    /// Mirrors `DOMNodeRemoved` event.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ChildNodeRemoved {
        /// Parent id.
        #[serde(rename = "parentNodeId")]
        pub parent_node_id: NodeId,
        /// Id of the node that has been removed.
        #[serde(rename = "nodeId")]
        pub node_id: NodeId,
    }

    impl ChildNodeRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.childNodeRemoved")
        }
    }

    /// Called when distribution is changed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DistributedNodesUpdated {
        /// Insertion point where distributed nodes were updated.
        #[serde(rename = "insertionPointId")]
        pub insertion_point_id: NodeId,
        /// Distributed nodes for given insertion point.
        #[serde(rename = "distributedNodes")]
        pub distributed_nodes: Vec<BackendNode>,
    }

    impl DistributedNodesUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.distributedNodesUpdated")
        }
    }

    /// Fired when `Document` has been totally updated. Node ids are no longer valid.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DocumentUpdated {}

    impl DocumentUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.documentUpdated")
        }
    }

    /// Fired when `Element`'s inline style is modified via a CSS property modification.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InlineStyleInvalidated {
        /// Ids of the nodes for which the inline styles have been invalidated.
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<NodeId>,
    }

    impl InlineStyleInvalidated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.inlineStyleInvalidated")
        }
    }

    /// Called when a pseudo element is added to an element.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PseudoElementAdded {
        /// Pseudo element's parent element id.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        /// The added pseudo element.
        #[serde(rename = "pseudoElement")]
        pub pseudo_element: Node,
    }

    impl PseudoElementAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.pseudoElementAdded")
        }
    }

    /// Called when top layer elements are changed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TopLayerElementsUpdated {}

    impl TopLayerElementsUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.topLayerElementsUpdated")
        }
    }

    /// Fired when a node's scrollability state changes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScrollableFlagUpdated {
        /// The id of the node.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
        /// If the node is scrollable.
        #[serde(rename = "isScrollable")]
        pub is_scrollable: bool,
    }

    impl ScrollableFlagUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.scrollableFlagUpdated")
        }
    }

    /// Fired when a node's starting styles changes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AffectedByStartingStylesFlagUpdated {
        /// The id of the node.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
        /// If the node has starting styles.
        #[serde(rename = "affectedByStartingStyles")]
        pub affected_by_starting_styles: bool,
    }

    impl AffectedByStartingStylesFlagUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("DOM.affectedByStartingStylesFlagUpdated")
        }
    }

    /// Called when a pseudo element is removed from an element.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PseudoElementRemoved {
        /// Pseudo element's parent element id.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        /// The removed pseudo element id.
        #[serde(rename = "pseudoElementId")]
        pub pseudo_element_id: NodeId,
    }

    impl PseudoElementRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.pseudoElementRemoved")
        }
    }

    /// Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetChildNodes {
        /// Parent node id to populate with children.
        #[serde(rename = "parentId")]
        pub parent_id: NodeId,
        /// Child nodes array.
        pub nodes: Vec<Node>,
    }

    impl SetChildNodes {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.setChildNodes")
        }
    }

    /// Called when shadow root is popped from the element.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ShadowRootPopped {
        /// Host element id.
        #[serde(rename = "hostId")]
        pub host_id: NodeId,
        /// Shadow root id.
        #[serde(rename = "rootId")]
        pub root_id: NodeId,
    }

    impl ShadowRootPopped {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.shadowRootPopped")
        }
    }

    /// Called when shadow root is pushed into the element.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ShadowRootPushed {
        /// Host element id.
        #[serde(rename = "hostId")]
        pub host_id: NodeId,
        /// Shadow root.
        pub root: Node,
    }

    impl ShadowRootPushed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOM.shadowRootPushed")
        }
    }
}

pub mod dom_debugger {
    use super::*;

    /// DOM breakpoint type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DOMBreakpointType {
        #[serde(rename = "subtree-modified")]
        SubtreeModified,
        #[serde(rename = "attribute-modified")]
        AttributeModified,
        #[serde(rename = "node-removed")]
        NodeRemoved,
    }
    impl From<&str> for DOMBreakpointType {
        fn from(s: &str) -> Self {
            match s {
                "subtree-modified" => Self::SubtreeModified,
                "attribute-modified" => Self::AttributeModified,
                "node-removed" => Self::NodeRemoved,
                _ => Self::SubtreeModified,
            }
        }
    }
    impl From<String> for DOMBreakpointType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// CSP Violation type.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CSPViolationType {
        #[serde(rename = "trustedtype-sink-violation")]
        TrustedtypeSinkViolation,
        #[serde(rename = "trustedtype-policy-violation")]
        TrustedtypePolicyViolation,
    }
    impl From<&str> for CSPViolationType {
        fn from(s: &str) -> Self {
            match s {
                "trustedtype-sink-violation" => Self::TrustedtypeSinkViolation,
                "trustedtype-policy-violation" => Self::TrustedtypePolicyViolation,
                _ => Self::TrustedtypeSinkViolation,
            }
        }
    }
    impl From<String> for CSPViolationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Object event listener.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EventListener {
        /// `EventListener`'s type.
        #[serde(rename = "type")]
        pub type_: String,
        /// `EventListener`'s useCapture.
        #[serde(rename = "useCapture")]
        pub use_capture: bool,
        /// `EventListener`'s passive flag.
        pub passive: bool,
        /// `EventListener`'s once flag.
        pub once: bool,
        /// Script id of the handler code.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// Column number in the script (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
        /// Event handler function value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub handler: Option<runtime::RemoteObject>,
        /// Event original handler function value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "originalHandler")]
        pub original_handler: Option<runtime::RemoteObject>,
        /// Node the listener is added to (if any).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<dom::BackendNodeId>,
    }

    /// Returns event listeners of the given object.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEventListeners {
        /// Identifier of the object to return listeners for.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
        /// The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        depth: Option<i64>,
        /// Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false). Reports listeners for all contexts if pierce is enabled.
        #[serde(skip_serializing_if = "Option::is_none")]
        pierce: Option<bool>,
    }

    impl GetEventListeners {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
                depth: None,
                pierce: None,
            }
        }

        pub fn with_depth(mut self, depth: impl Into<i64>) -> Self {
            self.depth = Some(depth.into());
            self
        }

        pub fn with_pierce(mut self, pierce: impl Into<bool>) -> Self {
            self.pierce = Some(pierce.into());
            self
        }
    }

    impl Command for GetEventListeners {
        type Response = GetEventListenersResult;
        const METHOD: &'static str = "DOMDebugger.getEventListeners";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetEventListenersResult {
        /// Array of relevant listeners.
        pub listeners: Vec<EventListener>,
    }

    /// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveDomBreakpoint {
        /// Identifier of the node to remove breakpoint from.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Type of the breakpoint to remove.
        #[serde(rename = "type")]
        type_: DOMBreakpointType,
    }

    impl RemoveDomBreakpoint {
        pub fn new(node_id: impl Into<dom::NodeId>, type_: impl Into<DOMBreakpointType>) -> Self {
            Self {
                node_id: node_id.into(),
                type_: type_.into(),
            }
        }
    }

    impl Command for RemoveDomBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.removeDOMBreakpoint";
    }

    /// Removes breakpoint on particular DOM event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveEventListenerBreakpoint {
        /// Event name.
        #[serde(rename = "eventName")]
        event_name: String,
        /// EventTarget interface name.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetName")]
        target_name: Option<String>,
    }

    impl RemoveEventListenerBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
                target_name: None,
            }
        }

        pub fn with_target_name(mut self, target_name: impl Into<String>) -> Self {
            self.target_name = Some(target_name.into());
            self
        }
    }

    impl Command for RemoveEventListenerBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.removeEventListenerBreakpoint";
    }

    /// Removes breakpoint on particular native event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveInstrumentationBreakpoint {
        /// Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        event_name: String,
    }

    impl RemoveInstrumentationBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
            }
        }
    }

    impl Command for RemoveInstrumentationBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.removeInstrumentationBreakpoint";
    }

    /// Removes breakpoint from XMLHttpRequest.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveXhrBreakpoint {
        /// Resource URL substring.
        url: String,
    }

    impl RemoveXhrBreakpoint {
        pub fn new(url: impl Into<String>) -> Self {
            Self { url: url.into() }
        }
    }

    impl Command for RemoveXhrBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.removeXHRBreakpoint";
    }

    /// Sets breakpoint on particular CSP violations.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakOnCspViolation {
        /// CSP Violations to stop upon.
        #[serde(rename = "violationTypes")]
        violation_types: Vec<CSPViolationType>,
    }

    impl SetBreakOnCspViolation {
        pub fn new(violation_types: impl Into<Vec<CSPViolationType>>) -> Self {
            Self {
                violation_types: violation_types.into(),
            }
        }
    }

    impl Command for SetBreakOnCspViolation {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.setBreakOnCSPViolation";
    }

    /// Sets breakpoint on particular operation with DOM.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDomBreakpoint {
        /// Identifier of the node to set breakpoint on.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Type of the operation to stop upon.
        #[serde(rename = "type")]
        type_: DOMBreakpointType,
    }

    impl SetDomBreakpoint {
        pub fn new(node_id: impl Into<dom::NodeId>, type_: impl Into<DOMBreakpointType>) -> Self {
            Self {
                node_id: node_id.into(),
                type_: type_.into(),
            }
        }
    }

    impl Command for SetDomBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.setDOMBreakpoint";
    }

    /// Sets breakpoint on particular DOM event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEventListenerBreakpoint {
        /// DOM Event name to stop on (any DOM event will do).
        #[serde(rename = "eventName")]
        event_name: String,
        /// EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any EventTarget.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetName")]
        target_name: Option<String>,
    }

    impl SetEventListenerBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
                target_name: None,
            }
        }

        pub fn with_target_name(mut self, target_name: impl Into<String>) -> Self {
            self.target_name = Some(target_name.into());
            self
        }
    }

    impl Command for SetEventListenerBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.setEventListenerBreakpoint";
    }

    /// Sets breakpoint on particular native event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInstrumentationBreakpoint {
        /// Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        event_name: String,
    }

    impl SetInstrumentationBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
            }
        }
    }

    impl Command for SetInstrumentationBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.setInstrumentationBreakpoint";
    }

    /// Sets breakpoint on XMLHttpRequest.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetXhrBreakpoint {
        /// Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
        url: String,
    }

    impl SetXhrBreakpoint {
        pub fn new(url: impl Into<String>) -> Self {
            Self { url: url.into() }
        }
    }

    impl Command for SetXhrBreakpoint {
        type Response = ();
        const METHOD: &'static str = "DOMDebugger.setXHRBreakpoint";
    }
}

pub mod dom_snapshot {
    use super::*;

    /// A Node in the DOM tree.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DOMNode {
        /// `Node`'s nodeType.
        #[serde(rename = "nodeType")]
        pub node_type: i64,
        /// `Node`'s nodeName.
        #[serde(rename = "nodeName")]
        pub node_name: String,
        /// `Node`'s nodeValue.
        #[serde(rename = "nodeValue")]
        pub node_value: String,
        /// Only set for textarea elements, contains the text value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "textValue")]
        pub text_value: Option<String>,
        /// Only set for input elements, contains the input's associated text value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inputValue")]
        pub input_value: Option<String>,
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inputChecked")]
        pub input_checked: Option<bool>,
        /// Only set for option elements, indicates if the element has been selected
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "optionSelected")]
        pub option_selected: Option<bool>,
        /// `Node`'s id, corresponds to DOM.Node.backendNodeId.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: dom::BackendNodeId,
        /// The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "childNodeIndexes")]
        pub child_node_indexes: Option<Vec<i64>>,
        /// Attributes of an `Element` node.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub attributes: Option<Vec<NameValue>>,
        /// Indexes of pseudo elements associated with this node in the `domNodes` array returned by `getSnapshot`, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoElementIndexes")]
        pub pseudo_element_indexes: Option<Vec<i64>>,
        /// The index of the node's related layout tree node in the `layoutTreeNodes` array returned by `getSnapshot`, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "layoutNodeIndex")]
        pub layout_node_index: Option<i64>,
        /// Document URL that `Document` or `FrameOwner` node points to.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "documentURL")]
        pub document_url: Option<String>,
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
        /// Only set for documents, contains the document's content language.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentLanguage")]
        pub content_language: Option<String>,
        /// Only set for documents, contains the document's character set encoding.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "documentEncoding")]
        pub document_encoding: Option<String>,
        /// `DocumentType` node's publicId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "publicId")]
        pub public_id: Option<String>,
        /// `DocumentType` node's systemId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "systemId")]
        pub system_id: Option<String>,
        /// Frame ID for frame owner elements and also for the document node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
        /// The index of a frame owner element's content document in the `domNodes` array returned by `getSnapshot`, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentDocumentIndex")]
        pub content_document_index: Option<i64>,
        /// Type of a pseudo element node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<dom::PseudoType>,
        /// Shadow root type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<dom::ShadowRootType>,
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click event listeners attached via JavaScript as well as anchor tags that naturally navigate when clicked.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isClickable")]
        pub is_clickable: Option<bool>,
        /// Details of the node's event listeners, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "eventListeners")]
        pub event_listeners: Option<Vec<dom_debugger::EventListener>>,
        /// The selected url for nodes with a srcset attribute.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "currentSourceURL")]
        pub current_source_url: Option<String>,
        /// The url of the script (if any) that generates this node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "originURL")]
        pub origin_url: Option<String>,
        /// Scroll offsets, set when this node is a Document.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: Option<f64>,
    }

    /// Details of post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InlineTextBox {
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        #[serde(rename = "boundingBox")]
        pub bounding_box: dom::Rect,
        /// The starting index in characters, for this post layout textbox substring. Characters that would be represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "startCharacterIndex")]
        pub start_character_index: i64,
        /// The number of characters in this post layout textbox substring. Characters that would be represented as a surrogate pair in UTF-16 have length 2.
        #[serde(rename = "numCharacters")]
        pub num_characters: i64,
    }

    /// Details of an element in the DOM tree with a LayoutObject.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayoutTreeNode {
        /// The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
        #[serde(rename = "domNodeIndex")]
        pub dom_node_index: i64,
        /// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
        #[serde(rename = "boundingBox")]
        pub bounding_box: dom::Rect,
        /// Contents of the LayoutText, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "layoutText")]
        pub layout_text: Option<String>,
        /// The post-layout inline text nodes, if any.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inlineTextNodes")]
        pub inline_text_nodes: Option<Vec<InlineTextBox>>,
        /// Index into the `computedStyles` array returned by `getSnapshot`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "styleIndex")]
        pub style_index: Option<i64>,
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes that are painted together will have the same index. Only provided if includePaintOrder in getSnapshot was true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "paintOrder")]
        pub paint_order: Option<i64>,
        /// Set to true to indicate the element begins a new stacking context.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isStackingContext")]
        pub is_stacking_context: Option<bool>,
    }

    /// A subset of the full ComputedStyle as defined by the request whitelist.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ComputedStyle {
        /// Name/value pairs of computed style properties.
        pub properties: Vec<NameValue>,
    }

    /// A name/value pair.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NameValue {
        /// Attribute/property name.
        pub name: String,
        /// Attribute/property value.
        pub value: String,
    }

    /// Index of the string in the strings table.
    pub type StringIndex = i64;

    /// Index of the string in the strings table.
    pub type ArrayOfStrings = Vec<StringIndex>;

    /// Data that is only present on rare nodes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RareStringData {
        pub index: Vec<i64>,
        pub value: Vec<StringIndex>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RareBooleanData {
        pub index: Vec<i64>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RareIntegerData {
        pub index: Vec<i64>,
        pub value: Vec<i64>,
    }

    pub type Rectangle = Vec<f64>;

    /// Document snapshot.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DocumentSnapshot {
        /// Document URL that `Document` or `FrameOwner` node points to.
        #[serde(rename = "documentURL")]
        pub document_url: StringIndex,
        /// Document title.
        pub title: StringIndex,
        /// Base URL that `Document` or `FrameOwner` node uses for URL completion.
        #[serde(rename = "baseURL")]
        pub base_url: StringIndex,
        /// Contains the document's content language.
        #[serde(rename = "contentLanguage")]
        pub content_language: StringIndex,
        /// Contains the document's character set encoding.
        #[serde(rename = "encodingName")]
        pub encoding_name: StringIndex,
        /// `DocumentType` node's publicId.
        #[serde(rename = "publicId")]
        pub public_id: StringIndex,
        /// `DocumentType` node's systemId.
        #[serde(rename = "systemId")]
        pub system_id: StringIndex,
        /// Frame ID for frame owner elements and also for the document node.
        #[serde(rename = "frameId")]
        pub frame_id: StringIndex,
        /// A table with dom nodes.
        pub nodes: NodeTreeSnapshot,
        /// The nodes in the layout tree.
        pub layout: LayoutTreeSnapshot,
        /// The post-layout inline text nodes.
        #[serde(rename = "textBoxes")]
        pub text_boxes: TextBoxSnapshot,
        /// Horizontal scroll offset.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: Option<f64>,
        /// Vertical scroll offset.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: Option<f64>,
        /// Document content width.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentWidth")]
        pub content_width: Option<f64>,
        /// Document content height.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentHeight")]
        pub content_height: Option<f64>,
    }

    /// Table containing nodes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodeTreeSnapshot {
        /// Parent node index.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentIndex")]
        pub parent_index: Option<Vec<i64>>,
        /// `Node`'s nodeType.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeType")]
        pub node_type: Option<Vec<i64>>,
        /// Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shadowRootType")]
        pub shadow_root_type: Option<RareStringData>,
        /// `Node`'s nodeName.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeName")]
        pub node_name: Option<Vec<StringIndex>>,
        /// `Node`'s nodeValue.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeValue")]
        pub node_value: Option<Vec<StringIndex>>,
        /// `Node`'s id, corresponds to DOM.Node.backendNodeId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<Vec<dom::BackendNodeId>>,
        /// Attributes of an `Element` node. Flatten name, value pairs.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub attributes: Option<Vec<ArrayOfStrings>>,
        /// Only set for textarea elements, contains the text value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "textValue")]
        pub text_value: Option<RareStringData>,
        /// Only set for input elements, contains the input's associated text value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inputValue")]
        pub input_value: Option<RareStringData>,
        /// Only set for radio and checkbox input elements, indicates if the element has been checked
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inputChecked")]
        pub input_checked: Option<RareBooleanData>,
        /// Only set for option elements, indicates if the element has been selected
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "optionSelected")]
        pub option_selected: Option<RareBooleanData>,
        /// The index of the document in the list of the snapshot documents.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentDocumentIndex")]
        pub content_document_index: Option<RareIntegerData>,
        /// Type of a pseudo element node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoType")]
        pub pseudo_type: Option<RareStringData>,
        /// Pseudo element identifier for this node. Only present if there is a valid pseudoType.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pseudoIdentifier")]
        pub pseudo_identifier: Option<RareStringData>,
        /// Whether this DOM node responds to mouse clicks. This includes nodes that have had click event listeners attached via JavaScript as well as anchor tags that naturally navigate when clicked.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isClickable")]
        pub is_clickable: Option<RareBooleanData>,
        /// The selected url for nodes with a srcset attribute.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "currentSourceURL")]
        pub current_source_url: Option<RareStringData>,
        /// The url of the script (if any) that generates this node.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "originURL")]
        pub origin_url: Option<RareStringData>,
    }

    /// Table of details of an element in the DOM tree with a LayoutObject.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayoutTreeSnapshot {
        /// Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
        #[serde(rename = "nodeIndex")]
        pub node_index: Vec<i64>,
        /// Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
        pub styles: Vec<ArrayOfStrings>,
        /// The absolute position bounding box.
        pub bounds: Vec<Rectangle>,
        /// Contents of the LayoutText, if any.
        pub text: Vec<StringIndex>,
        /// Stacking context information.
        #[serde(rename = "stackingContexts")]
        pub stacking_contexts: RareBooleanData,
        /// Global paint order index, which is determined by the stacking order of the nodes. Nodes that are painted together will have the same index. Only provided if includePaintOrder in captureSnapshot was true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "paintOrders")]
        pub paint_orders: Option<Vec<i64>>,
        /// The offset rect of nodes. Only available when includeDOMRects is set to true
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "offsetRects")]
        pub offset_rects: Option<Vec<Rectangle>>,
        /// The scroll rect of nodes. Only available when includeDOMRects is set to true
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollRects")]
        pub scroll_rects: Option<Vec<Rectangle>>,
        /// The client rect of nodes. Only available when includeDOMRects is set to true
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clientRects")]
        pub client_rects: Option<Vec<Rectangle>>,
        /// The list of background colors that are blended with colors of overlapping elements.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "blendedBackgroundColors")]
        pub blended_background_colors: Option<Vec<StringIndex>>,
        /// The list of computed text opacities.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "textColorOpacities")]
        pub text_color_opacities: Option<Vec<f64>>,
    }

    /// Table of details of the post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TextBoxSnapshot {
        /// Index of the layout tree node that owns this box collection.
        #[serde(rename = "layoutIndex")]
        pub layout_index: Vec<i64>,
        /// The absolute position bounding box.
        pub bounds: Vec<Rectangle>,
        /// The starting index in characters, for this post layout textbox substring. Characters that would be represented as a surrogate pair in UTF-16 have length 2.
        pub start: Vec<i64>,
        /// The number of characters in this post layout textbox substring. Characters that would be represented as a surrogate pair in UTF-16 have length 2.
        pub length: Vec<i64>,
    }

    /// Disables DOM snapshot agent for the given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "DOMSnapshot.disable";
    }

    /// Enables DOM snapshot agent for the given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "DOMSnapshot.enable";
    }

    /// Returns a document snapshot, including the full DOM tree of the root node (including iframes, template contents, and imported documents) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSnapshot {
        /// Whitelist of computed styles to return.
        #[serde(rename = "computedStyleWhitelist")]
        computed_style_whitelist: Vec<String>,
        /// Whether or not to retrieve details of DOM listeners (default false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeEventListeners")]
        include_event_listeners: Option<bool>,
        /// Whether to determine and include the paint order index of LayoutTreeNodes (default false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includePaintOrder")]
        include_paint_order: Option<bool>,
        /// Whether to include UA shadow tree in the snapshot (default false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeUserAgentShadowTree")]
        include_user_agent_shadow_tree: Option<bool>,
    }

    impl GetSnapshot {
        pub fn new(computed_style_whitelist: impl Into<Vec<String>>) -> Self {
            Self {
                computed_style_whitelist: computed_style_whitelist.into(),
                include_event_listeners: None,
                include_paint_order: None,
                include_user_agent_shadow_tree: None,
            }
        }

        pub fn with_include_event_listeners(
            mut self,
            include_event_listeners: impl Into<bool>,
        ) -> Self {
            self.include_event_listeners = Some(include_event_listeners.into());
            self
        }

        pub fn with_include_paint_order(mut self, include_paint_order: impl Into<bool>) -> Self {
            self.include_paint_order = Some(include_paint_order.into());
            self
        }

        pub fn with_include_user_agent_shadow_tree(
            mut self,
            include_user_agent_shadow_tree: impl Into<bool>,
        ) -> Self {
            self.include_user_agent_shadow_tree = Some(include_user_agent_shadow_tree.into());
            self
        }
    }

    impl Command for GetSnapshot {
        type Response = GetSnapshotResult;
        const METHOD: &'static str = "DOMSnapshot.getSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSnapshotResult {
        /// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
        #[serde(rename = "domNodes")]
        pub dom_nodes: Vec<DOMNode>,
        /// The nodes in the layout tree.
        #[serde(rename = "layoutTreeNodes")]
        pub layout_tree_nodes: Vec<LayoutTreeNode>,
        /// Whitelisted ComputedStyle properties for each node in the layout tree.
        #[serde(rename = "computedStyles")]
        pub computed_styles: Vec<ComputedStyle>,
    }

    /// Returns a document snapshot, including the full DOM tree of the root node (including iframes, template contents, and imported documents) in a flattened array, as well as layout and white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is flattened.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureSnapshot {
        /// Whitelist of computed styles to return.
        #[serde(rename = "computedStyles")]
        computed_styles: Vec<String>,
        /// Whether to include layout object paint orders into the snapshot.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includePaintOrder")]
        include_paint_order: Option<bool>,
        /// Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeDOMRects")]
        include_dom_rects: Option<bool>,
        /// Whether to include blended background colors in the snapshot (default: false). Blended background color is achieved by blending background colors of all elements that overlap with the current element.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeBlendedBackgroundColors")]
        include_blended_background_colors: Option<bool>,
        /// Whether to include text color opacity in the snapshot (default: false). An element might have the opacity property set that affects the text color of the element. The final text color opacity is computed based on the opacity of all overlapping elements.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeTextColorOpacities")]
        include_text_color_opacities: Option<bool>,
    }

    impl CaptureSnapshot {
        pub fn new(computed_styles: impl Into<Vec<String>>) -> Self {
            Self {
                computed_styles: computed_styles.into(),
                include_paint_order: None,
                include_dom_rects: None,
                include_blended_background_colors: None,
                include_text_color_opacities: None,
            }
        }

        pub fn with_include_paint_order(mut self, include_paint_order: impl Into<bool>) -> Self {
            self.include_paint_order = Some(include_paint_order.into());
            self
        }

        pub fn with_include_dom_rects(mut self, include_dom_rects: impl Into<bool>) -> Self {
            self.include_dom_rects = Some(include_dom_rects.into());
            self
        }

        pub fn with_include_blended_background_colors(
            mut self,
            include_blended_background_colors: impl Into<bool>,
        ) -> Self {
            self.include_blended_background_colors = Some(include_blended_background_colors.into());
            self
        }

        pub fn with_include_text_color_opacities(
            mut self,
            include_text_color_opacities: impl Into<bool>,
        ) -> Self {
            self.include_text_color_opacities = Some(include_text_color_opacities.into());
            self
        }
    }

    impl Command for CaptureSnapshot {
        type Response = CaptureSnapshotResult;
        const METHOD: &'static str = "DOMSnapshot.captureSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureSnapshotResult {
        /// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
        pub documents: Vec<DocumentSnapshot>,
        /// Shared string table that all string properties refer to with indexes.
        pub strings: Vec<String>,
    }
}

pub mod dom_storage {
    use super::*;

    pub type SerializedStorageKey = String;

    /// DOM Storage identifier.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StorageId {
        /// Security origin for the storage.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        pub security_origin: Option<String>,
        /// Represents a key by which DOM Storage keys its CachedStorageAreas
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        pub storage_key: Option<SerializedStorageKey>,
        /// Whether the storage is local storage (not session storage).
        #[serde(rename = "isLocalStorage")]
        pub is_local_storage: bool,
    }

    /// DOM Storage item.
    pub type Item = Vec<String>;

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Clear {
        #[serde(rename = "storageId")]
        storage_id: StorageId,
    }

    impl Clear {
        pub fn new(storage_id: impl Into<StorageId>) -> Self {
            Self {
                storage_id: storage_id.into(),
            }
        }
    }

    impl Command for Clear {
        type Response = ();
        const METHOD: &'static str = "DOMStorage.clear";
    }

    /// Disables storage tracking, prevents storage events from being sent to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "DOMStorage.disable";
    }

    /// Enables storage tracking, storage events will now be delivered to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "DOMStorage.enable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomStorageItems {
        #[serde(rename = "storageId")]
        storage_id: StorageId,
    }

    impl GetDomStorageItems {
        pub fn new(storage_id: impl Into<StorageId>) -> Self {
            Self {
                storage_id: storage_id.into(),
            }
        }
    }

    impl Command for GetDomStorageItems {
        type Response = GetDomStorageItemsResult;
        const METHOD: &'static str = "DOMStorage.getDOMStorageItems";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomStorageItemsResult {
        pub entries: Vec<Item>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveDomStorageItem {
        #[serde(rename = "storageId")]
        storage_id: StorageId,
        key: String,
    }

    impl RemoveDomStorageItem {
        pub fn new(storage_id: impl Into<StorageId>, key: impl Into<String>) -> Self {
            Self {
                storage_id: storage_id.into(),
                key: key.into(),
            }
        }
    }

    impl Command for RemoveDomStorageItem {
        type Response = ();
        const METHOD: &'static str = "DOMStorage.removeDOMStorageItem";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDomStorageItem {
        #[serde(rename = "storageId")]
        storage_id: StorageId,
        key: String,
        value: String,
    }

    impl SetDomStorageItem {
        pub fn new(
            storage_id: impl Into<StorageId>,
            key: impl Into<String>,
            value: impl Into<String>,
        ) -> Self {
            Self {
                storage_id: storage_id.into(),
                key: key.into(),
                value: value.into(),
            }
        }
    }

    impl Command for SetDomStorageItem {
        type Response = ();
        const METHOD: &'static str = "DOMStorage.setDOMStorageItem";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DomStorageItemAdded {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        pub key: String,
        #[serde(rename = "newValue")]
        pub new_value: String,
    }

    impl DomStorageItemAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOMStorage.domStorageItemAdded")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DomStorageItemRemoved {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        pub key: String,
    }

    impl DomStorageItemRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOMStorage.domStorageItemRemoved")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DomStorageItemUpdated {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
        pub key: String,
        #[serde(rename = "oldValue")]
        pub old_value: String,
        #[serde(rename = "newValue")]
        pub new_value: String,
    }

    impl DomStorageItemUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOMStorage.domStorageItemUpdated")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DomStorageItemsCleared {
        #[serde(rename = "storageId")]
        pub storage_id: StorageId,
    }

    impl DomStorageItemsCleared {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DOMStorage.domStorageItemsCleared")
        }
    }
}

pub mod device_access {
    use super::*;

    /// Device request id.
    pub type RequestId = String;

    /// A device id.
    pub type DeviceId = String;

    /// Device information displayed in a user prompt to select a device.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PromptDevice {
        pub id: DeviceId,
        /// Display name as it appears in a device request user prompt.
        pub name: String,
    }

    /// Enable events in this domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "DeviceAccess.enable";
    }

    /// Disable events in this domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "DeviceAccess.disable";
    }

    /// Select a device in response to a DeviceAccess.deviceRequestPrompted event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SelectPrompt {
        id: RequestId,
        #[serde(rename = "deviceId")]
        device_id: DeviceId,
    }

    impl SelectPrompt {
        pub fn new(id: impl Into<RequestId>, device_id: impl Into<DeviceId>) -> Self {
            Self {
                id: id.into(),
                device_id: device_id.into(),
            }
        }
    }

    impl Command for SelectPrompt {
        type Response = ();
        const METHOD: &'static str = "DeviceAccess.selectPrompt";
    }

    /// Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CancelPrompt {
        id: RequestId,
    }

    impl CancelPrompt {
        pub fn new(id: impl Into<RequestId>) -> Self {
            Self { id: id.into() }
        }
    }

    impl Command for CancelPrompt {
        type Response = ();
        const METHOD: &'static str = "DeviceAccess.cancelPrompt";
    }

    /// A device request opened a user prompt to select a device. Respond with the selectPrompt or cancelPrompt command.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceRequestPrompted {
        pub id: RequestId,
        pub devices: Vec<PromptDevice>,
    }

    impl DeviceRequestPrompted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("DeviceAccess.deviceRequestPrompted")
        }
    }
}

pub mod device_orientation {
    use super::*;

    /// Clears the overridden Device Orientation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDeviceOrientationOverride {}

    impl ClearDeviceOrientationOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDeviceOrientationOverride {
        type Response = ();
        const METHOD: &'static str = "DeviceOrientation.clearDeviceOrientationOverride";
    }

    /// Overrides the Device Orientation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDeviceOrientationOverride {
        /// Mock alpha
        alpha: f64,
        /// Mock beta
        beta: f64,
        /// Mock gamma
        gamma: f64,
    }

    impl SetDeviceOrientationOverride {
        pub fn new(alpha: impl Into<f64>, beta: impl Into<f64>, gamma: impl Into<f64>) -> Self {
            Self {
                alpha: alpha.into(),
                beta: beta.into(),
                gamma: gamma.into(),
            }
        }
    }

    impl Command for SetDeviceOrientationOverride {
        type Response = ();
        const METHOD: &'static str = "DeviceOrientation.setDeviceOrientationOverride";
    }
}

pub mod emulation {
    use super::*;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SafeAreaInsets {
        /// Overrides safe-area-inset-top.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub top: Option<i64>,
        /// Overrides safe-area-max-inset-top.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "topMax")]
        pub top_max: Option<i64>,
        /// Overrides safe-area-inset-left.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub left: Option<i64>,
        /// Overrides safe-area-max-inset-left.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "leftMax")]
        pub left_max: Option<i64>,
        /// Overrides safe-area-inset-bottom.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bottom: Option<i64>,
        /// Overrides safe-area-max-inset-bottom.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bottomMax")]
        pub bottom_max: Option<i64>,
        /// Overrides safe-area-inset-right.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub right: Option<i64>,
        /// Overrides safe-area-max-inset-right.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rightMax")]
        pub right_max: Option<i64>,
    }

    /// Screen orientation.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreenOrientation {
        /// Orientation type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Orientation angle.
        pub angle: i64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DisplayFeature {
        /// Orientation of a display feature in relation to screen
        pub orientation: String,
        /// The offset from the screen origin in either the x (for vertical orientation) or y (for horizontal orientation) direction.
        pub offset: i64,
        /// A display feature may mask content such that it is not physically displayed - this length along with the offset describes this area. A display feature that only splits content will have a 0 mask_length.
        #[serde(rename = "maskLength")]
        pub mask_length: i64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DevicePosture {
        /// Current posture of the device
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MediaFeature {
        pub name: String,
        pub value: String,
    }

    /// advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to allow the next delayed task (if any) to run; pause: The virtual time base may not advance; pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending resource fetches.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum VirtualTimePolicy {
        #[serde(rename = "advance")]
        Advance,
        #[serde(rename = "pause")]
        Pause,
        #[serde(rename = "pauseIfNetworkFetchesPending")]
        PauseIfNetworkFetchesPending,
    }
    impl From<&str> for VirtualTimePolicy {
        fn from(s: &str) -> Self {
            match s {
                "advance" => Self::Advance,
                "pause" => Self::Pause,
                "pauseIfNetworkFetchesPending" => Self::PauseIfNetworkFetchesPending,
                _ => Self::Advance,
            }
        }
    }
    impl From<String> for VirtualTimePolicy {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UserAgentBrandVersion {
        pub brand: String,
        pub version: String,
    }

    /// Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints Missing optional values will be filled in by the target with what it would normally use.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UserAgentMetadata {
        /// Brands appearing in Sec-CH-UA.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub brands: Option<Vec<UserAgentBrandVersion>>,
        /// Brands appearing in Sec-CH-UA-Full-Version-List.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fullVersionList")]
        pub full_version_list: Option<Vec<UserAgentBrandVersion>>,
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fullVersion")]
        pub full_version: Option<String>,
        pub platform: String,
        #[serde(rename = "platformVersion")]
        pub platform_version: String,
        pub architecture: String,
        pub model: String,
        pub mobile: bool,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bitness: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub wow64: Option<bool>,
        /// Used to specify User Agent form-factor values. See https://wicg.github.io/ua-client-hints/#sec-ch-ua-form-factors
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "formFactors")]
        pub form_factors: Option<Vec<String>>,
    }

    /// Used to specify sensor types to emulate. See https://w3c.github.io/sensors/#automation for more information.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SensorType {
        #[serde(rename = "absolute-orientation")]
        AbsoluteOrientation,
        #[serde(rename = "accelerometer")]
        Accelerometer,
        #[serde(rename = "ambient-light")]
        AmbientLight,
        #[serde(rename = "gravity")]
        Gravity,
        #[serde(rename = "gyroscope")]
        Gyroscope,
        #[serde(rename = "linear-acceleration")]
        LinearAcceleration,
        #[serde(rename = "magnetometer")]
        Magnetometer,
        #[serde(rename = "relative-orientation")]
        RelativeOrientation,
    }
    impl From<&str> for SensorType {
        fn from(s: &str) -> Self {
            match s {
                "absolute-orientation" => Self::AbsoluteOrientation,
                "accelerometer" => Self::Accelerometer,
                "ambient-light" => Self::AmbientLight,
                "gravity" => Self::Gravity,
                "gyroscope" => Self::Gyroscope,
                "linear-acceleration" => Self::LinearAcceleration,
                "magnetometer" => Self::Magnetometer,
                "relative-orientation" => Self::RelativeOrientation,
                _ => Self::AbsoluteOrientation,
            }
        }
    }
    impl From<String> for SensorType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SensorMetadata {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub available: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "minimumFrequency")]
        pub minimum_frequency: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maximumFrequency")]
        pub maximum_frequency: Option<f64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SensorReadingSingle {
        pub value: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SensorReadingXYZ {
        pub x: f64,
        pub y: f64,
        pub z: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SensorReadingQuaternion {
        pub x: f64,
        pub y: f64,
        pub z: f64,
        pub w: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SensorReading {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub single: Option<SensorReadingSingle>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub xyz: Option<SensorReadingXYZ>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub quaternion: Option<SensorReadingQuaternion>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PressureSource {
        #[serde(rename = "cpu")]
        Cpu,
    }
    impl From<&str> for PressureSource {
        fn from(s: &str) -> Self {
            match s {
                "cpu" => Self::Cpu,
                _ => Self::Cpu,
            }
        }
    }
    impl From<String> for PressureSource {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PressureState {
        #[serde(rename = "nominal")]
        Nominal,
        #[serde(rename = "fair")]
        Fair,
        #[serde(rename = "serious")]
        Serious,
        #[serde(rename = "critical")]
        Critical,
    }
    impl From<&str> for PressureState {
        fn from(s: &str) -> Self {
            match s {
                "nominal" => Self::Nominal,
                "fair" => Self::Fair,
                "serious" => Self::Serious,
                "critical" => Self::Critical,
                _ => Self::Nominal,
            }
        }
    }
    impl From<String> for PressureState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PressureMetadata {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub available: Option<bool>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WorkAreaInsets {
        /// Work area top inset in pixels. Default is 0;
        #[serde(skip_serializing_if = "Option::is_none")]
        pub top: Option<i64>,
        /// Work area left inset in pixels. Default is 0;
        #[serde(skip_serializing_if = "Option::is_none")]
        pub left: Option<i64>,
        /// Work area bottom inset in pixels. Default is 0;
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bottom: Option<i64>,
        /// Work area right inset in pixels. Default is 0;
        #[serde(skip_serializing_if = "Option::is_none")]
        pub right: Option<i64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type ScreenId = String;

    /// Screen information similar to the one returned by window.getScreenDetails() method, see https://w3c.github.io/window-management/#screendetailed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreenInfo {
        /// Offset of the left edge of the screen.
        pub left: i64,
        /// Offset of the top edge of the screen.
        pub top: i64,
        /// Width of the screen.
        pub width: i64,
        /// Height of the screen.
        pub height: i64,
        /// Offset of the left edge of the available screen area.
        #[serde(rename = "availLeft")]
        pub avail_left: i64,
        /// Offset of the top edge of the available screen area.
        #[serde(rename = "availTop")]
        pub avail_top: i64,
        /// Width of the available screen area.
        #[serde(rename = "availWidth")]
        pub avail_width: i64,
        /// Height of the available screen area.
        #[serde(rename = "availHeight")]
        pub avail_height: i64,
        /// Specifies the screen's device pixel ratio.
        #[serde(rename = "devicePixelRatio")]
        pub device_pixel_ratio: f64,
        /// Specifies the screen's orientation.
        pub orientation: ScreenOrientation,
        /// Specifies the screen's color depth in bits.
        #[serde(rename = "colorDepth")]
        pub color_depth: i64,
        /// Indicates whether the device has multiple screens.
        #[serde(rename = "isExtended")]
        pub is_extended: bool,
        /// Indicates whether the screen is internal to the device or external, attached to the device.
        #[serde(rename = "isInternal")]
        pub is_internal: bool,
        /// Indicates whether the screen is set as the the operating system primary screen.
        #[serde(rename = "isPrimary")]
        pub is_primary: bool,
        /// Specifies the descriptive label for the screen.
        pub label: String,
        /// Specifies the unique identifier of the screen.
        pub id: ScreenId,
    }

    /// Enum of image types that can be disabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DisabledImageType {
        #[serde(rename = "avif")]
        Avif,
        #[serde(rename = "webp")]
        Webp,
    }
    impl From<&str> for DisabledImageType {
        fn from(s: &str) -> Self {
            match s {
                "avif" => Self::Avif,
                "webp" => Self::Webp,
                _ => Self::Avif,
            }
        }
    }
    impl From<String> for DisabledImageType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Tells whether emulation is supported.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanEmulate {}

    impl CanEmulate {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CanEmulate {
        type Response = CanEmulateResult;
        const METHOD: &'static str = "Emulation.canEmulate";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanEmulateResult {
        /// True if emulation is supported.
        pub result: bool,
    }

    /// Clears the overridden device metrics.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDeviceMetricsOverride {}

    impl ClearDeviceMetricsOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDeviceMetricsOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.clearDeviceMetricsOverride";
    }

    /// Clears the overridden Geolocation Position and Error.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearGeolocationOverride {}

    impl ClearGeolocationOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearGeolocationOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.clearGeolocationOverride";
    }

    /// Requests that page scale factor is reset to initial values.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetPageScaleFactor {}

    impl ResetPageScaleFactor {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ResetPageScaleFactor {
        type Response = ();
        const METHOD: &'static str = "Emulation.resetPageScaleFactor";
    }

    /// Enables or disables simulating a focused and active page.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetFocusEmulationEnabled {
        /// Whether to enable to disable focus emulation.
        enabled: bool,
    }

    impl SetFocusEmulationEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetFocusEmulationEnabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setFocusEmulationEnabled";
    }

    /// Automatically render all web contents using a dark theme.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAutoDarkModeOverride {
        /// Whether to enable or disable automatic dark mode. If not specified, any existing override will be cleared.
        #[serde(skip_serializing_if = "Option::is_none")]
        enabled: Option<bool>,
    }

    impl SetAutoDarkModeOverride {
        pub fn new() -> Self {
            Self { enabled: None }
        }

        pub fn with_enabled(mut self, enabled: impl Into<bool>) -> Self {
            self.enabled = Some(enabled.into());
            self
        }
    }

    impl Command for SetAutoDarkModeOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setAutoDarkModeOverride";
    }

    /// Enables CPU throttling to emulate slow CPUs.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCpuThrottlingRate {
        /// Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
        rate: f64,
    }

    impl SetCpuThrottlingRate {
        pub fn new(rate: impl Into<f64>) -> Self {
            Self { rate: rate.into() }
        }
    }

    impl Command for SetCpuThrottlingRate {
        type Response = ();
        const METHOD: &'static str = "Emulation.setCPUThrottlingRate";
    }

    /// Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDefaultBackgroundColorOverride {
        /// RGBA of the default background color. If not specified, any existing override will be cleared.
        #[serde(skip_serializing_if = "Option::is_none")]
        color: Option<dom::RGBA>,
    }

    impl SetDefaultBackgroundColorOverride {
        pub fn new() -> Self {
            Self { color: None }
        }

        pub fn with_color(mut self, color: impl Into<dom::RGBA>) -> Self {
            self.color = Some(color.into());
            self
        }
    }

    impl Command for SetDefaultBackgroundColorOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDefaultBackgroundColorOverride";
    }

    /// Overrides the values for env(safe-area-inset-*) and env(safe-area-max-inset-*). Unset values will cause the respective variables to be undefined, even if previously overridden.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSafeAreaInsetsOverride {
        insets: SafeAreaInsets,
    }

    impl SetSafeAreaInsetsOverride {
        pub fn new(insets: impl Into<SafeAreaInsets>) -> Self {
            Self {
                insets: insets.into(),
            }
        }
    }

    impl Command for SetSafeAreaInsetsOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setSafeAreaInsetsOverride";
    }

    /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDeviceMetricsOverride {
        /// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        width: i64,
        /// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        height: i64,
        /// Overriding device scale factor value. 0 disables the override.
        #[serde(rename = "deviceScaleFactor")]
        device_scale_factor: f64,
        /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
        mobile: bool,
        /// Scale to apply to resulting view image.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        scale: Option<f64>,
        /// Overriding screen width value in pixels (minimum 0, maximum 10000000).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenWidth")]
        screen_width: Option<i64>,
        /// Overriding screen height value in pixels (minimum 0, maximum 10000000).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenHeight")]
        screen_height: Option<i64>,
        /// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "positionX")]
        position_x: Option<i64>,
        /// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "positionY")]
        position_y: Option<i64>,
        /// Do not set visible view size, rely upon explicit setVisibleSize call.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dontSetVisibleSize")]
        dont_set_visible_size: Option<bool>,
        /// Screen orientation override.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenOrientation")]
        screen_orientation: Option<ScreenOrientation>,
        /// If set, the visible area of the page will be overridden to this viewport. This viewport change is not observed by the page, e.g. viewport-relative elements do not change positions.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        viewport: Option<page::Viewport>,
        /// If set, the display feature of a multi-segment screen. If not set, multi-segment support is turned-off. Deprecated, use Emulation.setDisplayFeaturesOverride.
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "displayFeature")]
        display_feature: Option<DisplayFeature>,
        /// If set, the posture of a foldable device. If not set the posture is set to continuous. Deprecated, use Emulation.setDevicePostureOverride.
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "devicePosture")]
        device_posture: Option<DevicePosture>,
    }

    impl SetDeviceMetricsOverride {
        pub fn new(
            width: impl Into<i64>,
            height: impl Into<i64>,
            device_scale_factor: impl Into<f64>,
            mobile: impl Into<bool>,
        ) -> Self {
            Self {
                width: width.into(),
                height: height.into(),
                device_scale_factor: device_scale_factor.into(),
                mobile: mobile.into(),
                scale: None,
                screen_width: None,
                screen_height: None,
                position_x: None,
                position_y: None,
                dont_set_visible_size: None,
                screen_orientation: None,
                viewport: None,
                display_feature: None,
                device_posture: None,
            }
        }

        pub fn with_scale(mut self, scale: impl Into<f64>) -> Self {
            self.scale = Some(scale.into());
            self
        }

        pub fn with_screen_width(mut self, screen_width: impl Into<i64>) -> Self {
            self.screen_width = Some(screen_width.into());
            self
        }

        pub fn with_screen_height(mut self, screen_height: impl Into<i64>) -> Self {
            self.screen_height = Some(screen_height.into());
            self
        }

        pub fn with_position_x(mut self, position_x: impl Into<i64>) -> Self {
            self.position_x = Some(position_x.into());
            self
        }

        pub fn with_position_y(mut self, position_y: impl Into<i64>) -> Self {
            self.position_y = Some(position_y.into());
            self
        }

        pub fn with_dont_set_visible_size(
            mut self,
            dont_set_visible_size: impl Into<bool>,
        ) -> Self {
            self.dont_set_visible_size = Some(dont_set_visible_size.into());
            self
        }

        pub fn with_screen_orientation(
            mut self,
            screen_orientation: impl Into<ScreenOrientation>,
        ) -> Self {
            self.screen_orientation = Some(screen_orientation.into());
            self
        }

        pub fn with_viewport(mut self, viewport: impl Into<page::Viewport>) -> Self {
            self.viewport = Some(viewport.into());
            self
        }

        pub fn with_display_feature(mut self, display_feature: impl Into<DisplayFeature>) -> Self {
            self.display_feature = Some(display_feature.into());
            self
        }

        pub fn with_device_posture(mut self, device_posture: impl Into<DevicePosture>) -> Self {
            self.device_posture = Some(device_posture.into());
            self
        }
    }

    impl Command for SetDeviceMetricsOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDeviceMetricsOverride";
    }

    /// Start reporting the given posture value to the Device Posture API. This override can also be set in setDeviceMetricsOverride().
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDevicePostureOverride {
        posture: DevicePosture,
    }

    impl SetDevicePostureOverride {
        pub fn new(posture: impl Into<DevicePosture>) -> Self {
            Self {
                posture: posture.into(),
            }
        }
    }

    impl Command for SetDevicePostureOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDevicePostureOverride";
    }

    /// Clears a device posture override set with either setDeviceMetricsOverride() or setDevicePostureOverride() and starts using posture information from the platform again. Does nothing if no override is set.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDevicePostureOverride {}

    impl ClearDevicePostureOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDevicePostureOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.clearDevicePostureOverride";
    }

    /// Start using the given display features to pupulate the Viewport Segments API. This override can also be set in setDeviceMetricsOverride().
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDisplayFeaturesOverride {
        features: Vec<DisplayFeature>,
    }

    impl SetDisplayFeaturesOverride {
        pub fn new(features: impl Into<Vec<DisplayFeature>>) -> Self {
            Self {
                features: features.into(),
            }
        }
    }

    impl Command for SetDisplayFeaturesOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDisplayFeaturesOverride";
    }

    /// Clears the display features override set with either setDeviceMetricsOverride() or setDisplayFeaturesOverride() and starts using display features from the platform again. Does nothing if no override is set.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDisplayFeaturesOverride {}

    impl ClearDisplayFeaturesOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDisplayFeaturesOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.clearDisplayFeaturesOverride";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScrollbarsHidden {
        /// Whether scrollbars should be always hidden.
        hidden: bool,
    }

    impl SetScrollbarsHidden {
        pub fn new(hidden: impl Into<bool>) -> Self {
            Self {
                hidden: hidden.into(),
            }
        }
    }

    impl Command for SetScrollbarsHidden {
        type Response = ();
        const METHOD: &'static str = "Emulation.setScrollbarsHidden";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDocumentCookieDisabled {
        /// Whether document.coookie API should be disabled.
        disabled: bool,
    }

    impl SetDocumentCookieDisabled {
        pub fn new(disabled: impl Into<bool>) -> Self {
            Self {
                disabled: disabled.into(),
            }
        }
    }

    impl Command for SetDocumentCookieDisabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDocumentCookieDisabled";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEmitTouchEventsForMouse {
        /// Whether touch emulation based on mouse input should be enabled.
        enabled: bool,
        /// Touch/gesture events configuration. Default: current platform.
        #[serde(skip_serializing_if = "Option::is_none")]
        configuration: Option<String>,
    }

    impl SetEmitTouchEventsForMouse {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
                configuration: None,
            }
        }

        pub fn with_configuration(mut self, configuration: impl Into<String>) -> Self {
            self.configuration = Some(configuration.into());
            self
        }
    }

    impl Command for SetEmitTouchEventsForMouse {
        type Response = ();
        const METHOD: &'static str = "Emulation.setEmitTouchEventsForMouse";
    }

    /// Emulates the given media type or media feature for CSS media queries.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEmulatedMedia {
        /// Media type to emulate. Empty string disables the override.
        #[serde(skip_serializing_if = "Option::is_none")]
        media: Option<String>,
        /// Media features to emulate.
        #[serde(skip_serializing_if = "Option::is_none")]
        features: Option<Vec<MediaFeature>>,
    }

    impl SetEmulatedMedia {
        pub fn new() -> Self {
            Self {
                media: None,
                features: None,
            }
        }

        pub fn with_media(mut self, media: impl Into<String>) -> Self {
            self.media = Some(media.into());
            self
        }

        pub fn with_features(mut self, features: impl Into<Vec<MediaFeature>>) -> Self {
            self.features = Some(features.into());
            self
        }
    }

    impl Command for SetEmulatedMedia {
        type Response = ();
        const METHOD: &'static str = "Emulation.setEmulatedMedia";
    }

    /// Emulates the given vision deficiency.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEmulatedVisionDeficiency {
        /// Vision deficiency to emulate. Order: best-effort emulations come first, followed by any physiologically accurate emulations for medically recognized color vision deficiencies.
        #[serde(rename = "type")]
        type_: String,
    }

    impl SetEmulatedVisionDeficiency {
        pub fn new(type_: impl Into<String>) -> Self {
            Self {
                type_: type_.into(),
            }
        }
    }

    impl Command for SetEmulatedVisionDeficiency {
        type Response = ();
        const METHOD: &'static str = "Emulation.setEmulatedVisionDeficiency";
    }

    /// Emulates the given OS text scale.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetEmulatedOsTextScale {
        #[serde(skip_serializing_if = "Option::is_none")]
        scale: Option<f64>,
    }

    impl SetEmulatedOsTextScale {
        pub fn new() -> Self {
            Self { scale: None }
        }

        pub fn with_scale(mut self, scale: impl Into<f64>) -> Self {
            self.scale = Some(scale.into());
            self
        }
    }

    impl Command for SetEmulatedOsTextScale {
        type Response = ();
        const METHOD: &'static str = "Emulation.setEmulatedOSTextScale";
    }

    /// Overrides the Geolocation Position or Error. Omitting latitude, longitude or accuracy emulates position unavailable.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetGeolocationOverride {
        /// Mock latitude
        #[serde(skip_serializing_if = "Option::is_none")]
        latitude: Option<f64>,
        /// Mock longitude
        #[serde(skip_serializing_if = "Option::is_none")]
        longitude: Option<f64>,
        /// Mock accuracy
        #[serde(skip_serializing_if = "Option::is_none")]
        accuracy: Option<f64>,
        /// Mock altitude
        #[serde(skip_serializing_if = "Option::is_none")]
        altitude: Option<f64>,
        /// Mock altitudeAccuracy
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "altitudeAccuracy")]
        altitude_accuracy: Option<f64>,
        /// Mock heading
        #[serde(skip_serializing_if = "Option::is_none")]
        heading: Option<f64>,
        /// Mock speed
        #[serde(skip_serializing_if = "Option::is_none")]
        speed: Option<f64>,
    }

    impl SetGeolocationOverride {
        pub fn new() -> Self {
            Self {
                latitude: None,
                longitude: None,
                accuracy: None,
                altitude: None,
                altitude_accuracy: None,
                heading: None,
                speed: None,
            }
        }

        pub fn with_latitude(mut self, latitude: impl Into<f64>) -> Self {
            self.latitude = Some(latitude.into());
            self
        }

        pub fn with_longitude(mut self, longitude: impl Into<f64>) -> Self {
            self.longitude = Some(longitude.into());
            self
        }

        pub fn with_accuracy(mut self, accuracy: impl Into<f64>) -> Self {
            self.accuracy = Some(accuracy.into());
            self
        }

        pub fn with_altitude(mut self, altitude: impl Into<f64>) -> Self {
            self.altitude = Some(altitude.into());
            self
        }

        pub fn with_altitude_accuracy(mut self, altitude_accuracy: impl Into<f64>) -> Self {
            self.altitude_accuracy = Some(altitude_accuracy.into());
            self
        }

        pub fn with_heading(mut self, heading: impl Into<f64>) -> Self {
            self.heading = Some(heading.into());
            self
        }

        pub fn with_speed(mut self, speed: impl Into<f64>) -> Self {
            self.speed = Some(speed.into());
            self
        }
    }

    impl Command for SetGeolocationOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setGeolocationOverride";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOverriddenSensorInformation {
        #[serde(rename = "type")]
        type_: SensorType,
    }

    impl GetOverriddenSensorInformation {
        pub fn new(type_: impl Into<SensorType>) -> Self {
            Self {
                type_: type_.into(),
            }
        }
    }

    impl Command for GetOverriddenSensorInformation {
        type Response = GetOverriddenSensorInformationResult;
        const METHOD: &'static str = "Emulation.getOverriddenSensorInformation";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOverriddenSensorInformationResult {
        #[serde(rename = "requestedSamplingFrequency")]
        pub requested_sampling_frequency: f64,
    }

    /// Overrides a platform sensor of a given type. If |enabled| is true, calls to Sensor.start() will use a virtual sensor as backend rather than fetching data from a real hardware sensor. Otherwise, existing virtual sensor-backend Sensor objects will fire an error event and new calls to Sensor.start() will attempt to use a real sensor instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSensorOverrideEnabled {
        enabled: bool,
        #[serde(rename = "type")]
        type_: SensorType,
        #[serde(skip_serializing_if = "Option::is_none")]
        metadata: Option<SensorMetadata>,
    }

    impl SetSensorOverrideEnabled {
        pub fn new(enabled: impl Into<bool>, type_: impl Into<SensorType>) -> Self {
            Self {
                enabled: enabled.into(),
                type_: type_.into(),
                metadata: None,
            }
        }

        pub fn with_metadata(mut self, metadata: impl Into<SensorMetadata>) -> Self {
            self.metadata = Some(metadata.into());
            self
        }
    }

    impl Command for SetSensorOverrideEnabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setSensorOverrideEnabled";
    }

    /// Updates the sensor readings reported by a sensor type previously overridden by setSensorOverrideEnabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSensorOverrideReadings {
        #[serde(rename = "type")]
        type_: SensorType,
        reading: SensorReading,
    }

    impl SetSensorOverrideReadings {
        pub fn new(type_: impl Into<SensorType>, reading: impl Into<SensorReading>) -> Self {
            Self {
                type_: type_.into(),
                reading: reading.into(),
            }
        }
    }

    impl Command for SetSensorOverrideReadings {
        type Response = ();
        const METHOD: &'static str = "Emulation.setSensorOverrideReadings";
    }

    /// Overrides a pressure source of a given type, as used by the Compute Pressure API, so that updates to PressureObserver.observe() are provided via setPressureStateOverride instead of being retrieved from platform-provided telemetry data.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPressureSourceOverrideEnabled {
        enabled: bool,
        source: PressureSource,
        #[serde(skip_serializing_if = "Option::is_none")]
        metadata: Option<PressureMetadata>,
    }

    impl SetPressureSourceOverrideEnabled {
        pub fn new(enabled: impl Into<bool>, source: impl Into<PressureSource>) -> Self {
            Self {
                enabled: enabled.into(),
                source: source.into(),
                metadata: None,
            }
        }

        pub fn with_metadata(mut self, metadata: impl Into<PressureMetadata>) -> Self {
            self.metadata = Some(metadata.into());
            self
        }
    }

    impl Command for SetPressureSourceOverrideEnabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setPressureSourceOverrideEnabled";
    }

    /// TODO: OBSOLETE: To remove when setPressureDataOverride is merged. Provides a given pressure state that will be processed and eventually be delivered to PressureObserver users. |source| must have been previously overridden by setPressureSourceOverrideEnabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPressureStateOverride {
        source: PressureSource,
        state: PressureState,
    }

    impl SetPressureStateOverride {
        pub fn new(source: impl Into<PressureSource>, state: impl Into<PressureState>) -> Self {
            Self {
                source: source.into(),
                state: state.into(),
            }
        }
    }

    impl Command for SetPressureStateOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setPressureStateOverride";
    }

    /// Provides a given pressure data set that will be processed and eventually be delivered to PressureObserver users. |source| must have been previously overridden by setPressureSourceOverrideEnabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPressureDataOverride {
        source: PressureSource,
        state: PressureState,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ownContributionEstimate")]
        own_contribution_estimate: Option<f64>,
    }

    impl SetPressureDataOverride {
        pub fn new(source: impl Into<PressureSource>, state: impl Into<PressureState>) -> Self {
            Self {
                source: source.into(),
                state: state.into(),
                own_contribution_estimate: None,
            }
        }

        pub fn with_own_contribution_estimate(
            mut self,
            own_contribution_estimate: impl Into<f64>,
        ) -> Self {
            self.own_contribution_estimate = Some(own_contribution_estimate.into());
            self
        }
    }

    impl Command for SetPressureDataOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setPressureDataOverride";
    }

    /// Overrides the Idle state.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetIdleOverride {
        /// Mock isUserActive
        #[serde(rename = "isUserActive")]
        is_user_active: bool,
        /// Mock isScreenUnlocked
        #[serde(rename = "isScreenUnlocked")]
        is_screen_unlocked: bool,
    }

    impl SetIdleOverride {
        pub fn new(is_user_active: impl Into<bool>, is_screen_unlocked: impl Into<bool>) -> Self {
            Self {
                is_user_active: is_user_active.into(),
                is_screen_unlocked: is_screen_unlocked.into(),
            }
        }
    }

    impl Command for SetIdleOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setIdleOverride";
    }

    /// Clears Idle state overrides.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearIdleOverride {}

    impl ClearIdleOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearIdleOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.clearIdleOverride";
    }

    /// Overrides value returned by the javascript navigator object.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetNavigatorOverrides {
        /// The platform navigator.platform should return.
        platform: String,
    }

    impl SetNavigatorOverrides {
        pub fn new(platform: impl Into<String>) -> Self {
            Self {
                platform: platform.into(),
            }
        }
    }

    impl Command for SetNavigatorOverrides {
        type Response = ();
        const METHOD: &'static str = "Emulation.setNavigatorOverrides";
    }

    /// Sets a specified page scale factor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPageScaleFactor {
        /// Page scale factor.
        #[serde(rename = "pageScaleFactor")]
        page_scale_factor: f64,
    }

    impl SetPageScaleFactor {
        pub fn new(page_scale_factor: impl Into<f64>) -> Self {
            Self {
                page_scale_factor: page_scale_factor.into(),
            }
        }
    }

    impl Command for SetPageScaleFactor {
        type Response = ();
        const METHOD: &'static str = "Emulation.setPageScaleFactor";
    }

    /// Switches script execution in the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScriptExecutionDisabled {
        /// Whether script execution should be disabled in the page.
        value: bool,
    }

    impl SetScriptExecutionDisabled {
        pub fn new(value: impl Into<bool>) -> Self {
            Self {
                value: value.into(),
            }
        }
    }

    impl Command for SetScriptExecutionDisabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setScriptExecutionDisabled";
    }

    /// Enables touch on platforms which do not support them.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetTouchEmulationEnabled {
        /// Whether the touch event emulation should be enabled.
        enabled: bool,
        /// Maximum touch points supported. Defaults to one.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxTouchPoints")]
        max_touch_points: Option<i64>,
    }

    impl SetTouchEmulationEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
                max_touch_points: None,
            }
        }

        pub fn with_max_touch_points(mut self, max_touch_points: impl Into<i64>) -> Self {
            self.max_touch_points = Some(max_touch_points.into());
            self
        }
    }

    impl Command for SetTouchEmulationEnabled {
        type Response = ();
        const METHOD: &'static str = "Emulation.setTouchEmulationEnabled";
    }

    /// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy. Note this supersedes any previous time budget.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetVirtualTimePolicy {
        policy: VirtualTimePolicy,
        /// If set, after this many virtual milliseconds have elapsed virtual time will be paused and a virtualTimeBudgetExpired event is sent.
        #[serde(skip_serializing_if = "Option::is_none")]
        budget: Option<f64>,
        /// If set this specifies the maximum number of tasks that can be run before virtual is forced forwards to prevent deadlock.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxVirtualTimeTaskStarvationCount")]
        max_virtual_time_task_starvation_count: Option<i64>,
        /// If set, base::Time::Now will be overridden to initially return this value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "initialVirtualTime")]
        initial_virtual_time: Option<network::TimeSinceEpoch>,
    }

    impl SetVirtualTimePolicy {
        pub fn new(policy: impl Into<VirtualTimePolicy>) -> Self {
            Self {
                policy: policy.into(),
                budget: None,
                max_virtual_time_task_starvation_count: None,
                initial_virtual_time: None,
            }
        }

        pub fn with_budget(mut self, budget: impl Into<f64>) -> Self {
            self.budget = Some(budget.into());
            self
        }

        pub fn with_max_virtual_time_task_starvation_count(
            mut self,
            max_virtual_time_task_starvation_count: impl Into<i64>,
        ) -> Self {
            self.max_virtual_time_task_starvation_count =
                Some(max_virtual_time_task_starvation_count.into());
            self
        }

        pub fn with_initial_virtual_time(
            mut self,
            initial_virtual_time: impl Into<network::TimeSinceEpoch>,
        ) -> Self {
            self.initial_virtual_time = Some(initial_virtual_time.into());
            self
        }
    }

    impl Command for SetVirtualTimePolicy {
        type Response = SetVirtualTimePolicyResult;
        const METHOD: &'static str = "Emulation.setVirtualTimePolicy";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetVirtualTimePolicyResult {
        /// Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
        #[serde(rename = "virtualTimeTicksBase")]
        pub virtual_time_ticks_base: f64,
    }

    /// Overrides default host system locale with the specified one.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetLocaleOverride {
        /// ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and restores default host system locale.
        #[serde(skip_serializing_if = "Option::is_none")]
        locale: Option<String>,
    }

    impl SetLocaleOverride {
        pub fn new() -> Self {
            Self { locale: None }
        }

        pub fn with_locale(mut self, locale: impl Into<String>) -> Self {
            self.locale = Some(locale.into());
            self
        }
    }

    impl Command for SetLocaleOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setLocaleOverride";
    }

    /// Overrides default host system timezone with the specified one.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetTimezoneOverride {
        /// The timezone identifier. List of supported timezones: https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt If empty, disables the override and restores default host system timezone.
        #[serde(rename = "timezoneId")]
        timezone_id: String,
    }

    impl SetTimezoneOverride {
        pub fn new(timezone_id: impl Into<String>) -> Self {
            Self {
                timezone_id: timezone_id.into(),
            }
        }
    }

    impl Command for SetTimezoneOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setTimezoneOverride";
    }

    /// Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetVisibleSize {
        /// Frame width (DIP).
        width: i64,
        /// Frame height (DIP).
        height: i64,
    }

    impl SetVisibleSize {
        pub fn new(width: impl Into<i64>, height: impl Into<i64>) -> Self {
            Self {
                width: width.into(),
                height: height.into(),
            }
        }
    }

    impl Command for SetVisibleSize {
        type Response = ();
        const METHOD: &'static str = "Emulation.setVisibleSize";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDisabledImageTypes {
        /// Image types to disable.
        #[serde(rename = "imageTypes")]
        image_types: Vec<DisabledImageType>,
    }

    impl SetDisabledImageTypes {
        pub fn new(image_types: impl Into<Vec<DisabledImageType>>) -> Self {
            Self {
                image_types: image_types.into(),
            }
        }
    }

    impl Command for SetDisabledImageTypes {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDisabledImageTypes";
    }

    /// Override the value of navigator.connection.saveData
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDataSaverOverride {
        /// Override value. Omitting the parameter disables the override.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dataSaverEnabled")]
        data_saver_enabled: Option<bool>,
    }

    impl SetDataSaverOverride {
        pub fn new() -> Self {
            Self {
                data_saver_enabled: None,
            }
        }

        pub fn with_data_saver_enabled(mut self, data_saver_enabled: impl Into<bool>) -> Self {
            self.data_saver_enabled = Some(data_saver_enabled.into());
            self
        }
    }

    impl Command for SetDataSaverOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setDataSaverOverride";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetHardwareConcurrencyOverride {
        /// Hardware concurrency to report
        #[serde(rename = "hardwareConcurrency")]
        hardware_concurrency: i64,
    }

    impl SetHardwareConcurrencyOverride {
        pub fn new(hardware_concurrency: impl Into<i64>) -> Self {
            Self {
                hardware_concurrency: hardware_concurrency.into(),
            }
        }
    }

    impl Command for SetHardwareConcurrencyOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setHardwareConcurrencyOverride";
    }

    /// Allows overriding user agent with the given string. `userAgentMetadata` must be set for Client Hint headers to be sent.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetUserAgentOverride {
        /// User agent to use.
        #[serde(rename = "userAgent")]
        user_agent: String,
        /// Browser language to emulate.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "acceptLanguage")]
        accept_language: Option<String>,
        /// The platform navigator.platform should return.
        #[serde(skip_serializing_if = "Option::is_none")]
        platform: Option<String>,
        /// To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userAgentMetadata")]
        user_agent_metadata: Option<UserAgentMetadata>,
    }

    impl SetUserAgentOverride {
        pub fn new(user_agent: impl Into<String>) -> Self {
            Self {
                user_agent: user_agent.into(),
                accept_language: None,
                platform: None,
                user_agent_metadata: None,
            }
        }

        pub fn with_accept_language(mut self, accept_language: impl Into<String>) -> Self {
            self.accept_language = Some(accept_language.into());
            self
        }

        pub fn with_platform(mut self, platform: impl Into<String>) -> Self {
            self.platform = Some(platform.into());
            self
        }

        pub fn with_user_agent_metadata(
            mut self,
            user_agent_metadata: impl Into<UserAgentMetadata>,
        ) -> Self {
            self.user_agent_metadata = Some(user_agent_metadata.into());
            self
        }
    }

    impl Command for SetUserAgentOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setUserAgentOverride";
    }

    /// Allows overriding the automation flag.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAutomationOverride {
        /// Whether the override should be enabled.
        enabled: bool,
    }

    impl SetAutomationOverride {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetAutomationOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setAutomationOverride";
    }

    /// Allows overriding the difference between the small and large viewport sizes, which determine the value of the `svh` and `lvh` unit, respectively. Only supported for top-level frames.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSmallViewportHeightDifferenceOverride {
        /// This will cause an element of size 100svh to be `difference` pixels smaller than an element of size 100lvh.
        difference: i64,
    }

    impl SetSmallViewportHeightDifferenceOverride {
        pub fn new(difference: impl Into<i64>) -> Self {
            Self {
                difference: difference.into(),
            }
        }
    }

    impl Command for SetSmallViewportHeightDifferenceOverride {
        type Response = ();
        const METHOD: &'static str = "Emulation.setSmallViewportHeightDifferenceOverride";
    }

    /// Returns device's screen configuration.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetScreenInfos {}

    impl GetScreenInfos {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetScreenInfos {
        type Response = GetScreenInfosResult;
        const METHOD: &'static str = "Emulation.getScreenInfos";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetScreenInfosResult {
        #[serde(rename = "screenInfos")]
        pub screen_infos: Vec<ScreenInfo>,
    }

    /// Add a new screen to the device. Only supported in headless mode.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScreen {
        /// Offset of the left edge of the screen in pixels.
        left: i64,
        /// Offset of the top edge of the screen in pixels.
        top: i64,
        /// The width of the screen in pixels.
        width: i64,
        /// The height of the screen in pixels.
        height: i64,
        /// Specifies the screen's work area. Default is entire screen.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workAreaInsets")]
        work_area_insets: Option<WorkAreaInsets>,
        /// Specifies the screen's device pixel ratio. Default is 1.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "devicePixelRatio")]
        device_pixel_ratio: Option<f64>,
        /// Specifies the screen's rotation angle. Available values are 0, 90, 180 and 270. Default is 0.
        #[serde(skip_serializing_if = "Option::is_none")]
        rotation: Option<i64>,
        /// Specifies the screen's color depth in bits. Default is 24.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "colorDepth")]
        color_depth: Option<i64>,
        /// Specifies the descriptive label for the screen. Default is none.
        #[serde(skip_serializing_if = "Option::is_none")]
        label: Option<String>,
        /// Indicates whether the screen is internal to the device or external, attached to the device. Default is false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isInternal")]
        is_internal: Option<bool>,
    }

    impl AddScreen {
        pub fn new(
            left: impl Into<i64>,
            top: impl Into<i64>,
            width: impl Into<i64>,
            height: impl Into<i64>,
        ) -> Self {
            Self {
                left: left.into(),
                top: top.into(),
                width: width.into(),
                height: height.into(),
                work_area_insets: None,
                device_pixel_ratio: None,
                rotation: None,
                color_depth: None,
                label: None,
                is_internal: None,
            }
        }

        pub fn with_work_area_insets(
            mut self,
            work_area_insets: impl Into<WorkAreaInsets>,
        ) -> Self {
            self.work_area_insets = Some(work_area_insets.into());
            self
        }

        pub fn with_device_pixel_ratio(mut self, device_pixel_ratio: impl Into<f64>) -> Self {
            self.device_pixel_ratio = Some(device_pixel_ratio.into());
            self
        }

        pub fn with_rotation(mut self, rotation: impl Into<i64>) -> Self {
            self.rotation = Some(rotation.into());
            self
        }

        pub fn with_color_depth(mut self, color_depth: impl Into<i64>) -> Self {
            self.color_depth = Some(color_depth.into());
            self
        }

        pub fn with_label(mut self, label: impl Into<String>) -> Self {
            self.label = Some(label.into());
            self
        }

        pub fn with_is_internal(mut self, is_internal: impl Into<bool>) -> Self {
            self.is_internal = Some(is_internal.into());
            self
        }
    }

    impl Command for AddScreen {
        type Response = AddScreenResult;
        const METHOD: &'static str = "Emulation.addScreen";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScreenResult {
        #[serde(rename = "screenInfo")]
        pub screen_info: ScreenInfo,
    }

    /// Remove screen from the device. Only supported in headless mode.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveScreen {
        #[serde(rename = "screenId")]
        screen_id: ScreenId,
    }

    impl RemoveScreen {
        pub fn new(screen_id: impl Into<ScreenId>) -> Self {
            Self {
                screen_id: screen_id.into(),
            }
        }
    }

    impl Command for RemoveScreen {
        type Response = ();
        const METHOD: &'static str = "Emulation.removeScreen";
    }

    /// Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VirtualTimeBudgetExpired {}

    impl VirtualTimeBudgetExpired {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Emulation.virtualTimeBudgetExpired")
        }
    }
}

pub mod event_breakpoints {
    use super::*;

    /// Sets breakpoint on particular native event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInstrumentationBreakpoint {
        /// Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        event_name: String,
    }

    impl SetInstrumentationBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
            }
        }
    }

    impl Command for SetInstrumentationBreakpoint {
        type Response = ();
        const METHOD: &'static str = "EventBreakpoints.setInstrumentationBreakpoint";
    }

    /// Removes breakpoint on particular native event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveInstrumentationBreakpoint {
        /// Instrumentation name to stop on.
        #[serde(rename = "eventName")]
        event_name: String,
    }

    impl RemoveInstrumentationBreakpoint {
        pub fn new(event_name: impl Into<String>) -> Self {
            Self {
                event_name: event_name.into(),
            }
        }
    }

    impl Command for RemoveInstrumentationBreakpoint {
        type Response = ();
        const METHOD: &'static str = "EventBreakpoints.removeInstrumentationBreakpoint";
    }

    /// Removes all breakpoints
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "EventBreakpoints.disable";
    }
}

pub mod extensions {
    use super::*;

    /// Storage areas.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StorageArea {
        #[serde(rename = "session")]
        Session,
        #[serde(rename = "local")]
        Local,
        #[serde(rename = "sync")]
        Sync,
        #[serde(rename = "managed")]
        Managed,
    }
    impl From<&str> for StorageArea {
        fn from(s: &str) -> Self {
            match s {
                "session" => Self::Session,
                "local" => Self::Local,
                "sync" => Self::Sync,
                "managed" => Self::Managed,
                _ => Self::Session,
            }
        }
    }
    impl From<String> for StorageArea {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Runs an extension default action. Available if the client is connected using the --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging flag is set.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TriggerAction {
        /// Extension id.
        id: String,
        /// A tab target ID to trigger the default extension action on.
        #[serde(rename = "targetId")]
        target_id: String,
    }

    impl TriggerAction {
        pub fn new(id: impl Into<String>, target_id: impl Into<String>) -> Self {
            Self {
                id: id.into(),
                target_id: target_id.into(),
            }
        }
    }

    impl Command for TriggerAction {
        type Response = ();
        const METHOD: &'static str = "Extensions.triggerAction";
    }

    /// Installs an unpacked extension from the filesystem similar to --load-extension CLI flags. Returns extension ID once the extension has been installed. Available if the client is connected using the --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging flag is set.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadUnpacked {
        /// Absolute file path.
        path: String,
        /// Enable the extension in incognito
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableInIncognito")]
        enable_in_incognito: Option<bool>,
    }

    impl LoadUnpacked {
        pub fn new(path: impl Into<String>) -> Self {
            Self {
                path: path.into(),
                enable_in_incognito: None,
            }
        }

        pub fn with_enable_in_incognito(mut self, enable_in_incognito: impl Into<bool>) -> Self {
            self.enable_in_incognito = Some(enable_in_incognito.into());
            self
        }
    }

    impl Command for LoadUnpacked {
        type Response = LoadUnpackedResult;
        const METHOD: &'static str = "Extensions.loadUnpacked";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadUnpackedResult {
        /// Extension id.
        pub id: String,
    }

    /// Uninstalls an unpacked extension (others not supported) from the profile. Available if the client is connected using the --remote-debugging-pipe flag and the --enable-unsafe-extension-debugging.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Uninstall {
        /// Extension id.
        id: String,
    }

    impl Uninstall {
        pub fn new(id: impl Into<String>) -> Self {
            Self { id: id.into() }
        }
    }

    impl Command for Uninstall {
        type Response = ();
        const METHOD: &'static str = "Extensions.uninstall";
    }

    /// Gets data from extension storage in the given `storageArea`. If `keys` is specified, these are used to filter the result.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageItems {
        /// ID of extension.
        id: String,
        /// StorageArea to retrieve data from.
        #[serde(rename = "storageArea")]
        storage_area: StorageArea,
        /// Keys to retrieve.
        #[serde(skip_serializing_if = "Option::is_none")]
        keys: Option<Vec<String>>,
    }

    impl GetStorageItems {
        pub fn new(id: impl Into<String>, storage_area: impl Into<StorageArea>) -> Self {
            Self {
                id: id.into(),
                storage_area: storage_area.into(),
                keys: None,
            }
        }

        pub fn with_keys(mut self, keys: impl Into<Vec<String>>) -> Self {
            self.keys = Some(keys.into());
            self
        }
    }

    impl Command for GetStorageItems {
        type Response = GetStorageItemsResult;
        const METHOD: &'static str = "Extensions.getStorageItems";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageItemsResult {
        pub data: serde_json::Value,
    }

    /// Removes `keys` from extension storage in the given `storageArea`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveStorageItems {
        /// ID of extension.
        id: String,
        /// StorageArea to remove data from.
        #[serde(rename = "storageArea")]
        storage_area: StorageArea,
        /// Keys to remove.
        keys: Vec<String>,
    }

    impl RemoveStorageItems {
        pub fn new(
            id: impl Into<String>,
            storage_area: impl Into<StorageArea>,
            keys: impl Into<Vec<String>>,
        ) -> Self {
            Self {
                id: id.into(),
                storage_area: storage_area.into(),
                keys: keys.into(),
            }
        }
    }

    impl Command for RemoveStorageItems {
        type Response = ();
        const METHOD: &'static str = "Extensions.removeStorageItems";
    }

    /// Clears extension storage in the given `storageArea`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearStorageItems {
        /// ID of extension.
        id: String,
        /// StorageArea to remove data from.
        #[serde(rename = "storageArea")]
        storage_area: StorageArea,
    }

    impl ClearStorageItems {
        pub fn new(id: impl Into<String>, storage_area: impl Into<StorageArea>) -> Self {
            Self {
                id: id.into(),
                storage_area: storage_area.into(),
            }
        }
    }

    impl Command for ClearStorageItems {
        type Response = ();
        const METHOD: &'static str = "Extensions.clearStorageItems";
    }

    /// Sets `values` in extension storage in the given `storageArea`. The provided `values` will be merged with existing values in the storage area.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStorageItems {
        /// ID of extension.
        id: String,
        /// StorageArea to set data in.
        #[serde(rename = "storageArea")]
        storage_area: StorageArea,
        /// Values to set.
        values: serde_json::Value,
    }

    impl SetStorageItems {
        pub fn new(
            id: impl Into<String>,
            storage_area: impl Into<StorageArea>,
            values: impl Into<serde_json::Value>,
        ) -> Self {
            Self {
                id: id.into(),
                storage_area: storage_area.into(),
                values: values.into(),
            }
        }
    }

    impl Command for SetStorageItems {
        type Response = ();
        const METHOD: &'static str = "Extensions.setStorageItems";
    }
}

pub mod fed_cm {
    use super::*;

    /// Whether this is a sign-up or sign-in action for this account, i.e. whether this account has ever been used to sign in to this RP before.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LoginState {
        #[serde(rename = "SignIn")]
        SignIn,
        #[serde(rename = "SignUp")]
        SignUp,
    }
    impl From<&str> for LoginState {
        fn from(s: &str) -> Self {
            match s {
                "SignIn" => Self::SignIn,
                "SignUp" => Self::SignUp,
                _ => Self::SignIn,
            }
        }
    }
    impl From<String> for LoginState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The types of FedCM dialogs.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DialogType {
        #[serde(rename = "AccountChooser")]
        AccountChooser,
        #[serde(rename = "AutoReauthn")]
        AutoReauthn,
        #[serde(rename = "ConfirmIdpLogin")]
        ConfirmIdpLogin,
        #[serde(rename = "Error")]
        Error,
    }
    impl From<&str> for DialogType {
        fn from(s: &str) -> Self {
            match s {
                "AccountChooser" => Self::AccountChooser,
                "AutoReauthn" => Self::AutoReauthn,
                "ConfirmIdpLogin" => Self::ConfirmIdpLogin,
                "Error" => Self::Error,
                _ => Self::AccountChooser,
            }
        }
    }
    impl From<String> for DialogType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The buttons on the FedCM dialog.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DialogButton {
        #[serde(rename = "ConfirmIdpLoginContinue")]
        ConfirmIdpLoginContinue,
        #[serde(rename = "ErrorGotIt")]
        ErrorGotIt,
        #[serde(rename = "ErrorMoreDetails")]
        ErrorMoreDetails,
    }
    impl From<&str> for DialogButton {
        fn from(s: &str) -> Self {
            match s {
                "ConfirmIdpLoginContinue" => Self::ConfirmIdpLoginContinue,
                "ErrorGotIt" => Self::ErrorGotIt,
                "ErrorMoreDetails" => Self::ErrorMoreDetails,
                _ => Self::ConfirmIdpLoginContinue,
            }
        }
    }
    impl From<String> for DialogButton {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The URLs that each account has
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AccountUrlType {
        #[serde(rename = "TermsOfService")]
        TermsOfService,
        #[serde(rename = "PrivacyPolicy")]
        PrivacyPolicy,
    }
    impl From<&str> for AccountUrlType {
        fn from(s: &str) -> Self {
            match s {
                "TermsOfService" => Self::TermsOfService,
                "PrivacyPolicy" => Self::PrivacyPolicy,
                _ => Self::TermsOfService,
            }
        }
    }
    impl From<String> for AccountUrlType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Corresponds to IdentityRequestAccount
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Account {
        #[serde(rename = "accountId")]
        pub account_id: String,
        pub email: String,
        pub name: String,
        #[serde(rename = "givenName")]
        pub given_name: String,
        #[serde(rename = "pictureUrl")]
        pub picture_url: String,
        #[serde(rename = "idpConfigUrl")]
        pub idp_config_url: String,
        #[serde(rename = "idpLoginUrl")]
        pub idp_login_url: String,
        #[serde(rename = "loginState")]
        pub login_state: LoginState,
        /// These two are only set if the loginState is signUp
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "termsOfServiceUrl")]
        pub terms_of_service_url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "privacyPolicyUrl")]
        pub privacy_policy_url: Option<String>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// Allows callers to disable the promise rejection delay that would normally happen, if this is unimportant to what's being tested. (step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "disableRejectionDelay")]
        disable_rejection_delay: Option<bool>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                disable_rejection_delay: None,
            }
        }

        pub fn with_disable_rejection_delay(
            mut self,
            disable_rejection_delay: impl Into<bool>,
        ) -> Self {
            self.disable_rejection_delay = Some(disable_rejection_delay.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "FedCm.enable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "FedCm.disable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SelectAccount {
        #[serde(rename = "dialogId")]
        dialog_id: String,
        #[serde(rename = "accountIndex")]
        account_index: i64,
    }

    impl SelectAccount {
        pub fn new(dialog_id: impl Into<String>, account_index: impl Into<i64>) -> Self {
            Self {
                dialog_id: dialog_id.into(),
                account_index: account_index.into(),
            }
        }
    }

    impl Command for SelectAccount {
        type Response = ();
        const METHOD: &'static str = "FedCm.selectAccount";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClickDialogButton {
        #[serde(rename = "dialogId")]
        dialog_id: String,
        #[serde(rename = "dialogButton")]
        dialog_button: DialogButton,
    }

    impl ClickDialogButton {
        pub fn new(dialog_id: impl Into<String>, dialog_button: impl Into<DialogButton>) -> Self {
            Self {
                dialog_id: dialog_id.into(),
                dialog_button: dialog_button.into(),
            }
        }
    }

    impl Command for ClickDialogButton {
        type Response = ();
        const METHOD: &'static str = "FedCm.clickDialogButton";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OpenUrl {
        #[serde(rename = "dialogId")]
        dialog_id: String,
        #[serde(rename = "accountIndex")]
        account_index: i64,
        #[serde(rename = "accountUrlType")]
        account_url_type: AccountUrlType,
    }

    impl OpenUrl {
        pub fn new(
            dialog_id: impl Into<String>,
            account_index: impl Into<i64>,
            account_url_type: impl Into<AccountUrlType>,
        ) -> Self {
            Self {
                dialog_id: dialog_id.into(),
                account_index: account_index.into(),
                account_url_type: account_url_type.into(),
            }
        }
    }

    impl Command for OpenUrl {
        type Response = ();
        const METHOD: &'static str = "FedCm.openUrl";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DismissDialog {
        #[serde(rename = "dialogId")]
        dialog_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "triggerCooldown")]
        trigger_cooldown: Option<bool>,
    }

    impl DismissDialog {
        pub fn new(dialog_id: impl Into<String>) -> Self {
            Self {
                dialog_id: dialog_id.into(),
                trigger_cooldown: None,
            }
        }

        pub fn with_trigger_cooldown(mut self, trigger_cooldown: impl Into<bool>) -> Self {
            self.trigger_cooldown = Some(trigger_cooldown.into());
            self
        }
    }

    impl Command for DismissDialog {
        type Response = ();
        const METHOD: &'static str = "FedCm.dismissDialog";
    }

    /// Resets the cooldown time, if any, to allow the next FedCM call to show a dialog even if one was recently dismissed by the user.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetCooldown {}

    impl ResetCooldown {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ResetCooldown {
        type Response = ();
        const METHOD: &'static str = "FedCm.resetCooldown";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DialogShown {
        #[serde(rename = "dialogId")]
        pub dialog_id: String,
        #[serde(rename = "dialogType")]
        pub dialog_type: DialogType,
        pub accounts: Vec<Account>,
        /// These exist primarily so that the caller can verify the RP context was used appropriately.
        pub title: String,
        pub subtitle: Option<String>,
    }

    impl DialogShown {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("FedCm.dialogShown")
        }
    }

    /// Triggered when a dialog is closed, either by user action, JS abort, or a command below.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DialogClosed {
        #[serde(rename = "dialogId")]
        pub dialog_id: String,
    }

    impl DialogClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("FedCm.dialogClosed")
        }
    }
}

pub mod fetch {
    use super::*;

    /// Unique request identifier. Note that this does not identify individual HTTP requests that are part of a network request.
    pub type RequestId = String;

    /// Stages of the request to handle. Request will intercept before the request is sent. Response will intercept after the response is received (but before response body is received).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum RequestStage {
        #[serde(rename = "Request")]
        Request,
        #[serde(rename = "Response")]
        Response,
    }
    impl From<&str> for RequestStage {
        fn from(s: &str) -> Self {
            match s {
                "Request" => Self::Request,
                "Response" => Self::Response,
                _ => Self::Request,
            }
        }
    }
    impl From<String> for RequestStage {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestPattern {
        /// Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is backslash. Omitting is equivalent to `"*"`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlPattern")]
        pub url_pattern: Option<String>,
        /// If set, only requests for matching resource types will be intercepted.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resourceType")]
        pub resource_type: Option<network::ResourceType>,
        /// Stage at which to begin intercepting requests. Default is Request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestStage")]
        pub request_stage: Option<RequestStage>,
    }

    /// Response HTTP header entry
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HeaderEntry {
        pub name: String,
        pub value: String,
    }

    /// Authorization challenge for HTTP status code 401 or 407.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AuthChallenge {
        /// Source of the authentication challenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub source: Option<String>,
        /// Origin of the challenger.
        pub origin: String,
        /// The authentication scheme used, such as basic or digest
        pub scheme: String,
        /// The realm of the challenge. May be empty.
        pub realm: String,
    }

    /// Response to an AuthChallenge.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AuthChallengeResponse {
        /// The decision on what to do in response to the authorization challenge. Default means deferring to the default behavior of the net stack, which will likely either the Cancel authentication or display a popup dialog box.
        pub response: String,
        /// The username to provide, possibly empty. Should only be set if response is ProvideCredentials.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub username: Option<String>,
        /// The password to provide, possibly empty. Should only be set if response is ProvideCredentials.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub password: Option<String>,
    }

    /// Disables the fetch domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Fetch.disable";
    }

    /// Enables issuing of requestPaused events. A request will be paused until client calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
        #[serde(skip_serializing_if = "Option::is_none")]
        patterns: Option<Vec<RequestPattern>>,
        /// If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "handleAuthRequests")]
        handle_auth_requests: Option<bool>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                patterns: None,
                handle_auth_requests: None,
            }
        }

        pub fn with_patterns(mut self, patterns: impl Into<Vec<RequestPattern>>) -> Self {
            self.patterns = Some(patterns.into());
            self
        }

        pub fn with_handle_auth_requests(mut self, handle_auth_requests: impl Into<bool>) -> Self {
            self.handle_auth_requests = Some(handle_auth_requests.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Fetch.enable";
    }

    /// Causes the request to fail with specified reason.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FailRequest {
        /// An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// Causes the request to fail with the given reason.
        #[serde(rename = "errorReason")]
        error_reason: network::ErrorReason,
    }

    impl FailRequest {
        pub fn new(
            request_id: impl Into<RequestId>,
            error_reason: impl Into<network::ErrorReason>,
        ) -> Self {
            Self {
                request_id: request_id.into(),
                error_reason: error_reason.into(),
            }
        }
    }

    impl Command for FailRequest {
        type Response = ();
        const METHOD: &'static str = "Fetch.failRequest";
    }

    /// Provides response to the request.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FulfillRequest {
        /// An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// An HTTP response code.
        #[serde(rename = "responseCode")]
        response_code: i64,
        /// Response headers.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responseHeaders")]
        response_headers: Option<Vec<HeaderEntry>>,
        /// Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "binaryResponseHeaders")]
        binary_response_headers: Option<String>,
        /// A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        body: Option<String>,
        /// A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responsePhrase")]
        response_phrase: Option<String>,
    }

    impl FulfillRequest {
        pub fn new(request_id: impl Into<RequestId>, response_code: impl Into<i64>) -> Self {
            Self {
                request_id: request_id.into(),
                response_code: response_code.into(),
                response_headers: None,
                binary_response_headers: None,
                body: None,
                response_phrase: None,
            }
        }

        pub fn with_response_headers(
            mut self,
            response_headers: impl Into<Vec<HeaderEntry>>,
        ) -> Self {
            self.response_headers = Some(response_headers.into());
            self
        }

        pub fn with_binary_response_headers(
            mut self,
            binary_response_headers: impl Into<String>,
        ) -> Self {
            self.binary_response_headers = Some(binary_response_headers.into());
            self
        }

        pub fn with_body(mut self, body: impl Into<String>) -> Self {
            self.body = Some(body.into());
            self
        }

        pub fn with_response_phrase(mut self, response_phrase: impl Into<String>) -> Self {
            self.response_phrase = Some(response_phrase.into());
            self
        }
    }

    impl Command for FulfillRequest {
        type Response = ();
        const METHOD: &'static str = "Fetch.fulfillRequest";
    }

    /// Continues the request, optionally modifying some of its parameters.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContinueRequest {
        /// An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// If set, the request url will be modified in a way that's not observable by page.
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
        /// If set, the request method is overridden.
        #[serde(skip_serializing_if = "Option::is_none")]
        method: Option<String>,
        /// If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "postData")]
        post_data: Option<String>,
        /// If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
        #[serde(skip_serializing_if = "Option::is_none")]
        headers: Option<Vec<HeaderEntry>>,
        /// If set, overrides response interception behavior for this request.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "interceptResponse")]
        intercept_response: Option<bool>,
    }

    impl ContinueRequest {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
                url: None,
                method: None,
                post_data: None,
                headers: None,
                intercept_response: None,
            }
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }

        pub fn with_method(mut self, method: impl Into<String>) -> Self {
            self.method = Some(method.into());
            self
        }

        pub fn with_post_data(mut self, post_data: impl Into<String>) -> Self {
            self.post_data = Some(post_data.into());
            self
        }

        pub fn with_headers(mut self, headers: impl Into<Vec<HeaderEntry>>) -> Self {
            self.headers = Some(headers.into());
            self
        }

        pub fn with_intercept_response(mut self, intercept_response: impl Into<bool>) -> Self {
            self.intercept_response = Some(intercept_response.into());
            self
        }
    }

    impl Command for ContinueRequest {
        type Response = ();
        const METHOD: &'static str = "Fetch.continueRequest";
    }

    /// Continues a request supplying authChallengeResponse following authRequired event.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContinueWithAuth {
        /// An id the client received in authRequired event.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// Response to with an authChallenge.
        #[serde(rename = "authChallengeResponse")]
        auth_challenge_response: AuthChallengeResponse,
    }

    impl ContinueWithAuth {
        pub fn new(
            request_id: impl Into<RequestId>,
            auth_challenge_response: impl Into<AuthChallengeResponse>,
        ) -> Self {
            Self {
                request_id: request_id.into(),
                auth_challenge_response: auth_challenge_response.into(),
            }
        }
    }

    impl Command for ContinueWithAuth {
        type Response = ();
        const METHOD: &'static str = "Fetch.continueWithAuth";
    }

    /// Continues loading of the paused response, optionally modifying the response headers. If either responseCode or headers are modified, all of them must be present.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContinueResponse {
        /// An id the client received in requestPaused event.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// An HTTP response code. If absent, original response code will be used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responseCode")]
        response_code: Option<i64>,
        /// A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responsePhrase")]
        response_phrase: Option<String>,
        /// Response headers. If absent, original response headers will be used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responseHeaders")]
        response_headers: Option<Vec<HeaderEntry>>,
        /// Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "binaryResponseHeaders")]
        binary_response_headers: Option<String>,
    }

    impl ContinueResponse {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
                response_code: None,
                response_phrase: None,
                response_headers: None,
                binary_response_headers: None,
            }
        }

        pub fn with_response_code(mut self, response_code: impl Into<i64>) -> Self {
            self.response_code = Some(response_code.into());
            self
        }

        pub fn with_response_phrase(mut self, response_phrase: impl Into<String>) -> Self {
            self.response_phrase = Some(response_phrase.into());
            self
        }

        pub fn with_response_headers(
            mut self,
            response_headers: impl Into<Vec<HeaderEntry>>,
        ) -> Self {
            self.response_headers = Some(response_headers.into());
            self
        }

        pub fn with_binary_response_headers(
            mut self,
            binary_response_headers: impl Into<String>,
        ) -> Self {
            self.binary_response_headers = Some(binary_response_headers.into());
            self
        }
    }

    impl Command for ContinueResponse {
        type Response = ();
        const METHOD: &'static str = "Fetch.continueResponse";
    }

    /// Causes the body of the response to be received from the server and returned as a single string. May only be issued for a request that is paused in the Response stage and is mutually exclusive with takeResponseBodyForInterceptionAsStream. Calling other methods that affect the request or disabling fetch domain before body is received results in an undefined behavior. Note that the response body is not available for redirects. Requests paused in the _redirect received_ state may be differentiated by `responseCode` and presence of `location` response header, see comments to `requestPaused` for details.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBody {
        /// Identifier for the intercepted request to get body for.
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl GetResponseBody {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for GetResponseBody {
        type Response = GetResponseBodyResult;
        const METHOD: &'static str = "Fetch.getResponseBody";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBodyResult {
        /// Response body.
        pub body: String,
        /// True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: bool,
    }

    /// Returns a handle to the stream representing the response body. The request must be paused in the HeadersReceived stage. Note that after this command the request can't be continued as is -- client either needs to cancel it or to provide the response body. The stream only supports sequential read, IO.read will fail if the position is specified. This method is mutually exclusive with getResponseBody. Calling other methods that affect the request or disabling fetch domain before body is received results in an undefined behavior.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeResponseBodyAsStream {
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl TakeResponseBodyAsStream {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for TakeResponseBodyAsStream {
        type Response = TakeResponseBodyAsStreamResult;
        const METHOD: &'static str = "Fetch.takeResponseBodyAsStream";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeResponseBodyAsStreamResult {
        pub stream: io::StreamHandle,
    }

    /// Issued when the domain is enabled and the request URL matches the specified filter. The request is paused until the client responds with one of continueRequest, failRequest or fulfillRequest. The stage of the request can be determined by presence of responseErrorReason and responseStatusCode -- the request is at the response stage if either of these fields is present and in the request stage otherwise. Redirect responses and subsequent requests are reported similarly to regular responses and requests. Redirect responses may be distinguished by the value of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with presence of the `location` header. Requests resulting from a redirect will have `redirectedRequestId` field set.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestPaused {
        /// Each request the page makes will have a unique id.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// The details of the request.
        pub request: network::Request,
        /// The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: network::ResourceType,
        /// Response error if intercepted at response stage.
        #[serde(rename = "responseErrorReason")]
        pub response_error_reason: Option<network::ErrorReason>,
        /// Response code if intercepted at response stage.
        #[serde(rename = "responseStatusCode")]
        pub response_status_code: Option<i64>,
        /// Response status text if intercepted at response stage.
        #[serde(rename = "responseStatusText")]
        pub response_status_text: Option<String>,
        /// Response headers if intercepted at the response stage.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Vec<HeaderEntry>>,
        /// If the intercepted request had a corresponding Network.requestWillBeSent event fired for it, then this networkId will be the same as the requestId present in the requestWillBeSent event.
        #[serde(rename = "networkId")]
        pub network_id: Option<network::RequestId>,
        /// If the request is due to a redirect response from the server, the id of the request that has caused the redirect.
        /// **EXPERIMENTAL**
        #[serde(rename = "redirectedRequestId")]
        pub redirected_request_id: Option<RequestId>,
    }

    impl RequestPaused {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Fetch.requestPaused")
        }
    }

    /// Issued when the domain is enabled with handleAuthRequests set to true. The request is paused until client responds with continueWithAuth.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AuthRequired {
        /// Each request the page makes will have a unique id.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// The details of the request.
        pub request: network::Request,
        /// The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: network::ResourceType,
        /// Details of the Authorization Challenge encountered. If this is set, client should respond with continueRequest that contains AuthChallengeResponse.
        #[serde(rename = "authChallenge")]
        pub auth_challenge: AuthChallenge,
    }

    impl AuthRequired {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Fetch.authRequired")
        }
    }
}

pub mod file_system {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct File {
        pub name: String,
        /// Timestamp
        #[serde(rename = "lastModified")]
        pub last_modified: network::TimeSinceEpoch,
        /// Size in bytes
        pub size: f64,
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Directory {
        pub name: String,
        #[serde(rename = "nestedDirectories")]
        pub nested_directories: Vec<String>,
        /// Files that are directly nested under this directory.
        #[serde(rename = "nestedFiles")]
        pub nested_files: Vec<File>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BucketFileSystemLocator {
        /// Storage key
        #[serde(rename = "storageKey")]
        pub storage_key: storage::SerializedStorageKey,
        /// Bucket name. Not passing a `bucketName` will retrieve the default Bucket. (https://developer.mozilla.org/en-US/docs/Web/API/Storage_API#storage_buckets)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bucketName")]
        pub bucket_name: Option<String>,
        /// Path to the directory using each path component as an array item.
        #[serde(rename = "pathComponents")]
        pub path_components: Vec<String>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDirectory {
        #[serde(rename = "bucketFileSystemLocator")]
        bucket_file_system_locator: BucketFileSystemLocator,
    }

    impl GetDirectory {
        pub fn new(bucket_file_system_locator: impl Into<BucketFileSystemLocator>) -> Self {
            Self {
                bucket_file_system_locator: bucket_file_system_locator.into(),
            }
        }
    }

    impl Command for GetDirectory {
        type Response = GetDirectoryResult;
        const METHOD: &'static str = "FileSystem.getDirectory";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDirectoryResult {
        /// Returns the directory object at the path.
        pub directory: Directory,
    }
}

pub mod headless_experimental {
    use super::*;

    /// Encoding options for a screenshot.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreenshotParams {
        /// Image compression format (defaults to png).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub format: Option<String>,
        /// Compression quality from range [0..100] (jpeg and webp only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub quality: Option<i64>,
        /// Optimize image encoding for speed, not for resulting size (defaults to false)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "optimizeForSpeed")]
        pub optimize_for_speed: Option<bool>,
    }

    /// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a screenshot from the resulting frame. Requires that the target was created with enabled BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also https://goo.gle/chrome-headless-rendering for more background.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BeginFrame {
        /// Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set, the current time will be used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameTimeTicks")]
        frame_time_ticks: Option<f64>,
        /// The interval between BeginFrames that is reported to the compositor, in milliseconds. Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
        #[serde(skip_serializing_if = "Option::is_none")]
        interval: Option<f64>,
        /// Whether updates should not be committed and drawn onto the display. False by default. If true, only side effects of the BeginFrame will be run, such as layout and animations, but any visual updates may not be visible on the display or in screenshots.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "noDisplayUpdates")]
        no_display_updates: Option<bool>,
        /// If set, a screenshot of the frame will be captured and returned in the response. Otherwise, no screenshot will be captured. Note that capturing a screenshot can fail, for example, during renderer initialization. In such a case, no screenshot data will be returned.
        #[serde(skip_serializing_if = "Option::is_none")]
        screenshot: Option<ScreenshotParams>,
    }

    impl BeginFrame {
        pub fn new() -> Self {
            Self {
                frame_time_ticks: None,
                interval: None,
                no_display_updates: None,
                screenshot: None,
            }
        }

        pub fn with_frame_time_ticks(mut self, frame_time_ticks: impl Into<f64>) -> Self {
            self.frame_time_ticks = Some(frame_time_ticks.into());
            self
        }

        pub fn with_interval(mut self, interval: impl Into<f64>) -> Self {
            self.interval = Some(interval.into());
            self
        }

        pub fn with_no_display_updates(mut self, no_display_updates: impl Into<bool>) -> Self {
            self.no_display_updates = Some(no_display_updates.into());
            self
        }

        pub fn with_screenshot(mut self, screenshot: impl Into<ScreenshotParams>) -> Self {
            self.screenshot = Some(screenshot.into());
            self
        }
    }

    impl Command for BeginFrame {
        type Response = BeginFrameResult;
        const METHOD: &'static str = "HeadlessExperimental.beginFrame";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BeginFrameResult {
        /// Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the display. Reported for diagnostic uses, may be removed in the future.
        #[serde(rename = "hasDamage")]
        pub has_damage: bool,
        /// Base64-encoded image data of the screenshot, if one was requested and successfully taken. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "screenshotData")]
        pub screenshot_data: Option<String>,
    }

    /// Disables headless events for the target.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "HeadlessExperimental.disable";
    }

    /// Enables headless events for the target.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "HeadlessExperimental.enable";
    }
}

pub mod io {
    use super::*;

    /// This is either obtained from another method or specified as `blob:<uuid>` where `<uuid>` is an UUID of a Blob.
    pub type StreamHandle = String;

    /// Close the stream, discard any temporary backing storage.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Close {
        /// Handle of the stream to close.
        handle: StreamHandle,
    }

    impl Close {
        pub fn new(handle: impl Into<StreamHandle>) -> Self {
            Self {
                handle: handle.into(),
            }
        }
    }

    impl Command for Close {
        type Response = ();
        const METHOD: &'static str = "IO.close";
    }

    /// Read a chunk of the stream
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Read {
        /// Handle of the stream to read.
        handle: StreamHandle,
        /// Seek to the specified offset before reading (if not specified, proceed with offset following the last read). Some types of streams may only support sequential reads.
        #[serde(skip_serializing_if = "Option::is_none")]
        offset: Option<i64>,
        /// Maximum number of bytes to read (left upon the agent discretion if not specified).
        #[serde(skip_serializing_if = "Option::is_none")]
        size: Option<i64>,
    }

    impl Read {
        pub fn new(handle: impl Into<StreamHandle>) -> Self {
            Self {
                handle: handle.into(),
                offset: None,
                size: None,
            }
        }

        pub fn with_offset(mut self, offset: impl Into<i64>) -> Self {
            self.offset = Some(offset.into());
            self
        }

        pub fn with_size(mut self, size: impl Into<i64>) -> Self {
            self.size = Some(size.into());
            self
        }
    }

    impl Command for Read {
        type Response = ReadResult;
        const METHOD: &'static str = "IO.read";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReadResult {
        /// Set if the data is base64-encoded
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: Option<bool>,
        /// Data that were read.
        pub data: String,
        /// Set if the end-of-file condition occurred while reading.
        pub eof: bool,
    }

    /// Return UUID of Blob object specified by a remote object id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveBlob {
        /// Object id of a Blob object wrapper.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
    }

    impl ResolveBlob {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
            }
        }
    }

    impl Command for ResolveBlob {
        type Response = ResolveBlobResult;
        const METHOD: &'static str = "IO.resolveBlob";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolveBlobResult {
        /// UUID of the specified Blob.
        pub uuid: String,
    }
}

pub mod indexed_db {
    use super::*;

    /// Database with an array of object stores.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DatabaseWithObjectStores {
        /// Database name.
        pub name: String,
        /// Database version (type is not 'integer', as the standard requires the version number to be 'unsigned long long')
        pub version: f64,
        /// Object stores in this database.
        #[serde(rename = "objectStores")]
        pub object_stores: Vec<ObjectStore>,
    }

    /// Object store.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ObjectStore {
        /// Object store name.
        pub name: String,
        /// Object store key path.
        #[serde(rename = "keyPath")]
        pub key_path: KeyPath,
        /// If true, object store has auto increment flag set.
        #[serde(rename = "autoIncrement")]
        pub auto_increment: bool,
        /// Indexes in this object store.
        pub indexes: Vec<ObjectStoreIndex>,
    }

    /// Object store index.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ObjectStoreIndex {
        /// Index name.
        pub name: String,
        /// Index key path.
        #[serde(rename = "keyPath")]
        pub key_path: KeyPath,
        /// If true, index is unique.
        pub unique: bool,
        /// If true, index allows multiple entries for a key.
        #[serde(rename = "multiEntry")]
        pub multi_entry: bool,
    }

    /// Key.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Key {
        /// Key type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Number value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub number: Option<f64>,
        /// String value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub string: Option<String>,
        /// Date value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub date: Option<f64>,
        /// Array value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub array: Option<Vec<Key>>,
    }

    /// Key range.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct KeyRange {
        /// Lower bound.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub lower: Option<Key>,
        /// Upper bound.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub upper: Option<Key>,
        /// If true lower bound is open.
        #[serde(rename = "lowerOpen")]
        pub lower_open: bool,
        /// If true upper bound is open.
        #[serde(rename = "upperOpen")]
        pub upper_open: bool,
    }

    /// Data entry.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DataEntry {
        /// Key object.
        pub key: runtime::RemoteObject,
        /// Primary key object.
        #[serde(rename = "primaryKey")]
        pub primary_key: runtime::RemoteObject,
        /// Value object.
        pub value: runtime::RemoteObject,
    }

    /// Key path.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct KeyPath {
        /// Key path type.
        #[serde(rename = "type")]
        pub type_: String,
        /// String value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub string: Option<String>,
        /// Array value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub array: Option<Vec<String>>,
    }

    /// Clears all entries from an object store.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearObjectStore {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        /// Database name.
        #[serde(rename = "databaseName")]
        database_name: String,
        /// Object store name.
        #[serde(rename = "objectStoreName")]
        object_store_name: String,
    }

    impl ClearObjectStore {
        pub fn new(database_name: impl Into<String>, object_store_name: impl Into<String>) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
                object_store_name: object_store_name.into(),
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for ClearObjectStore {
        type Response = ();
        const METHOD: &'static str = "IndexedDB.clearObjectStore";
    }

    /// Deletes a database.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteDatabase {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        /// Database name.
        #[serde(rename = "databaseName")]
        database_name: String,
    }

    impl DeleteDatabase {
        pub fn new(database_name: impl Into<String>) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for DeleteDatabase {
        type Response = ();
        const METHOD: &'static str = "IndexedDB.deleteDatabase";
    }

    /// Delete a range of entries from an object store
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteObjectStoreEntries {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        #[serde(rename = "databaseName")]
        database_name: String,
        #[serde(rename = "objectStoreName")]
        object_store_name: String,
        /// Range of entry keys to delete
        #[serde(rename = "keyRange")]
        key_range: KeyRange,
    }

    impl DeleteObjectStoreEntries {
        pub fn new(
            database_name: impl Into<String>,
            object_store_name: impl Into<String>,
            key_range: impl Into<KeyRange>,
        ) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
                object_store_name: object_store_name.into(),
                key_range: key_range.into(),
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for DeleteObjectStoreEntries {
        type Response = ();
        const METHOD: &'static str = "IndexedDB.deleteObjectStoreEntries";
    }

    /// Disables events from backend.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "IndexedDB.disable";
    }

    /// Enables events from backend.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "IndexedDB.enable";
    }

    /// Requests data from object store or index.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestData {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        /// Database name.
        #[serde(rename = "databaseName")]
        database_name: String,
        /// Object store name.
        #[serde(rename = "objectStoreName")]
        object_store_name: String,
        /// Index name. If not specified, it performs an object store data request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "indexName")]
        index_name: Option<String>,
        /// Number of records to skip.
        #[serde(rename = "skipCount")]
        skip_count: i64,
        /// Number of records to fetch.
        #[serde(rename = "pageSize")]
        page_size: i64,
        /// Key range.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keyRange")]
        key_range: Option<KeyRange>,
    }

    impl RequestData {
        pub fn new(
            database_name: impl Into<String>,
            object_store_name: impl Into<String>,
            skip_count: impl Into<i64>,
            page_size: impl Into<i64>,
        ) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
                object_store_name: object_store_name.into(),
                index_name: None,
                skip_count: skip_count.into(),
                page_size: page_size.into(),
                key_range: None,
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }

        pub fn with_index_name(mut self, index_name: impl Into<String>) -> Self {
            self.index_name = Some(index_name.into());
            self
        }

        pub fn with_key_range(mut self, key_range: impl Into<KeyRange>) -> Self {
            self.key_range = Some(key_range.into());
            self
        }
    }

    impl Command for RequestData {
        type Response = RequestDataResult;
        const METHOD: &'static str = "IndexedDB.requestData";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestDataResult {
        /// Array of object store data entries.
        #[serde(rename = "objectStoreDataEntries")]
        pub object_store_data_entries: Vec<DataEntry>,
        /// If true, there are more entries to fetch in the given range.
        #[serde(rename = "hasMore")]
        pub has_more: bool,
    }

    /// Gets metadata of an object store.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMetadata {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        /// Database name.
        #[serde(rename = "databaseName")]
        database_name: String,
        /// Object store name.
        #[serde(rename = "objectStoreName")]
        object_store_name: String,
    }

    impl GetMetadata {
        pub fn new(database_name: impl Into<String>, object_store_name: impl Into<String>) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
                object_store_name: object_store_name.into(),
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for GetMetadata {
        type Response = GetMetadataResult;
        const METHOD: &'static str = "IndexedDB.getMetadata";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMetadataResult {
        /// the entries count
        #[serde(rename = "entriesCount")]
        pub entries_count: f64,
        /// the current value of key generator, to become the next inserted key into the object store. Valid if objectStore.autoIncrement is true.
        #[serde(rename = "keyGeneratorValue")]
        pub key_generator_value: f64,
    }

    /// Requests database with given name in given frame.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestDatabase {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
        /// Database name.
        #[serde(rename = "databaseName")]
        database_name: String,
    }

    impl RequestDatabase {
        pub fn new(database_name: impl Into<String>) -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
                database_name: database_name.into(),
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for RequestDatabase {
        type Response = RequestDatabaseResult;
        const METHOD: &'static str = "IndexedDB.requestDatabase";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestDatabaseResult {
        /// Database with an array of object stores.
        #[serde(rename = "databaseWithObjectStores")]
        pub database_with_object_stores: DatabaseWithObjectStores,
    }

    /// Requests database names for given security origin.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestDatabaseNames {
        /// At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOrigin")]
        security_origin: Option<String>,
        /// Storage key.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageKey")]
        storage_key: Option<String>,
        /// Storage bucket. If not specified, it uses the default bucket.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "storageBucket")]
        storage_bucket: Option<storage::StorageBucket>,
    }

    impl RequestDatabaseNames {
        pub fn new() -> Self {
            Self {
                security_origin: None,
                storage_key: None,
                storage_bucket: None,
            }
        }

        pub fn with_security_origin(mut self, security_origin: impl Into<String>) -> Self {
            self.security_origin = Some(security_origin.into());
            self
        }

        pub fn with_storage_key(mut self, storage_key: impl Into<String>) -> Self {
            self.storage_key = Some(storage_key.into());
            self
        }

        pub fn with_storage_bucket(
            mut self,
            storage_bucket: impl Into<storage::StorageBucket>,
        ) -> Self {
            self.storage_bucket = Some(storage_bucket.into());
            self
        }
    }

    impl Command for RequestDatabaseNames {
        type Response = RequestDatabaseNamesResult;
        const METHOD: &'static str = "IndexedDB.requestDatabaseNames";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestDatabaseNamesResult {
        /// Database names for origin.
        #[serde(rename = "databaseNames")]
        pub database_names: Vec<String>,
    }
}

pub mod input {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TouchPoint {
        /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
        pub x: f64,
        /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        pub y: f64,
        /// X radius of the touch area (default: 1.0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "radiusX")]
        pub radius_x: Option<f64>,
        /// Y radius of the touch area (default: 1.0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "radiusY")]
        pub radius_y: Option<f64>,
        /// Rotation angle (default: 0.0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rotationAngle")]
        pub rotation_angle: Option<f64>,
        /// Force (default: 1.0).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub force: Option<f64>,
        /// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tangentialPressure")]
        pub tangential_pressure: Option<f64>,
        /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tiltX")]
        pub tilt_x: Option<f64>,
        /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tiltY")]
        pub tilt_y: Option<f64>,
        /// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub twist: Option<i64>,
        /// Identifier used to track touch sources between events, must be unique within an event.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub id: Option<f64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum GestureSourceType {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "touch")]
        Touch,
        #[serde(rename = "mouse")]
        Mouse,
    }
    impl From<&str> for GestureSourceType {
        fn from(s: &str) -> Self {
            match s {
                "default" => Self::Default,
                "touch" => Self::Touch,
                "mouse" => Self::Mouse,
                _ => Self::Default,
            }
        }
    }
    impl From<String> for GestureSourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MouseButton {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "left")]
        Left,
        #[serde(rename = "middle")]
        Middle,
        #[serde(rename = "right")]
        Right,
        #[serde(rename = "back")]
        Back,
        #[serde(rename = "forward")]
        Forward,
    }
    impl From<&str> for MouseButton {
        fn from(s: &str) -> Self {
            match s {
                "none" => Self::None,
                "left" => Self::Left,
                "middle" => Self::Middle,
                "right" => Self::Right,
                "back" => Self::Back,
                "forward" => Self::Forward,
                _ => Self::None,
            }
        }
    }
    impl From<String> for MouseButton {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// UTC time in seconds, counted from January 1, 1970.
    pub type TimeSinceEpoch = f64;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DragDataItem {
        /// Mime type of the dragged data.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        /// Depending of the value of `mimeType`, it contains the dragged link, text, HTML markup or any other data.
        pub data: String,
        /// Title associated with a link. Only valid when `mimeType` == "text/uri-list".
        #[serde(skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
        /// Stores the base URL for the contained markup. Only valid when `mimeType` == "text/html".
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "baseURL")]
        pub base_url: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DragData {
        pub items: Vec<DragDataItem>,
        /// List of filenames that should be included when dropping
        #[serde(skip_serializing_if = "Option::is_none")]
        pub files: Option<Vec<String>>,
        /// Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
        #[serde(rename = "dragOperationsMask")]
        pub drag_operations_mask: i64,
    }

    /// Dispatches a drag event into the page.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchDragEvent {
        /// Type of the drag event.
        #[serde(rename = "type")]
        type_: String,
        /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
        x: f64,
        /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        y: f64,
        data: DragData,
        /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        modifiers: Option<i64>,
    }

    impl DispatchDragEvent {
        pub fn new(
            type_: impl Into<String>,
            x: impl Into<f64>,
            y: impl Into<f64>,
            data: impl Into<DragData>,
        ) -> Self {
            Self {
                type_: type_.into(),
                x: x.into(),
                y: y.into(),
                data: data.into(),
                modifiers: None,
            }
        }

        pub fn with_modifiers(mut self, modifiers: impl Into<i64>) -> Self {
            self.modifiers = Some(modifiers.into());
            self
        }
    }

    impl Command for DispatchDragEvent {
        type Response = ();
        const METHOD: &'static str = "Input.dispatchDragEvent";
    }

    /// Dispatches a key event to the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchKeyEvent {
        /// Type of the key event.
        #[serde(rename = "type")]
        type_: String,
        /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        modifiers: Option<i64>,
        /// Time at which the event occurred.
        #[serde(skip_serializing_if = "Option::is_none")]
        timestamp: Option<TimeSinceEpoch>,
        /// Text as generated by processing a virtual key code with a keyboard layout. Not needed for for `keyUp` and `rawKeyDown` events (default: "")
        #[serde(skip_serializing_if = "Option::is_none")]
        text: Option<String>,
        /// Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "unmodifiedText")]
        unmodified_text: Option<String>,
        /// Unique key identifier (e.g., 'U+0041') (default: "").
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keyIdentifier")]
        key_identifier: Option<String>,
        /// Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
        #[serde(skip_serializing_if = "Option::is_none")]
        code: Option<String>,
        /// Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
        #[serde(skip_serializing_if = "Option::is_none")]
        key: Option<String>,
        /// Windows virtual key code (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "windowsVirtualKeyCode")]
        windows_virtual_key_code: Option<i64>,
        /// Native virtual key code (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nativeVirtualKeyCode")]
        native_virtual_key_code: Option<i64>,
        /// Whether the event was generated from auto repeat (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "autoRepeat")]
        auto_repeat: Option<bool>,
        /// Whether the event was generated from the keypad (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isKeypad")]
        is_keypad: Option<bool>,
        /// Whether the event was a system key event (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isSystemKey")]
        is_system_key: Option<bool>,
        /// Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        location: Option<i64>,
        /// Editing commands to send with the key event (e.g., 'selectAll') (default: []). These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding. See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        commands: Option<Vec<String>>,
    }

    impl DispatchKeyEvent {
        pub fn new(type_: impl Into<String>) -> Self {
            Self {
                type_: type_.into(),
                modifiers: None,
                timestamp: None,
                text: None,
                unmodified_text: None,
                key_identifier: None,
                code: None,
                key: None,
                windows_virtual_key_code: None,
                native_virtual_key_code: None,
                auto_repeat: None,
                is_keypad: None,
                is_system_key: None,
                location: None,
                commands: None,
            }
        }

        pub fn with_modifiers(mut self, modifiers: impl Into<i64>) -> Self {
            self.modifiers = Some(modifiers.into());
            self
        }

        pub fn with_timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
            self.timestamp = Some(timestamp.into());
            self
        }

        pub fn with_text(mut self, text: impl Into<String>) -> Self {
            self.text = Some(text.into());
            self
        }

        pub fn with_unmodified_text(mut self, unmodified_text: impl Into<String>) -> Self {
            self.unmodified_text = Some(unmodified_text.into());
            self
        }

        pub fn with_key_identifier(mut self, key_identifier: impl Into<String>) -> Self {
            self.key_identifier = Some(key_identifier.into());
            self
        }

        pub fn with_code(mut self, code: impl Into<String>) -> Self {
            self.code = Some(code.into());
            self
        }

        pub fn with_key(mut self, key: impl Into<String>) -> Self {
            self.key = Some(key.into());
            self
        }

        pub fn with_windows_virtual_key_code(
            mut self,
            windows_virtual_key_code: impl Into<i64>,
        ) -> Self {
            self.windows_virtual_key_code = Some(windows_virtual_key_code.into());
            self
        }

        pub fn with_native_virtual_key_code(
            mut self,
            native_virtual_key_code: impl Into<i64>,
        ) -> Self {
            self.native_virtual_key_code = Some(native_virtual_key_code.into());
            self
        }

        pub fn with_auto_repeat(mut self, auto_repeat: impl Into<bool>) -> Self {
            self.auto_repeat = Some(auto_repeat.into());
            self
        }

        pub fn with_is_keypad(mut self, is_keypad: impl Into<bool>) -> Self {
            self.is_keypad = Some(is_keypad.into());
            self
        }

        pub fn with_is_system_key(mut self, is_system_key: impl Into<bool>) -> Self {
            self.is_system_key = Some(is_system_key.into());
            self
        }

        pub fn with_location(mut self, location: impl Into<i64>) -> Self {
            self.location = Some(location.into());
            self
        }

        pub fn with_commands(mut self, commands: impl Into<Vec<String>>) -> Self {
            self.commands = Some(commands.into());
            self
        }
    }

    impl Command for DispatchKeyEvent {
        type Response = ();
        const METHOD: &'static str = "Input.dispatchKeyEvent";
    }

    /// This method emulates inserting text that doesn't come from a key press, for example an emoji keyboard or an IME.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InsertText {
        /// The text to insert.
        text: String,
    }

    impl InsertText {
        pub fn new(text: impl Into<String>) -> Self {
            Self { text: text.into() }
        }
    }

    impl Command for InsertText {
        type Response = ();
        const METHOD: &'static str = "Input.insertText";
    }

    /// This method sets the current candidate text for IME. Use imeCommitComposition to commit the final text. Use imeSetComposition with empty string as text to cancel composition.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ImeSetComposition {
        /// The text to insert
        text: String,
        /// selection start
        #[serde(rename = "selectionStart")]
        selection_start: i64,
        /// selection end
        #[serde(rename = "selectionEnd")]
        selection_end: i64,
        /// replacement start
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "replacementStart")]
        replacement_start: Option<i64>,
        /// replacement end
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "replacementEnd")]
        replacement_end: Option<i64>,
    }

    impl ImeSetComposition {
        pub fn new(
            text: impl Into<String>,
            selection_start: impl Into<i64>,
            selection_end: impl Into<i64>,
        ) -> Self {
            Self {
                text: text.into(),
                selection_start: selection_start.into(),
                selection_end: selection_end.into(),
                replacement_start: None,
                replacement_end: None,
            }
        }

        pub fn with_replacement_start(mut self, replacement_start: impl Into<i64>) -> Self {
            self.replacement_start = Some(replacement_start.into());
            self
        }

        pub fn with_replacement_end(mut self, replacement_end: impl Into<i64>) -> Self {
            self.replacement_end = Some(replacement_end.into());
            self
        }
    }

    impl Command for ImeSetComposition {
        type Response = ();
        const METHOD: &'static str = "Input.imeSetComposition";
    }

    /// Dispatches a mouse event to the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchMouseEvent {
        /// Type of the mouse event.
        #[serde(rename = "type")]
        type_: String,
        /// X coordinate of the event relative to the main frame's viewport in CSS pixels.
        x: f64,
        /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        y: f64,
        /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        modifiers: Option<i64>,
        /// Time at which the event occurred.
        #[serde(skip_serializing_if = "Option::is_none")]
        timestamp: Option<TimeSinceEpoch>,
        /// Mouse button (default: "none").
        #[serde(skip_serializing_if = "Option::is_none")]
        button: Option<MouseButton>,
        /// A number indicating which buttons are pressed on the mouse when a mouse event is triggered. Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
        #[serde(skip_serializing_if = "Option::is_none")]
        buttons: Option<i64>,
        /// Number of times the mouse button was clicked (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clickCount")]
        click_count: Option<i64>,
        /// The normalized pressure, which has a range of [0,1] (default: 0).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        force: Option<f64>,
        /// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tangentialPressure")]
        tangential_pressure: Option<f64>,
        /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tiltX")]
        tilt_x: Option<f64>,
        /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tiltY")]
        tilt_y: Option<f64>,
        /// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        twist: Option<i64>,
        /// X delta in CSS pixels for mouse wheel event (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deltaX")]
        delta_x: Option<f64>,
        /// Y delta in CSS pixels for mouse wheel event (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deltaY")]
        delta_y: Option<f64>,
        /// Pointer type (default: "mouse").
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pointerType")]
        pointer_type: Option<String>,
    }

    impl DispatchMouseEvent {
        pub fn new(type_: impl Into<String>, x: impl Into<f64>, y: impl Into<f64>) -> Self {
            Self {
                type_: type_.into(),
                x: x.into(),
                y: y.into(),
                modifiers: None,
                timestamp: None,
                button: None,
                buttons: None,
                click_count: None,
                force: None,
                tangential_pressure: None,
                tilt_x: None,
                tilt_y: None,
                twist: None,
                delta_x: None,
                delta_y: None,
                pointer_type: None,
            }
        }

        pub fn with_modifiers(mut self, modifiers: impl Into<i64>) -> Self {
            self.modifiers = Some(modifiers.into());
            self
        }

        pub fn with_timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
            self.timestamp = Some(timestamp.into());
            self
        }

        pub fn with_button(mut self, button: impl Into<MouseButton>) -> Self {
            self.button = Some(button.into());
            self
        }

        pub fn with_buttons(mut self, buttons: impl Into<i64>) -> Self {
            self.buttons = Some(buttons.into());
            self
        }

        pub fn with_click_count(mut self, click_count: impl Into<i64>) -> Self {
            self.click_count = Some(click_count.into());
            self
        }

        pub fn with_force(mut self, force: impl Into<f64>) -> Self {
            self.force = Some(force.into());
            self
        }

        pub fn with_tangential_pressure(mut self, tangential_pressure: impl Into<f64>) -> Self {
            self.tangential_pressure = Some(tangential_pressure.into());
            self
        }

        pub fn with_tilt_x(mut self, tilt_x: impl Into<f64>) -> Self {
            self.tilt_x = Some(tilt_x.into());
            self
        }

        pub fn with_tilt_y(mut self, tilt_y: impl Into<f64>) -> Self {
            self.tilt_y = Some(tilt_y.into());
            self
        }

        pub fn with_twist(mut self, twist: impl Into<i64>) -> Self {
            self.twist = Some(twist.into());
            self
        }

        pub fn with_delta_x(mut self, delta_x: impl Into<f64>) -> Self {
            self.delta_x = Some(delta_x.into());
            self
        }

        pub fn with_delta_y(mut self, delta_y: impl Into<f64>) -> Self {
            self.delta_y = Some(delta_y.into());
            self
        }

        pub fn with_pointer_type(mut self, pointer_type: impl Into<String>) -> Self {
            self.pointer_type = Some(pointer_type.into());
            self
        }
    }

    impl Command for DispatchMouseEvent {
        type Response = ();
        const METHOD: &'static str = "Input.dispatchMouseEvent";
    }

    /// Dispatches a touch event to the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchTouchEvent {
        /// Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
        #[serde(rename = "type")]
        type_: String,
        /// Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
        #[serde(rename = "touchPoints")]
        touch_points: Vec<TouchPoint>,
        /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        modifiers: Option<i64>,
        /// Time at which the event occurred.
        #[serde(skip_serializing_if = "Option::is_none")]
        timestamp: Option<TimeSinceEpoch>,
    }

    impl DispatchTouchEvent {
        pub fn new(type_: impl Into<String>, touch_points: impl Into<Vec<TouchPoint>>) -> Self {
            Self {
                type_: type_.into(),
                touch_points: touch_points.into(),
                modifiers: None,
                timestamp: None,
            }
        }

        pub fn with_modifiers(mut self, modifiers: impl Into<i64>) -> Self {
            self.modifiers = Some(modifiers.into());
            self
        }

        pub fn with_timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
            self.timestamp = Some(timestamp.into());
            self
        }
    }

    impl Command for DispatchTouchEvent {
        type Response = ();
        const METHOD: &'static str = "Input.dispatchTouchEvent";
    }

    /// Cancels any active dragging in the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CancelDragging {}

    impl CancelDragging {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CancelDragging {
        type Response = ();
        const METHOD: &'static str = "Input.cancelDragging";
    }

    /// Emulates touch event from the mouse event parameters.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EmulateTouchFromMouseEvent {
        /// Type of the mouse event.
        #[serde(rename = "type")]
        type_: String,
        /// X coordinate of the mouse pointer in DIP.
        x: i64,
        /// Y coordinate of the mouse pointer in DIP.
        y: i64,
        /// Mouse button. Only "none", "left", "right" are supported.
        button: MouseButton,
        /// Time at which the event occurred (default: current time).
        #[serde(skip_serializing_if = "Option::is_none")]
        timestamp: Option<TimeSinceEpoch>,
        /// X delta in DIP for mouse wheel event (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deltaX")]
        delta_x: Option<f64>,
        /// Y delta in DIP for mouse wheel event (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deltaY")]
        delta_y: Option<f64>,
        /// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        modifiers: Option<i64>,
        /// Number of times the mouse button was clicked (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clickCount")]
        click_count: Option<i64>,
    }

    impl EmulateTouchFromMouseEvent {
        pub fn new(
            type_: impl Into<String>,
            x: impl Into<i64>,
            y: impl Into<i64>,
            button: impl Into<MouseButton>,
        ) -> Self {
            Self {
                type_: type_.into(),
                x: x.into(),
                y: y.into(),
                button: button.into(),
                timestamp: None,
                delta_x: None,
                delta_y: None,
                modifiers: None,
                click_count: None,
            }
        }

        pub fn with_timestamp(mut self, timestamp: impl Into<TimeSinceEpoch>) -> Self {
            self.timestamp = Some(timestamp.into());
            self
        }

        pub fn with_delta_x(mut self, delta_x: impl Into<f64>) -> Self {
            self.delta_x = Some(delta_x.into());
            self
        }

        pub fn with_delta_y(mut self, delta_y: impl Into<f64>) -> Self {
            self.delta_y = Some(delta_y.into());
            self
        }

        pub fn with_modifiers(mut self, modifiers: impl Into<i64>) -> Self {
            self.modifiers = Some(modifiers.into());
            self
        }

        pub fn with_click_count(mut self, click_count: impl Into<i64>) -> Self {
            self.click_count = Some(click_count.into());
            self
        }
    }

    impl Command for EmulateTouchFromMouseEvent {
        type Response = ();
        const METHOD: &'static str = "Input.emulateTouchFromMouseEvent";
    }

    /// Ignores input events (useful while auditing page).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetIgnoreInputEvents {
        /// Ignores input events processing when set to true.
        ignore: bool,
    }

    impl SetIgnoreInputEvents {
        pub fn new(ignore: impl Into<bool>) -> Self {
            Self {
                ignore: ignore.into(),
            }
        }
    }

    impl Command for SetIgnoreInputEvents {
        type Response = ();
        const METHOD: &'static str = "Input.setIgnoreInputEvents";
    }

    /// Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events. Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInterceptDrags {
        enabled: bool,
    }

    impl SetInterceptDrags {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetInterceptDrags {
        type Response = ();
        const METHOD: &'static str = "Input.setInterceptDrags";
    }

    /// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SynthesizePinchGesture {
        /// X coordinate of the start of the gesture in CSS pixels.
        x: f64,
        /// Y coordinate of the start of the gesture in CSS pixels.
        y: f64,
        /// Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
        #[serde(rename = "scaleFactor")]
        scale_factor: f64,
        /// Relative pointer speed in pixels per second (default: 800).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "relativeSpeed")]
        relative_speed: Option<i64>,
        /// Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gestureSourceType")]
        gesture_source_type: Option<GestureSourceType>,
    }

    impl SynthesizePinchGesture {
        pub fn new(x: impl Into<f64>, y: impl Into<f64>, scale_factor: impl Into<f64>) -> Self {
            Self {
                x: x.into(),
                y: y.into(),
                scale_factor: scale_factor.into(),
                relative_speed: None,
                gesture_source_type: None,
            }
        }

        pub fn with_relative_speed(mut self, relative_speed: impl Into<i64>) -> Self {
            self.relative_speed = Some(relative_speed.into());
            self
        }

        pub fn with_gesture_source_type(
            mut self,
            gesture_source_type: impl Into<GestureSourceType>,
        ) -> Self {
            self.gesture_source_type = Some(gesture_source_type.into());
            self
        }
    }

    impl Command for SynthesizePinchGesture {
        type Response = ();
        const METHOD: &'static str = "Input.synthesizePinchGesture";
    }

    /// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SynthesizeScrollGesture {
        /// X coordinate of the start of the gesture in CSS pixels.
        x: f64,
        /// Y coordinate of the start of the gesture in CSS pixels.
        y: f64,
        /// The distance to scroll along the X axis (positive to scroll left).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "xDistance")]
        x_distance: Option<f64>,
        /// The distance to scroll along the Y axis (positive to scroll up).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "yDistance")]
        y_distance: Option<f64>,
        /// The number of additional pixels to scroll back along the X axis, in addition to the given distance.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "xOverscroll")]
        x_overscroll: Option<f64>,
        /// The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "yOverscroll")]
        y_overscroll: Option<f64>,
        /// Prevent fling (default: true).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "preventFling")]
        prevent_fling: Option<bool>,
        /// Swipe speed in pixels per second (default: 800).
        #[serde(skip_serializing_if = "Option::is_none")]
        speed: Option<i64>,
        /// Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gestureSourceType")]
        gesture_source_type: Option<GestureSourceType>,
        /// The number of times to repeat the gesture (default: 0).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "repeatCount")]
        repeat_count: Option<i64>,
        /// The number of milliseconds delay between each repeat. (default: 250).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "repeatDelayMs")]
        repeat_delay_ms: Option<i64>,
        /// The name of the interaction markers to generate, if not empty (default: "").
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "interactionMarkerName")]
        interaction_marker_name: Option<String>,
    }

    impl SynthesizeScrollGesture {
        pub fn new(x: impl Into<f64>, y: impl Into<f64>) -> Self {
            Self {
                x: x.into(),
                y: y.into(),
                x_distance: None,
                y_distance: None,
                x_overscroll: None,
                y_overscroll: None,
                prevent_fling: None,
                speed: None,
                gesture_source_type: None,
                repeat_count: None,
                repeat_delay_ms: None,
                interaction_marker_name: None,
            }
        }

        pub fn with_x_distance(mut self, x_distance: impl Into<f64>) -> Self {
            self.x_distance = Some(x_distance.into());
            self
        }

        pub fn with_y_distance(mut self, y_distance: impl Into<f64>) -> Self {
            self.y_distance = Some(y_distance.into());
            self
        }

        pub fn with_x_overscroll(mut self, x_overscroll: impl Into<f64>) -> Self {
            self.x_overscroll = Some(x_overscroll.into());
            self
        }

        pub fn with_y_overscroll(mut self, y_overscroll: impl Into<f64>) -> Self {
            self.y_overscroll = Some(y_overscroll.into());
            self
        }

        pub fn with_prevent_fling(mut self, prevent_fling: impl Into<bool>) -> Self {
            self.prevent_fling = Some(prevent_fling.into());
            self
        }

        pub fn with_speed(mut self, speed: impl Into<i64>) -> Self {
            self.speed = Some(speed.into());
            self
        }

        pub fn with_gesture_source_type(
            mut self,
            gesture_source_type: impl Into<GestureSourceType>,
        ) -> Self {
            self.gesture_source_type = Some(gesture_source_type.into());
            self
        }

        pub fn with_repeat_count(mut self, repeat_count: impl Into<i64>) -> Self {
            self.repeat_count = Some(repeat_count.into());
            self
        }

        pub fn with_repeat_delay_ms(mut self, repeat_delay_ms: impl Into<i64>) -> Self {
            self.repeat_delay_ms = Some(repeat_delay_ms.into());
            self
        }

        pub fn with_interaction_marker_name(
            mut self,
            interaction_marker_name: impl Into<String>,
        ) -> Self {
            self.interaction_marker_name = Some(interaction_marker_name.into());
            self
        }
    }

    impl Command for SynthesizeScrollGesture {
        type Response = ();
        const METHOD: &'static str = "Input.synthesizeScrollGesture";
    }

    /// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SynthesizeTapGesture {
        /// X coordinate of the start of the gesture in CSS pixels.
        x: f64,
        /// Y coordinate of the start of the gesture in CSS pixels.
        y: f64,
        /// Duration between touchdown and touchup events in ms (default: 50).
        #[serde(skip_serializing_if = "Option::is_none")]
        duration: Option<i64>,
        /// Number of times to perform the tap (e.g. 2 for double tap, default: 1).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tapCount")]
        tap_count: Option<i64>,
        /// Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gestureSourceType")]
        gesture_source_type: Option<GestureSourceType>,
    }

    impl SynthesizeTapGesture {
        pub fn new(x: impl Into<f64>, y: impl Into<f64>) -> Self {
            Self {
                x: x.into(),
                y: y.into(),
                duration: None,
                tap_count: None,
                gesture_source_type: None,
            }
        }

        pub fn with_duration(mut self, duration: impl Into<i64>) -> Self {
            self.duration = Some(duration.into());
            self
        }

        pub fn with_tap_count(mut self, tap_count: impl Into<i64>) -> Self {
            self.tap_count = Some(tap_count.into());
            self
        }

        pub fn with_gesture_source_type(
            mut self,
            gesture_source_type: impl Into<GestureSourceType>,
        ) -> Self {
            self.gesture_source_type = Some(gesture_source_type.into());
            self
        }
    }

    impl Command for SynthesizeTapGesture {
        type Response = ();
        const METHOD: &'static str = "Input.synthesizeTapGesture";
    }

    /// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to restore normal drag and drop behavior.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DragIntercepted {
        pub data: DragData,
    }

    impl DragIntercepted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Input.dragIntercepted")
        }
    }
}

pub mod inspector {
    use super::*;

    /// Disables inspector domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Inspector.disable";
    }

    /// Enables inspector domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Inspector.enable";
    }

    /// Fired when remote debugging connection is about to be terminated. Contains detach reason.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Detached {
        /// The reason why connection has been terminated.
        pub reason: String,
    }

    impl Detached {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Inspector.detached")
        }
    }

    /// Fired when debugging target has crashed
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetCrashed {}

    impl TargetCrashed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Inspector.targetCrashed")
        }
    }

    /// Fired when debugging target has reloaded after crash
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetReloadedAfterCrash {}

    impl TargetReloadedAfterCrash {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Inspector.targetReloadedAfterCrash")
        }
    }

    /// Fired on worker targets when main worker script and any imported scripts have been evaluated.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WorkerScriptLoaded {}

    impl WorkerScriptLoaded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Inspector.workerScriptLoaded")
        }
    }
}

pub mod layer_tree {
    use super::*;

    /// Unique Layer identifier.
    pub type LayerId = String;

    /// Unique snapshot identifier.
    pub type SnapshotId = String;

    /// Rectangle where scrolling happens on the main thread.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScrollRect {
        /// Rectangle itself.
        pub rect: dom::Rect,
        /// Reason for rectangle to force scrolling on the main thread
        #[serde(rename = "type")]
        pub type_: String,
    }

    /// Sticky position constraints.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StickyPositionConstraint {
        /// Layout rectangle of the sticky element before being shifted
        #[serde(rename = "stickyBoxRect")]
        pub sticky_box_rect: dom::Rect,
        /// Layout rectangle of the containing block of the sticky element
        #[serde(rename = "containingBlockRect")]
        pub containing_block_rect: dom::Rect,
        /// The nearest sticky layer that shifts the sticky box
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nearestLayerShiftingStickyBox")]
        pub nearest_layer_shifting_sticky_box: Option<LayerId>,
        /// The nearest sticky layer that shifts the containing block
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nearestLayerShiftingContainingBlock")]
        pub nearest_layer_shifting_containing_block: Option<LayerId>,
    }

    /// Serialized fragment of layer picture along with its offset within the layer.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PictureTile {
        /// Offset from owning layer left boundary
        pub x: f64,
        /// Offset from owning layer top boundary
        pub y: f64,
        /// Base64-encoded snapshot data. (Encoded as a base64 string when passed over JSON)
        pub picture: String,
    }

    /// Information about a compositing layer.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Layer {
        /// The unique id for this layer.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
        /// The id of parent (not present for root).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentLayerId")]
        pub parent_layer_id: Option<LayerId>,
        /// The backend id for the node associated with this layer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<dom::BackendNodeId>,
        /// Offset from parent layer, X coordinate.
        #[serde(rename = "offsetX")]
        pub offset_x: f64,
        /// Offset from parent layer, Y coordinate.
        #[serde(rename = "offsetY")]
        pub offset_y: f64,
        /// Layer width.
        pub width: f64,
        /// Layer height.
        pub height: f64,
        /// Transformation matrix for layer, default is identity matrix
        #[serde(skip_serializing_if = "Option::is_none")]
        pub transform: Option<Vec<f64>>,
        /// Transform anchor point X, absent if no transform specified
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "anchorX")]
        pub anchor_x: Option<f64>,
        /// Transform anchor point Y, absent if no transform specified
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "anchorY")]
        pub anchor_y: Option<f64>,
        /// Transform anchor point Z, absent if no transform specified
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "anchorZ")]
        pub anchor_z: Option<f64>,
        /// Indicates how many time this layer has painted.
        #[serde(rename = "paintCount")]
        pub paint_count: i64,
        /// Indicates whether this layer hosts any content, rather than being used for transform/scrolling purposes only.
        #[serde(rename = "drawsContent")]
        pub draws_content: bool,
        /// Set if layer is not visible.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub invisible: Option<bool>,
        /// Rectangles scrolling on main thread only.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollRects")]
        pub scroll_rects: Option<Vec<ScrollRect>>,
        /// Sticky position constraint information
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "stickyPositionConstraint")]
        pub sticky_position_constraint: Option<StickyPositionConstraint>,
    }

    /// Array of timings, one per paint step.
    pub type PaintProfile = Vec<f64>;

    /// Provides the reasons why the given layer was composited.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompositingReasons {
        /// The id of the layer for which we want to get the reasons it was composited.
        #[serde(rename = "layerId")]
        layer_id: LayerId,
    }

    impl CompositingReasons {
        pub fn new(layer_id: impl Into<LayerId>) -> Self {
            Self {
                layer_id: layer_id.into(),
            }
        }
    }

    impl Command for CompositingReasons {
        type Response = CompositingReasonsResult;
        const METHOD: &'static str = "LayerTree.compositingReasons";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompositingReasonsResult {
        /// A list of strings specifying reasons for the given layer to become composited.
        #[serde(rename = "compositingReasons")]
        pub compositing_reasons: Vec<String>,
        /// A list of strings specifying reason IDs for the given layer to become composited.
        #[serde(rename = "compositingReasonIds")]
        pub compositing_reason_ids: Vec<String>,
    }

    /// Disables compositing tree inspection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "LayerTree.disable";
    }

    /// Enables compositing tree inspection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "LayerTree.enable";
    }

    /// Returns the snapshot identifier.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadSnapshot {
        /// An array of tiles composing the snapshot.
        tiles: Vec<PictureTile>,
    }

    impl LoadSnapshot {
        pub fn new(tiles: impl Into<Vec<PictureTile>>) -> Self {
            Self {
                tiles: tiles.into(),
            }
        }
    }

    impl Command for LoadSnapshot {
        type Response = LoadSnapshotResult;
        const METHOD: &'static str = "LayerTree.loadSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadSnapshotResult {
        /// The id of the snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }

    /// Returns the layer snapshot identifier.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MakeSnapshot {
        /// The id of the layer.
        #[serde(rename = "layerId")]
        layer_id: LayerId,
    }

    impl MakeSnapshot {
        pub fn new(layer_id: impl Into<LayerId>) -> Self {
            Self {
                layer_id: layer_id.into(),
            }
        }
    }

    impl Command for MakeSnapshot {
        type Response = MakeSnapshotResult;
        const METHOD: &'static str = "LayerTree.makeSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MakeSnapshotResult {
        /// The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        pub snapshot_id: SnapshotId,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProfileSnapshot {
        /// The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        snapshot_id: SnapshotId,
        /// The maximum number of times to replay the snapshot (1, if not specified).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "minRepeatCount")]
        min_repeat_count: Option<i64>,
        /// The minimum duration (in seconds) to replay the snapshot.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "minDuration")]
        min_duration: Option<f64>,
        /// The clip rectangle to apply when replaying the snapshot.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "clipRect")]
        clip_rect: Option<dom::Rect>,
    }

    impl ProfileSnapshot {
        pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
            Self {
                snapshot_id: snapshot_id.into(),
                min_repeat_count: None,
                min_duration: None,
                clip_rect: None,
            }
        }

        pub fn with_min_repeat_count(mut self, min_repeat_count: impl Into<i64>) -> Self {
            self.min_repeat_count = Some(min_repeat_count.into());
            self
        }

        pub fn with_min_duration(mut self, min_duration: impl Into<f64>) -> Self {
            self.min_duration = Some(min_duration.into());
            self
        }

        pub fn with_clip_rect(mut self, clip_rect: impl Into<dom::Rect>) -> Self {
            self.clip_rect = Some(clip_rect.into());
            self
        }
    }

    impl Command for ProfileSnapshot {
        type Response = ProfileSnapshotResult;
        const METHOD: &'static str = "LayerTree.profileSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProfileSnapshotResult {
        /// The array of paint profiles, one per run.
        pub timings: Vec<PaintProfile>,
    }

    /// Releases layer snapshot captured by the back-end.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReleaseSnapshot {
        /// The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        snapshot_id: SnapshotId,
    }

    impl ReleaseSnapshot {
        pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
            Self {
                snapshot_id: snapshot_id.into(),
            }
        }
    }

    impl Command for ReleaseSnapshot {
        type Response = ();
        const METHOD: &'static str = "LayerTree.releaseSnapshot";
    }

    /// Replays the layer snapshot and returns the resulting bitmap.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReplaySnapshot {
        /// The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        snapshot_id: SnapshotId,
        /// The first step to replay from (replay from the very start if not specified).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromStep")]
        from_step: Option<i64>,
        /// The last step to replay to (replay till the end if not specified).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "toStep")]
        to_step: Option<i64>,
        /// The scale to apply while replaying (defaults to 1).
        #[serde(skip_serializing_if = "Option::is_none")]
        scale: Option<f64>,
    }

    impl ReplaySnapshot {
        pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
            Self {
                snapshot_id: snapshot_id.into(),
                from_step: None,
                to_step: None,
                scale: None,
            }
        }

        pub fn with_from_step(mut self, from_step: impl Into<i64>) -> Self {
            self.from_step = Some(from_step.into());
            self
        }

        pub fn with_to_step(mut self, to_step: impl Into<i64>) -> Self {
            self.to_step = Some(to_step.into());
            self
        }

        pub fn with_scale(mut self, scale: impl Into<f64>) -> Self {
            self.scale = Some(scale.into());
            self
        }
    }

    impl Command for ReplaySnapshot {
        type Response = ReplaySnapshotResult;
        const METHOD: &'static str = "LayerTree.replaySnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReplaySnapshotResult {
        /// A data: URL for resulting image.
        #[serde(rename = "dataURL")]
        pub data_url: String,
    }

    /// Replays the layer snapshot and returns canvas log.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SnapshotCommandLog {
        /// The id of the layer snapshot.
        #[serde(rename = "snapshotId")]
        snapshot_id: SnapshotId,
    }

    impl SnapshotCommandLog {
        pub fn new(snapshot_id: impl Into<SnapshotId>) -> Self {
            Self {
                snapshot_id: snapshot_id.into(),
            }
        }
    }

    impl Command for SnapshotCommandLog {
        type Response = SnapshotCommandLogResult;
        const METHOD: &'static str = "LayerTree.snapshotCommandLog";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SnapshotCommandLogResult {
        /// The array of canvas function calls.
        #[serde(rename = "commandLog")]
        pub command_log: Vec<serde_json::Value>,
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayerPainted {
        /// The id of the painted layer.
        #[serde(rename = "layerId")]
        pub layer_id: LayerId,
        /// Clip rectangle.
        pub clip: dom::Rect,
    }

    impl LayerPainted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("LayerTree.layerPainted")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayerTreeDidChange {
        /// Layer tree, absent if not in the compositing mode.
        pub layers: Option<Vec<Layer>>,
    }

    impl LayerTreeDidChange {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("LayerTree.layerTreeDidChange")
        }
    }
}

pub mod log {
    use super::*;

    /// Log entry.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LogEntry {
        /// Log entry source.
        pub source: String,
        /// Log entry severity.
        pub level: String,
        /// Logged text.
        pub text: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub category: Option<String>,
        /// Timestamp when this entry was added.
        pub timestamp: runtime::Timestamp,
        /// URL of the resource if known.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// Line number in the resource.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lineNumber")]
        pub line_number: Option<i64>,
        /// JavaScript stack trace.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<runtime::StackTrace>,
        /// Identifier of the network request associated with this entry.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "networkRequestId")]
        pub network_request_id: Option<network::RequestId>,
        /// Identifier of the worker associated with this entry.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workerId")]
        pub worker_id: Option<String>,
        /// Call arguments.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub args: Option<Vec<runtime::RemoteObject>>,
    }

    /// Violation configuration setting.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ViolationSetting {
        /// Violation type.
        pub name: String,
        /// Time threshold to trigger upon.
        pub threshold: f64,
    }

    /// Clears the log.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Clear {}

    impl Clear {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Clear {
        type Response = ();
        const METHOD: &'static str = "Log.clear";
    }

    /// Disables log domain, prevents further log entries from being reported to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Log.disable";
    }

    /// Enables log domain, sends the entries collected so far to the client by means of the `entryAdded` notification.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Log.enable";
    }

    /// start violation reporting.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartViolationsReport {
        /// Configuration for violations.
        config: Vec<ViolationSetting>,
    }

    impl StartViolationsReport {
        pub fn new(config: impl Into<Vec<ViolationSetting>>) -> Self {
            Self {
                config: config.into(),
            }
        }
    }

    impl Command for StartViolationsReport {
        type Response = ();
        const METHOD: &'static str = "Log.startViolationsReport";
    }

    /// Stop violation reporting.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopViolationsReport {}

    impl StopViolationsReport {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopViolationsReport {
        type Response = ();
        const METHOD: &'static str = "Log.stopViolationsReport";
    }

    /// Issued when new message was logged.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EntryAdded {
        /// The entry.
        pub entry: LogEntry,
    }

    impl EntryAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Log.entryAdded")
        }
    }
}

pub mod media {
    use super::*;

    /// Players will get an ID that is unique within the agent context.
    pub type PlayerId = String;

    pub type Timestamp = f64;

    /// Have one type per entry in MediaLogRecord::Type Corresponds to kMessage
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerMessage {
        /// Keep in sync with MediaLogMessageLevel We are currently keeping the message level 'error' separate from the PlayerError type because right now they represent different things, this one being a DVLOG(ERROR) style log message that gets printed based on what log level is selected in the UI, and the other is a representation of a media::PipelineStatus object. Soon however we're going to be moving away from using PipelineStatus for errors and introducing a new error type which should hopefully let us integrate the error log level into the PlayerError type.
        pub level: String,
        pub message: String,
    }

    /// Corresponds to kMediaPropertyChange
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerProperty {
        pub name: String,
        pub value: String,
    }

    /// Corresponds to kMediaEventTriggered
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerEvent {
        pub timestamp: Timestamp,
        pub value: String,
    }

    /// Represents logged source line numbers reported in an error. NOTE: file and line are from chromium c++ implementation code, not js.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerErrorSourceLocation {
        pub file: String,
        pub line: i64,
    }

    /// Corresponds to kMediaError
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerError {
        #[serde(rename = "errorType")]
        pub error_type: String,
        /// Code is the numeric enum entry for a specific set of error codes, such as PipelineStatusCodes in media/base/pipeline_status.h
        pub code: i64,
        /// A trace of where this error was caused / where it passed through.
        pub stack: Vec<PlayerErrorSourceLocation>,
        /// Errors potentially have a root cause error, ie, a DecoderError might be caused by an WindowsError
        pub cause: Vec<PlayerError>,
        /// Extra data attached to an error, such as an HRESULT, Video Codec, etc.
        pub data: serde_json::Value,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Player {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "domNodeId")]
        pub dom_node_id: Option<dom::BackendNodeId>,
    }

    /// Enables the Media domain
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Media.enable";
    }

    /// Disables the Media domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Media.disable";
    }

    /// This can be called multiple times, and can be used to set / override / remove player properties. A null propValue indicates removal.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerPropertiesChanged {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        pub properties: Vec<PlayerProperty>,
    }

    impl PlayerPropertiesChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Media.playerPropertiesChanged")
        }
    }

    /// Send events as a list, allowing them to be batched on the browser for less congestion. If batched, events must ALWAYS be in chronological order.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerEventsAdded {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        pub events: Vec<PlayerEvent>,
    }

    impl PlayerEventsAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Media.playerEventsAdded")
        }
    }

    /// Send a list of any messages that need to be delivered.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerMessagesLogged {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        pub messages: Vec<PlayerMessage>,
    }

    impl PlayerMessagesLogged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Media.playerMessagesLogged")
        }
    }

    /// Send a list of any errors that need to be delivered.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerErrorsRaised {
        #[serde(rename = "playerId")]
        pub player_id: PlayerId,
        pub errors: Vec<PlayerError>,
    }

    impl PlayerErrorsRaised {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Media.playerErrorsRaised")
        }
    }

    /// Called whenever a player is created, or when a new agent joins and receives a list of active players. If an agent is restored, it will receive one event for each active player.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PlayerCreated {
        pub player: Player,
    }

    impl PlayerCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Media.playerCreated")
        }
    }
}

pub mod memory {
    use super::*;

    /// Memory pressure level.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PressureLevel {
        #[serde(rename = "moderate")]
        Moderate,
        #[serde(rename = "critical")]
        Critical,
    }
    impl From<&str> for PressureLevel {
        fn from(s: &str) -> Self {
            match s {
                "moderate" => Self::Moderate,
                "critical" => Self::Critical,
                _ => Self::Moderate,
            }
        }
    }
    impl From<String> for PressureLevel {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Heap profile sample.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SamplingProfileNode {
        /// Size of the sampled allocation.
        pub size: f64,
        /// Total bytes attributed to this sample.
        pub total: f64,
        /// Execution stack at the point of allocation.
        pub stack: Vec<String>,
    }

    /// Array of heap profile samples.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SamplingProfile {
        pub samples: Vec<SamplingProfileNode>,
        pub modules: Vec<Module>,
    }

    /// Executable module information
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Module {
        /// Name of the module.
        pub name: String,
        /// UUID of the module.
        pub uuid: String,
        /// Base address where the module is loaded into memory. Encoded as a decimal or hexadecimal (0x prefixed) string.
        #[serde(rename = "baseAddress")]
        pub base_address: String,
        /// Size of the module in bytes.
        pub size: f64,
    }

    /// DOM object counter data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DOMCounter {
        /// Object name. Note: object names should be presumed volatile and clients should not expect the returned names to be consistent across runs.
        pub name: String,
        /// Object count.
        pub count: i64,
    }

    /// Retruns current DOM object counters.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomCounters {}

    impl GetDomCounters {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetDomCounters {
        type Response = GetDomCountersResult;
        const METHOD: &'static str = "Memory.getDOMCounters";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomCountersResult {
        pub documents: i64,
        pub nodes: i64,
        #[serde(rename = "jsEventListeners")]
        pub js_event_listeners: i64,
    }

    /// Retruns DOM object counters after preparing renderer for leak detection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomCountersForLeakDetection {}

    impl GetDomCountersForLeakDetection {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetDomCountersForLeakDetection {
        type Response = GetDomCountersForLeakDetectionResult;
        const METHOD: &'static str = "Memory.getDOMCountersForLeakDetection";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomCountersForLeakDetectionResult {
        /// DOM object counters.
        pub counters: Vec<DOMCounter>,
    }

    /// Prepares for leak detection by terminating workers, stopping spellcheckers, dropping non-essential internal caches, running garbage collections, etc.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrepareForLeakDetection {}

    impl PrepareForLeakDetection {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for PrepareForLeakDetection {
        type Response = ();
        const METHOD: &'static str = "Memory.prepareForLeakDetection";
    }

    /// Simulate OomIntervention by purging V8 memory.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ForciblyPurgeJavaScriptMemory {}

    impl ForciblyPurgeJavaScriptMemory {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ForciblyPurgeJavaScriptMemory {
        type Response = ();
        const METHOD: &'static str = "Memory.forciblyPurgeJavaScriptMemory";
    }

    /// Enable/disable suppressing memory pressure notifications in all processes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPressureNotificationsSuppressed {
        /// If true, memory pressure notifications will be suppressed.
        suppressed: bool,
    }

    impl SetPressureNotificationsSuppressed {
        pub fn new(suppressed: impl Into<bool>) -> Self {
            Self {
                suppressed: suppressed.into(),
            }
        }
    }

    impl Command for SetPressureNotificationsSuppressed {
        type Response = ();
        const METHOD: &'static str = "Memory.setPressureNotificationsSuppressed";
    }

    /// Simulate a memory pressure notification in all processes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SimulatePressureNotification {
        /// Memory pressure level of the notification.
        level: PressureLevel,
    }

    impl SimulatePressureNotification {
        pub fn new(level: impl Into<PressureLevel>) -> Self {
            Self {
                level: level.into(),
            }
        }
    }

    impl Command for SimulatePressureNotification {
        type Response = ();
        const METHOD: &'static str = "Memory.simulatePressureNotification";
    }

    /// Start collecting native memory profile.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartSampling {
        /// Average number of bytes between samples.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "samplingInterval")]
        sampling_interval: Option<i64>,
        /// Do not randomize intervals between samples.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "suppressRandomness")]
        suppress_randomness: Option<bool>,
    }

    impl StartSampling {
        pub fn new() -> Self {
            Self {
                sampling_interval: None,
                suppress_randomness: None,
            }
        }

        pub fn with_sampling_interval(mut self, sampling_interval: impl Into<i64>) -> Self {
            self.sampling_interval = Some(sampling_interval.into());
            self
        }

        pub fn with_suppress_randomness(mut self, suppress_randomness: impl Into<bool>) -> Self {
            self.suppress_randomness = Some(suppress_randomness.into());
            self
        }
    }

    impl Command for StartSampling {
        type Response = ();
        const METHOD: &'static str = "Memory.startSampling";
    }

    /// Stop collecting native memory profile.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopSampling {}

    impl StopSampling {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopSampling {
        type Response = ();
        const METHOD: &'static str = "Memory.stopSampling";
    }

    /// Retrieve native memory allocations profile collected since renderer process startup.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAllTimeSamplingProfile {}

    impl GetAllTimeSamplingProfile {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetAllTimeSamplingProfile {
        type Response = GetAllTimeSamplingProfileResult;
        const METHOD: &'static str = "Memory.getAllTimeSamplingProfile";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAllTimeSamplingProfileResult {
        pub profile: SamplingProfile,
    }

    /// Retrieve native memory allocations profile collected since browser process startup.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserSamplingProfile {}

    impl GetBrowserSamplingProfile {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetBrowserSamplingProfile {
        type Response = GetBrowserSamplingProfileResult;
        const METHOD: &'static str = "Memory.getBrowserSamplingProfile";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserSamplingProfileResult {
        pub profile: SamplingProfile,
    }

    /// Retrieve native memory allocations profile collected since last `startSampling` call.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSamplingProfile {}

    impl GetSamplingProfile {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetSamplingProfile {
        type Response = GetSamplingProfileResult;
        const METHOD: &'static str = "Memory.getSamplingProfile";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSamplingProfileResult {
        pub profile: SamplingProfile,
    }
}

pub mod network {
    use super::*;

    /// Resource type as it was perceived by the rendering engine.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ResourceType {
        #[serde(rename = "Document")]
        Document,
        #[serde(rename = "Stylesheet")]
        Stylesheet,
        #[serde(rename = "Image")]
        Image,
        #[serde(rename = "Media")]
        Media,
        #[serde(rename = "Font")]
        Font,
        #[serde(rename = "Script")]
        Script,
        #[serde(rename = "TextTrack")]
        TextTrack,
        #[serde(rename = "XHR")]
        Xhr,
        #[serde(rename = "Fetch")]
        Fetch,
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "EventSource")]
        EventSource,
        #[serde(rename = "WebSocket")]
        WebSocket,
        #[serde(rename = "Manifest")]
        Manifest,
        #[serde(rename = "SignedExchange")]
        SignedExchange,
        #[serde(rename = "Ping")]
        Ping,
        #[serde(rename = "CSPViolationReport")]
        CspViolationReport,
        #[serde(rename = "Preflight")]
        Preflight,
        #[serde(rename = "FedCM")]
        FedCm,
        #[serde(rename = "Other")]
        Other,
    }
    impl From<&str> for ResourceType {
        fn from(s: &str) -> Self {
            match s {
                "Document" => Self::Document,
                "Stylesheet" => Self::Stylesheet,
                "Image" => Self::Image,
                "Media" => Self::Media,
                "Font" => Self::Font,
                "Script" => Self::Script,
                "TextTrack" => Self::TextTrack,
                "XHR" => Self::Xhr,
                "Fetch" => Self::Fetch,
                "Prefetch" => Self::Prefetch,
                "EventSource" => Self::EventSource,
                "WebSocket" => Self::WebSocket,
                "Manifest" => Self::Manifest,
                "SignedExchange" => Self::SignedExchange,
                "Ping" => Self::Ping,
                "CSPViolationReport" => Self::CspViolationReport,
                "Preflight" => Self::Preflight,
                "FedCM" => Self::FedCm,
                "Other" => Self::Other,
                _ => Self::Document,
            }
        }
    }
    impl From<String> for ResourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Unique loader identifier.
    pub type LoaderId = String;

    /// Unique network request identifier. Note that this does not identify individual HTTP requests that are part of a network request.
    pub type RequestId = String;

    /// Unique intercepted request identifier.
    pub type InterceptionId = String;

    /// Network level fetch failure reason.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ErrorReason {
        #[serde(rename = "Failed")]
        Failed,
        #[serde(rename = "Aborted")]
        Aborted,
        #[serde(rename = "TimedOut")]
        TimedOut,
        #[serde(rename = "AccessDenied")]
        AccessDenied,
        #[serde(rename = "ConnectionClosed")]
        ConnectionClosed,
        #[serde(rename = "ConnectionReset")]
        ConnectionReset,
        #[serde(rename = "ConnectionRefused")]
        ConnectionRefused,
        #[serde(rename = "ConnectionAborted")]
        ConnectionAborted,
        #[serde(rename = "ConnectionFailed")]
        ConnectionFailed,
        #[serde(rename = "NameNotResolved")]
        NameNotResolved,
        #[serde(rename = "InternetDisconnected")]
        InternetDisconnected,
        #[serde(rename = "AddressUnreachable")]
        AddressUnreachable,
        #[serde(rename = "BlockedByClient")]
        BlockedByClient,
        #[serde(rename = "BlockedByResponse")]
        BlockedByResponse,
    }
    impl From<&str> for ErrorReason {
        fn from(s: &str) -> Self {
            match s {
                "Failed" => Self::Failed,
                "Aborted" => Self::Aborted,
                "TimedOut" => Self::TimedOut,
                "AccessDenied" => Self::AccessDenied,
                "ConnectionClosed" => Self::ConnectionClosed,
                "ConnectionReset" => Self::ConnectionReset,
                "ConnectionRefused" => Self::ConnectionRefused,
                "ConnectionAborted" => Self::ConnectionAborted,
                "ConnectionFailed" => Self::ConnectionFailed,
                "NameNotResolved" => Self::NameNotResolved,
                "InternetDisconnected" => Self::InternetDisconnected,
                "AddressUnreachable" => Self::AddressUnreachable,
                "BlockedByClient" => Self::BlockedByClient,
                "BlockedByResponse" => Self::BlockedByResponse,
                _ => Self::Failed,
            }
        }
    }
    impl From<String> for ErrorReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// UTC time in seconds, counted from January 1, 1970.
    pub type TimeSinceEpoch = f64;

    /// Monotonically increasing time in seconds since an arbitrary point in the past.
    pub type MonotonicTime = f64;

    /// Request / response headers as keys / values of JSON object.
    pub type Headers = serde_json::Value;

    /// The underlying connection technology that the browser is supposedly using.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ConnectionType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "cellular2g")]
        Cellular2g,
        #[serde(rename = "cellular3g")]
        Cellular3g,
        #[serde(rename = "cellular4g")]
        Cellular4g,
        #[serde(rename = "bluetooth")]
        Bluetooth,
        #[serde(rename = "ethernet")]
        Ethernet,
        #[serde(rename = "wifi")]
        Wifi,
        #[serde(rename = "wimax")]
        Wimax,
        #[serde(rename = "other")]
        Other,
    }
    impl From<&str> for ConnectionType {
        fn from(s: &str) -> Self {
            match s {
                "none" => Self::None,
                "cellular2g" => Self::Cellular2g,
                "cellular3g" => Self::Cellular3g,
                "cellular4g" => Self::Cellular4g,
                "bluetooth" => Self::Bluetooth,
                "ethernet" => Self::Ethernet,
                "wifi" => Self::Wifi,
                "wimax" => Self::Wimax,
                "other" => Self::Other,
                _ => Self::None,
            }
        }
    }
    impl From<String> for ConnectionType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Represents the cookie's 'SameSite' status: https://tools.ietf.org/html/draft-west-first-party-cookies
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieSameSite {
        #[serde(rename = "Strict")]
        Strict,
        #[serde(rename = "Lax")]
        Lax,
        #[serde(rename = "None")]
        None,
    }
    impl From<&str> for CookieSameSite {
        fn from(s: &str) -> Self {
            match s {
                "Strict" => Self::Strict,
                "Lax" => Self::Lax,
                "None" => Self::None,
                _ => Self::Strict,
            }
        }
    }
    impl From<String> for CookieSameSite {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Represents the cookie's 'Priority' status: https://tools.ietf.org/html/draft-west-cookie-priority-00
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookiePriority {
        #[serde(rename = "Low")]
        Low,
        #[serde(rename = "Medium")]
        Medium,
        #[serde(rename = "High")]
        High,
    }
    impl From<&str> for CookiePriority {
        fn from(s: &str) -> Self {
            match s {
                "Low" => Self::Low,
                "Medium" => Self::Medium,
                "High" => Self::High,
                _ => Self::Low,
            }
        }
    }
    impl From<String> for CookiePriority {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Represents the source scheme of the origin that originally set the cookie. A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme. This is a temporary ability and it will be removed in the future.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieSourceScheme {
        #[serde(rename = "Unset")]
        Unset,
        #[serde(rename = "NonSecure")]
        NonSecure,
        #[serde(rename = "Secure")]
        Secure,
    }
    impl From<&str> for CookieSourceScheme {
        fn from(s: &str) -> Self {
            match s {
                "Unset" => Self::Unset,
                "NonSecure" => Self::NonSecure,
                "Secure" => Self::Secure,
                _ => Self::Unset,
            }
        }
    }
    impl From<String> for CookieSourceScheme {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Timing information for the request.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResourceTiming {
        /// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime.
        #[serde(rename = "requestTime")]
        pub request_time: f64,
        /// Started resolving proxy.
        #[serde(rename = "proxyStart")]
        pub proxy_start: f64,
        /// Finished resolving proxy.
        #[serde(rename = "proxyEnd")]
        pub proxy_end: f64,
        /// Started DNS address resolve.
        #[serde(rename = "dnsStart")]
        pub dns_start: f64,
        /// Finished DNS address resolve.
        #[serde(rename = "dnsEnd")]
        pub dns_end: f64,
        /// Started connecting to the remote host.
        #[serde(rename = "connectStart")]
        pub connect_start: f64,
        /// Connected to the remote host.
        #[serde(rename = "connectEnd")]
        pub connect_end: f64,
        /// Started SSL handshake.
        #[serde(rename = "sslStart")]
        pub ssl_start: f64,
        /// Finished SSL handshake.
        #[serde(rename = "sslEnd")]
        pub ssl_end: f64,
        /// Started running ServiceWorker.
        /// **EXPERIMENTAL**
        #[serde(rename = "workerStart")]
        pub worker_start: f64,
        /// Finished Starting ServiceWorker.
        /// **EXPERIMENTAL**
        #[serde(rename = "workerReady")]
        pub worker_ready: f64,
        /// Started fetch event.
        /// **EXPERIMENTAL**
        #[serde(rename = "workerFetchStart")]
        pub worker_fetch_start: f64,
        /// Settled fetch event respondWith promise.
        /// **EXPERIMENTAL**
        #[serde(rename = "workerRespondWithSettled")]
        pub worker_respond_with_settled: f64,
        /// Started ServiceWorker static routing source evaluation.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workerRouterEvaluationStart")]
        pub worker_router_evaluation_start: Option<f64>,
        /// Started cache lookup when the source was evaluated to `cache`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workerCacheLookupStart")]
        pub worker_cache_lookup_start: Option<f64>,
        /// Started sending request.
        #[serde(rename = "sendStart")]
        pub send_start: f64,
        /// Finished sending request.
        #[serde(rename = "sendEnd")]
        pub send_end: f64,
        /// Time the server started pushing request.
        /// **EXPERIMENTAL**
        #[serde(rename = "pushStart")]
        pub push_start: f64,
        /// Time the server finished pushing request.
        /// **EXPERIMENTAL**
        #[serde(rename = "pushEnd")]
        pub push_end: f64,
        /// Started receiving response headers.
        /// **EXPERIMENTAL**
        #[serde(rename = "receiveHeadersStart")]
        pub receive_headers_start: f64,
        /// Finished receiving response headers.
        #[serde(rename = "receiveHeadersEnd")]
        pub receive_headers_end: f64,
    }

    /// Loading priority of a resource request.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ResourcePriority {
        #[serde(rename = "VeryLow")]
        VeryLow,
        #[serde(rename = "Low")]
        Low,
        #[serde(rename = "Medium")]
        Medium,
        #[serde(rename = "High")]
        High,
        #[serde(rename = "VeryHigh")]
        VeryHigh,
    }
    impl From<&str> for ResourcePriority {
        fn from(s: &str) -> Self {
            match s {
                "VeryLow" => Self::VeryLow,
                "Low" => Self::Low,
                "Medium" => Self::Medium,
                "High" => Self::High,
                "VeryHigh" => Self::VeryHigh,
                _ => Self::VeryLow,
            }
        }
    }
    impl From<String> for ResourcePriority {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The render blocking behavior of a resource request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum RenderBlockingBehavior {
        #[serde(rename = "Blocking")]
        Blocking,
        #[serde(rename = "InBodyParserBlocking")]
        InBodyParserBlocking,
        #[serde(rename = "NonBlocking")]
        NonBlocking,
        #[serde(rename = "NonBlockingDynamic")]
        NonBlockingDynamic,
        #[serde(rename = "PotentiallyBlocking")]
        PotentiallyBlocking,
    }
    impl From<&str> for RenderBlockingBehavior {
        fn from(s: &str) -> Self {
            match s {
                "Blocking" => Self::Blocking,
                "InBodyParserBlocking" => Self::InBodyParserBlocking,
                "NonBlocking" => Self::NonBlocking,
                "NonBlockingDynamic" => Self::NonBlockingDynamic,
                "PotentiallyBlocking" => Self::PotentiallyBlocking,
                _ => Self::Blocking,
            }
        }
    }
    impl From<String> for RenderBlockingBehavior {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Post data entry for HTTP request
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PostDataEntry {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub bytes: Option<String>,
    }

    /// HTTP request data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Request {
        /// Request URL (without fragment).
        pub url: String,
        /// Fragment of the requested URL starting with hash, if present.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlFragment")]
        pub url_fragment: Option<String>,
        /// HTTP request method.
        pub method: String,
        /// HTTP request headers.
        pub headers: Headers,
        /// HTTP POST request data. Use postDataEntries instead.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "postData")]
        pub post_data: Option<String>,
        /// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasPostData")]
        pub has_post_data: Option<bool>,
        /// Request body elements (post data broken into individual entries).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "postDataEntries")]
        pub post_data_entries: Option<Vec<PostDataEntry>>,
        /// The mixed content type of the request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "mixedContentType")]
        pub mixed_content_type: Option<security::MixedContentType>,
        /// Priority of the resource request at the time request is sent.
        #[serde(rename = "initialPriority")]
        pub initial_priority: ResourcePriority,
        /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
        #[serde(rename = "referrerPolicy")]
        pub referrer_policy: String,
        /// Whether is loaded via link preload.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isLinkPreload")]
        pub is_link_preload: Option<bool>,
        /// Set for requests when the TrustToken API is used. Contains the parameters passed by the developer (e.g. via "fetch") as understood by the backend.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "trustTokenParams")]
        pub trust_token_params: Option<TrustTokenParams>,
        /// True if this resource request is considered to be the 'same site' as the request corresponding to the main frame.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isSameSite")]
        pub is_same_site: Option<bool>,
        /// True when the resource request is ad-related.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isAdRelated")]
        pub is_ad_related: Option<bool>,
    }

    /// Details of a signed certificate timestamp (SCT).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedCertificateTimestamp {
        /// Validation status.
        pub status: String,
        /// Origin.
        pub origin: String,
        /// Log name / description.
        #[serde(rename = "logDescription")]
        pub log_description: String,
        /// Log ID.
        #[serde(rename = "logId")]
        pub log_id: String,
        /// Issuance date. Unlike TimeSinceEpoch, this contains the number of milliseconds since January 1, 1970, UTC, not the number of seconds.
        pub timestamp: f64,
        /// Hash algorithm.
        #[serde(rename = "hashAlgorithm")]
        pub hash_algorithm: String,
        /// Signature algorithm.
        #[serde(rename = "signatureAlgorithm")]
        pub signature_algorithm: String,
        /// Signature data.
        #[serde(rename = "signatureData")]
        pub signature_data: String,
    }

    /// Security details about a request.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SecurityDetails {
        /// Protocol name (e.g. "TLS 1.2" or "QUIC").
        pub protocol: String,
        /// Key Exchange used by the connection, or the empty string if not applicable.
        #[serde(rename = "keyExchange")]
        pub key_exchange: String,
        /// (EC)DH group used by the connection, if applicable.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keyExchangeGroup")]
        pub key_exchange_group: Option<String>,
        /// Cipher name.
        pub cipher: String,
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub mac: Option<String>,
        /// Certificate ID value.
        #[serde(rename = "certificateId")]
        pub certificate_id: security::CertificateId,
        /// Certificate subject name.
        #[serde(rename = "subjectName")]
        pub subject_name: String,
        /// Subject Alternative Name (SAN) DNS names and IP addresses.
        #[serde(rename = "sanList")]
        pub san_list: Vec<String>,
        /// Name of the issuing CA.
        pub issuer: String,
        /// Certificate valid from date.
        #[serde(rename = "validFrom")]
        pub valid_from: TimeSinceEpoch,
        /// Certificate valid to (expiration) date
        #[serde(rename = "validTo")]
        pub valid_to: TimeSinceEpoch,
        /// List of signed certificate timestamps (SCTs).
        #[serde(rename = "signedCertificateTimestampList")]
        pub signed_certificate_timestamp_list: Vec<SignedCertificateTimestamp>,
        /// Whether the request complied with Certificate Transparency policy
        #[serde(rename = "certificateTransparencyCompliance")]
        pub certificate_transparency_compliance: CertificateTransparencyCompliance,
        /// The signature algorithm used by the server in the TLS server signature, represented as a TLS SignatureScheme code point. Omitted if not applicable or not known.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serverSignatureAlgorithm")]
        pub server_signature_algorithm: Option<i64>,
        /// Whether the connection used Encrypted ClientHello
        #[serde(rename = "encryptedClientHello")]
        pub encrypted_client_hello: bool,
    }

    /// Whether the request complied with Certificate Transparency policy.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CertificateTransparencyCompliance {
        #[serde(rename = "unknown")]
        Unknown,
        #[serde(rename = "not-compliant")]
        NotCompliant,
        #[serde(rename = "compliant")]
        Compliant,
    }
    impl From<&str> for CertificateTransparencyCompliance {
        fn from(s: &str) -> Self {
            match s {
                "unknown" => Self::Unknown,
                "not-compliant" => Self::NotCompliant,
                "compliant" => Self::Compliant,
                _ => Self::Unknown,
            }
        }
    }
    impl From<String> for CertificateTransparencyCompliance {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The reason why request was blocked.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum BlockedReason {
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "csp")]
        Csp,
        #[serde(rename = "mixed-content")]
        MixedContent,
        #[serde(rename = "origin")]
        Origin,
        #[serde(rename = "inspector")]
        Inspector,
        #[serde(rename = "integrity")]
        Integrity,
        #[serde(rename = "subresource-filter")]
        SubresourceFilter,
        #[serde(rename = "content-type")]
        ContentType,
        #[serde(rename = "coep-frame-resource-needs-coep-header")]
        CoepFrameResourceNeedsCoepHeader,
        #[serde(rename = "coop-sandboxed-iframe-cannot-navigate-to-coop-page")]
        CoopSandboxedIframeCannotNavigateToCoopPage,
        #[serde(rename = "corp-not-same-origin")]
        CorpNotSameOrigin,
        #[serde(rename = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        #[serde(rename = "corp-not-same-origin-after-defaulted-to-same-origin-by-dip")]
        CorpNotSameOriginAfterDefaultedToSameOriginByDip,
        #[serde(rename = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip")]
        CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip,
        #[serde(rename = "corp-not-same-site")]
        CorpNotSameSite,
        #[serde(rename = "sri-message-signature-mismatch")]
        SriMessageSignatureMismatch,
    }
    impl From<&str> for BlockedReason {
        fn from(s: &str) -> Self {
            match s {
                "other" => Self::Other,
                "csp" => Self::Csp,
                "mixed-content" => Self::MixedContent,
                "origin" => Self::Origin,
                "inspector" => Self::Inspector,
                "integrity" => Self::Integrity,
                "subresource-filter" => Self::SubresourceFilter,
                "content-type" => Self::ContentType,
                "coep-frame-resource-needs-coep-header" => Self::CoepFrameResourceNeedsCoepHeader,
                "coop-sandboxed-iframe-cannot-navigate-to-coop-page" => {
                    Self::CoopSandboxedIframeCannotNavigateToCoopPage
                }
                "corp-not-same-origin" => Self::CorpNotSameOrigin,
                "corp-not-same-origin-after-defaulted-to-same-origin-by-coep" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByCoep
                }
                "corp-not-same-origin-after-defaulted-to-same-origin-by-dip" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByDip
                }
                "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip" => {
                    Self::CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip
                }
                "corp-not-same-site" => Self::CorpNotSameSite,
                "sri-message-signature-mismatch" => Self::SriMessageSignatureMismatch,
                _ => Self::Other,
            }
        }
    }
    impl From<String> for BlockedReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The reason why request was blocked.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CorsError {
        #[serde(rename = "DisallowedByMode")]
        DisallowedByMode,
        #[serde(rename = "InvalidResponse")]
        InvalidResponse,
        #[serde(rename = "WildcardOriginNotAllowed")]
        WildcardOriginNotAllowed,
        #[serde(rename = "MissingAllowOriginHeader")]
        MissingAllowOriginHeader,
        #[serde(rename = "MultipleAllowOriginValues")]
        MultipleAllowOriginValues,
        #[serde(rename = "InvalidAllowOriginValue")]
        InvalidAllowOriginValue,
        #[serde(rename = "AllowOriginMismatch")]
        AllowOriginMismatch,
        #[serde(rename = "InvalidAllowCredentials")]
        InvalidAllowCredentials,
        #[serde(rename = "CorsDisabledScheme")]
        CorsDisabledScheme,
        #[serde(rename = "PreflightInvalidStatus")]
        PreflightInvalidStatus,
        #[serde(rename = "PreflightDisallowedRedirect")]
        PreflightDisallowedRedirect,
        #[serde(rename = "PreflightWildcardOriginNotAllowed")]
        PreflightWildcardOriginNotAllowed,
        #[serde(rename = "PreflightMissingAllowOriginHeader")]
        PreflightMissingAllowOriginHeader,
        #[serde(rename = "PreflightMultipleAllowOriginValues")]
        PreflightMultipleAllowOriginValues,
        #[serde(rename = "PreflightInvalidAllowOriginValue")]
        PreflightInvalidAllowOriginValue,
        #[serde(rename = "PreflightAllowOriginMismatch")]
        PreflightAllowOriginMismatch,
        #[serde(rename = "PreflightInvalidAllowCredentials")]
        PreflightInvalidAllowCredentials,
        #[serde(rename = "PreflightMissingAllowExternal")]
        PreflightMissingAllowExternal,
        #[serde(rename = "PreflightInvalidAllowExternal")]
        PreflightInvalidAllowExternal,
        #[serde(rename = "InvalidAllowMethodsPreflightResponse")]
        InvalidAllowMethodsPreflightResponse,
        #[serde(rename = "InvalidAllowHeadersPreflightResponse")]
        InvalidAllowHeadersPreflightResponse,
        #[serde(rename = "MethodDisallowedByPreflightResponse")]
        MethodDisallowedByPreflightResponse,
        #[serde(rename = "HeaderDisallowedByPreflightResponse")]
        HeaderDisallowedByPreflightResponse,
        #[serde(rename = "RedirectContainsCredentials")]
        RedirectContainsCredentials,
        #[serde(rename = "InsecurePrivateNetwork")]
        InsecurePrivateNetwork,
        #[serde(rename = "InvalidPrivateNetworkAccess")]
        InvalidPrivateNetworkAccess,
        #[serde(rename = "NoCorsRedirectModeNotFollow")]
        NoCorsRedirectModeNotFollow,
        #[serde(rename = "LocalNetworkAccessPermissionDenied")]
        LocalNetworkAccessPermissionDenied,
    }
    impl From<&str> for CorsError {
        fn from(s: &str) -> Self {
            match s {
                "DisallowedByMode" => Self::DisallowedByMode,
                "InvalidResponse" => Self::InvalidResponse,
                "WildcardOriginNotAllowed" => Self::WildcardOriginNotAllowed,
                "MissingAllowOriginHeader" => Self::MissingAllowOriginHeader,
                "MultipleAllowOriginValues" => Self::MultipleAllowOriginValues,
                "InvalidAllowOriginValue" => Self::InvalidAllowOriginValue,
                "AllowOriginMismatch" => Self::AllowOriginMismatch,
                "InvalidAllowCredentials" => Self::InvalidAllowCredentials,
                "CorsDisabledScheme" => Self::CorsDisabledScheme,
                "PreflightInvalidStatus" => Self::PreflightInvalidStatus,
                "PreflightDisallowedRedirect" => Self::PreflightDisallowedRedirect,
                "PreflightWildcardOriginNotAllowed" => Self::PreflightWildcardOriginNotAllowed,
                "PreflightMissingAllowOriginHeader" => Self::PreflightMissingAllowOriginHeader,
                "PreflightMultipleAllowOriginValues" => Self::PreflightMultipleAllowOriginValues,
                "PreflightInvalidAllowOriginValue" => Self::PreflightInvalidAllowOriginValue,
                "PreflightAllowOriginMismatch" => Self::PreflightAllowOriginMismatch,
                "PreflightInvalidAllowCredentials" => Self::PreflightInvalidAllowCredentials,
                "PreflightMissingAllowExternal" => Self::PreflightMissingAllowExternal,
                "PreflightInvalidAllowExternal" => Self::PreflightInvalidAllowExternal,
                "InvalidAllowMethodsPreflightResponse" => {
                    Self::InvalidAllowMethodsPreflightResponse
                }
                "InvalidAllowHeadersPreflightResponse" => {
                    Self::InvalidAllowHeadersPreflightResponse
                }
                "MethodDisallowedByPreflightResponse" => Self::MethodDisallowedByPreflightResponse,
                "HeaderDisallowedByPreflightResponse" => Self::HeaderDisallowedByPreflightResponse,
                "RedirectContainsCredentials" => Self::RedirectContainsCredentials,
                "InsecurePrivateNetwork" => Self::InsecurePrivateNetwork,
                "InvalidPrivateNetworkAccess" => Self::InvalidPrivateNetworkAccess,
                "NoCorsRedirectModeNotFollow" => Self::NoCorsRedirectModeNotFollow,
                "LocalNetworkAccessPermissionDenied" => Self::LocalNetworkAccessPermissionDenied,
                _ => Self::DisallowedByMode,
            }
        }
    }
    impl From<String> for CorsError {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CorsErrorStatus {
        #[serde(rename = "corsError")]
        pub cors_error: CorsError,
        #[serde(rename = "failedParameter")]
        pub failed_parameter: String,
    }

    /// Source of serviceworker response.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ServiceWorkerResponseSource {
        #[serde(rename = "cache-storage")]
        CacheStorage,
        #[serde(rename = "http-cache")]
        HttpCache,
        #[serde(rename = "fallback-code")]
        FallbackCode,
        #[serde(rename = "network")]
        Network,
    }
    impl From<&str> for ServiceWorkerResponseSource {
        fn from(s: &str) -> Self {
            match s {
                "cache-storage" => Self::CacheStorage,
                "http-cache" => Self::HttpCache,
                "fallback-code" => Self::FallbackCode,
                "network" => Self::Network,
                _ => Self::CacheStorage,
            }
        }
    }
    impl From<String> for ServiceWorkerResponseSource {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Determines what type of Trust Token operation is executed and depending on the type, some additional parameters. The values are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrustTokenParams {
        pub operation: TrustTokenOperationType,
        /// Only set for "token-redemption" operation and determine whether to request a fresh SRR or use a still valid cached SRR.
        #[serde(rename = "refreshPolicy")]
        pub refresh_policy: String,
        /// Origins of issuers from whom to request tokens or redemption records.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub issuers: Option<Vec<String>>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum TrustTokenOperationType {
        #[serde(rename = "Issuance")]
        Issuance,
        #[serde(rename = "Redemption")]
        Redemption,
        #[serde(rename = "Signing")]
        Signing,
    }
    impl From<&str> for TrustTokenOperationType {
        fn from(s: &str) -> Self {
            match s {
                "Issuance" => Self::Issuance,
                "Redemption" => Self::Redemption,
                "Signing" => Self::Signing,
                _ => Self::Issuance,
            }
        }
    }
    impl From<String> for TrustTokenOperationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The reason why Chrome uses a specific transport protocol for HTTP semantics.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AlternateProtocolUsage {
        #[serde(rename = "alternativeJobWonWithoutRace")]
        AlternativeJobWonWithoutRace,
        #[serde(rename = "alternativeJobWonRace")]
        AlternativeJobWonRace,
        #[serde(rename = "mainJobWonRace")]
        MainJobWonRace,
        #[serde(rename = "mappingMissing")]
        MappingMissing,
        #[serde(rename = "broken")]
        Broken,
        #[serde(rename = "dnsAlpnH3JobWonWithoutRace")]
        DnsAlpnH3JobWonWithoutRace,
        #[serde(rename = "dnsAlpnH3JobWonRace")]
        DnsAlpnH3JobWonRace,
        #[serde(rename = "unspecifiedReason")]
        UnspecifiedReason,
    }
    impl From<&str> for AlternateProtocolUsage {
        fn from(s: &str) -> Self {
            match s {
                "alternativeJobWonWithoutRace" => Self::AlternativeJobWonWithoutRace,
                "alternativeJobWonRace" => Self::AlternativeJobWonRace,
                "mainJobWonRace" => Self::MainJobWonRace,
                "mappingMissing" => Self::MappingMissing,
                "broken" => Self::Broken,
                "dnsAlpnH3JobWonWithoutRace" => Self::DnsAlpnH3JobWonWithoutRace,
                "dnsAlpnH3JobWonRace" => Self::DnsAlpnH3JobWonRace,
                "unspecifiedReason" => Self::UnspecifiedReason,
                _ => Self::AlternativeJobWonWithoutRace,
            }
        }
    }
    impl From<String> for AlternateProtocolUsage {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Source of service worker router.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ServiceWorkerRouterSource {
        #[serde(rename = "network")]
        Network,
        #[serde(rename = "cache")]
        Cache,
        #[serde(rename = "fetch-event")]
        FetchEvent,
        #[serde(rename = "race-network-and-fetch-handler")]
        RaceNetworkAndFetchHandler,
        #[serde(rename = "race-network-and-cache")]
        RaceNetworkAndCache,
    }
    impl From<&str> for ServiceWorkerRouterSource {
        fn from(s: &str) -> Self {
            match s {
                "network" => Self::Network,
                "cache" => Self::Cache,
                "fetch-event" => Self::FetchEvent,
                "race-network-and-fetch-handler" => Self::RaceNetworkAndFetchHandler,
                "race-network-and-cache" => Self::RaceNetworkAndCache,
                _ => Self::Network,
            }
        }
    }
    impl From<String> for ServiceWorkerRouterSource {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ServiceWorkerRouterInfo {
        /// ID of the rule matched. If there is a matched rule, this field will be set, otherwiser no value will be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ruleIdMatched")]
        pub rule_id_matched: Option<i64>,
        /// The router source of the matched rule. If there is a matched rule, this field will be set, otherwise no value will be set.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "matchedSourceType")]
        pub matched_source_type: Option<ServiceWorkerRouterSource>,
        /// The actual router source used.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "actualSourceType")]
        pub actual_source_type: Option<ServiceWorkerRouterSource>,
    }

    /// HTTP response data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Response {
        /// Response URL. This URL can be different from CachedResource.url in case of redirect.
        pub url: String,
        /// HTTP response status code.
        pub status: i64,
        /// HTTP response status text.
        #[serde(rename = "statusText")]
        pub status_text: String,
        /// HTTP response headers.
        pub headers: Headers,
        /// HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        /// Resource mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        /// Resource charset as determined by the browser (if applicable).
        pub charset: String,
        /// Refined HTTP request headers that were actually transmitted over the network.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestHeaders")]
        pub request_headers: Option<Headers>,
        /// HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestHeadersText")]
        pub request_headers_text: Option<String>,
        /// Specifies whether physical connection was actually reused for this request.
        #[serde(rename = "connectionReused")]
        pub connection_reused: bool,
        /// Physical connection id that was actually used for this request.
        #[serde(rename = "connectionId")]
        pub connection_id: f64,
        /// Remote IP address.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remoteIPAddress")]
        pub remote_ip_address: Option<String>,
        /// Remote port.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remotePort")]
        pub remote_port: Option<i64>,
        /// Specifies that the request was served from the disk cache.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromDiskCache")]
        pub from_disk_cache: Option<bool>,
        /// Specifies that the request was served from the ServiceWorker.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromServiceWorker")]
        pub from_service_worker: Option<bool>,
        /// Specifies that the request was served from the prefetch cache.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromPrefetchCache")]
        pub from_prefetch_cache: Option<bool>,
        /// Specifies that the request was served from the prefetch cache.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromEarlyHints")]
        pub from_early_hints: Option<bool>,
        /// Information about how ServiceWorker Static Router API was used. If this field is set with `matchedSourceType` field, a matching rule is found. If this field is set without `matchedSource`, no matching rule is found. Otherwise, the API is not used.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serviceWorkerRouterInfo")]
        pub service_worker_router_info: Option<ServiceWorkerRouterInfo>,
        /// Total number of bytes received for this request so far.
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: f64,
        /// Timing information for the given request.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub timing: Option<ResourceTiming>,
        /// Response source of response from ServiceWorker.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serviceWorkerResponseSource")]
        pub service_worker_response_source: Option<ServiceWorkerResponseSource>,
        /// The time at which the returned response was generated.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "responseTime")]
        pub response_time: Option<TimeSinceEpoch>,
        /// Cache Storage Cache Name.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cacheStorageCacheName")]
        pub cache_storage_cache_name: Option<String>,
        /// Protocol used to fetch this request.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub protocol: Option<String>,
        /// The reason why Chrome uses a specific transport protocol for HTTP semantics.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "alternateProtocolUsage")]
        pub alternate_protocol_usage: Option<AlternateProtocolUsage>,
        /// Security state of the request resource.
        #[serde(rename = "securityState")]
        pub security_state: security::SecurityState,
        /// Security details for the request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityDetails")]
        pub security_details: Option<SecurityDetails>,
    }

    /// WebSocket request data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketRequest {
        /// HTTP request headers.
        pub headers: Headers,
    }

    /// WebSocket response data.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketResponse {
        /// HTTP response status code.
        pub status: i64,
        /// HTTP response status text.
        #[serde(rename = "statusText")]
        pub status_text: String,
        /// HTTP response headers.
        pub headers: Headers,
        /// HTTP response headers text.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        /// HTTP request headers.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestHeaders")]
        pub request_headers: Option<Headers>,
        /// HTTP request headers text.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestHeadersText")]
        pub request_headers_text: Option<String>,
    }

    /// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketFrame {
        /// WebSocket message opcode.
        pub opcode: f64,
        /// WebSocket message mask.
        pub mask: bool,
        /// WebSocket message payload data. If the opcode is 1, this is a text message and payloadData is a UTF-8 string. If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
        #[serde(rename = "payloadData")]
        pub payload_data: String,
    }

    /// Information about the cached resource.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CachedResource {
        /// Resource URL. This is the url of the original network request.
        pub url: String,
        /// Type of this resource.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        /// Cached response data.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub response: Option<Response>,
        /// Cached response body size.
        #[serde(rename = "bodySize")]
        pub body_size: f64,
    }

    /// Information about the request initiator.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Initiator {
        /// Type of this initiator.
        #[serde(rename = "type")]
        pub type_: String,
        /// Initiator JavaScript stack trace, set for Script only. Requires the Debugger domain to be enabled.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub stack: Option<runtime::StackTrace>,
        /// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// Initiator line number, set for Parser type or for Script type (when script is importing module) (0-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lineNumber")]
        pub line_number: Option<f64>,
        /// Initiator column number, set for Parser type or for Script type (when script is importing module) (0-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnNumber")]
        pub column_number: Option<f64>,
        /// Set if another request triggered this request (e.g. preflight).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestId")]
        pub request_id: Option<RequestId>,
    }

    /// cookiePartitionKey object The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CookiePartitionKey {
        /// The site of the top-level URL the browser was visiting at the start of the request to the endpoint that set the cookie.
        #[serde(rename = "topLevelSite")]
        pub top_level_site: String,
        /// Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
        #[serde(rename = "hasCrossSiteAncestor")]
        pub has_cross_site_ancestor: bool,
    }

    /// Cookie object
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Cookie {
        /// Cookie name.
        pub name: String,
        /// Cookie value.
        pub value: String,
        /// Cookie domain.
        pub domain: String,
        /// Cookie path.
        pub path: String,
        /// Cookie expiration date as the number of seconds since the UNIX epoch. The value is set to -1 if the expiry date is not set. The value can be null for values that cannot be represented in JSON (Inf).
        pub expires: f64,
        /// Cookie size.
        pub size: i64,
        /// True if cookie is http-only.
        #[serde(rename = "httpOnly")]
        pub http_only: bool,
        /// True if cookie is secure.
        pub secure: bool,
        /// True in case of session cookie.
        pub session: bool,
        /// Cookie SameSite type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
        /// Cookie Priority
        /// **EXPERIMENTAL**
        pub priority: CookiePriority,
        /// Cookie source scheme type.
        /// **EXPERIMENTAL**
        #[serde(rename = "sourceScheme")]
        pub source_scheme: CookieSourceScheme,
        /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.
        /// **EXPERIMENTAL**
        #[serde(rename = "sourcePort")]
        pub source_port: i64,
        /// Cookie partition key.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitionKey")]
        pub partition_key: Option<CookiePartitionKey>,
        /// True if cookie partition key is opaque.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitionKeyOpaque")]
        pub partition_key_opaque: Option<bool>,
    }

    /// Types of reasons why a cookie may not be stored from a response.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SetCookieBlockedReason {
        #[serde(rename = "SecureOnly")]
        SecureOnly,
        #[serde(rename = "SameSiteStrict")]
        SameSiteStrict,
        #[serde(rename = "SameSiteLax")]
        SameSiteLax,
        #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        #[serde(rename = "UserPreferences")]
        UserPreferences,
        #[serde(rename = "ThirdPartyPhaseout")]
        ThirdPartyPhaseout,
        #[serde(rename = "ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        #[serde(rename = "SyntaxError")]
        SyntaxError,
        #[serde(rename = "SchemeNotSupported")]
        SchemeNotSupported,
        #[serde(rename = "OverwriteSecure")]
        OverwriteSecure,
        #[serde(rename = "InvalidDomain")]
        InvalidDomain,
        #[serde(rename = "InvalidPrefix")]
        InvalidPrefix,
        #[serde(rename = "UnknownError")]
        UnknownError,
        #[serde(rename = "SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        #[serde(rename = "SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize,
        #[serde(rename = "DisallowedCharacter")]
        DisallowedCharacter,
        #[serde(rename = "NoCookieContent")]
        NoCookieContent,
    }
    impl From<&str> for SetCookieBlockedReason {
        fn from(s: &str) -> Self {
            match s {
                "SecureOnly" => Self::SecureOnly,
                "SameSiteStrict" => Self::SameSiteStrict,
                "SameSiteLax" => Self::SameSiteLax,
                "SameSiteUnspecifiedTreatedAsLax" => Self::SameSiteUnspecifiedTreatedAsLax,
                "SameSiteNoneInsecure" => Self::SameSiteNoneInsecure,
                "UserPreferences" => Self::UserPreferences,
                "ThirdPartyPhaseout" => Self::ThirdPartyPhaseout,
                "ThirdPartyBlockedInFirstPartySet" => Self::ThirdPartyBlockedInFirstPartySet,
                "SyntaxError" => Self::SyntaxError,
                "SchemeNotSupported" => Self::SchemeNotSupported,
                "OverwriteSecure" => Self::OverwriteSecure,
                "InvalidDomain" => Self::InvalidDomain,
                "InvalidPrefix" => Self::InvalidPrefix,
                "UnknownError" => Self::UnknownError,
                "SchemefulSameSiteStrict" => Self::SchemefulSameSiteStrict,
                "SchemefulSameSiteLax" => Self::SchemefulSameSiteLax,
                "SchemefulSameSiteUnspecifiedTreatedAsLax" => {
                    Self::SchemefulSameSiteUnspecifiedTreatedAsLax
                }
                "NameValuePairExceedsMaxSize" => Self::NameValuePairExceedsMaxSize,
                "DisallowedCharacter" => Self::DisallowedCharacter,
                "NoCookieContent" => Self::NoCookieContent,
                _ => Self::SecureOnly,
            }
        }
    }
    impl From<String> for SetCookieBlockedReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Types of reasons why a cookie may not be sent with a request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieBlockedReason {
        #[serde(rename = "SecureOnly")]
        SecureOnly,
        #[serde(rename = "NotOnPath")]
        NotOnPath,
        #[serde(rename = "DomainMismatch")]
        DomainMismatch,
        #[serde(rename = "SameSiteStrict")]
        SameSiteStrict,
        #[serde(rename = "SameSiteLax")]
        SameSiteLax,
        #[serde(rename = "SameSiteUnspecifiedTreatedAsLax")]
        SameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "SameSiteNoneInsecure")]
        SameSiteNoneInsecure,
        #[serde(rename = "UserPreferences")]
        UserPreferences,
        #[serde(rename = "ThirdPartyPhaseout")]
        ThirdPartyPhaseout,
        #[serde(rename = "ThirdPartyBlockedInFirstPartySet")]
        ThirdPartyBlockedInFirstPartySet,
        #[serde(rename = "UnknownError")]
        UnknownError,
        #[serde(rename = "SchemefulSameSiteStrict")]
        SchemefulSameSiteStrict,
        #[serde(rename = "SchemefulSameSiteLax")]
        SchemefulSameSiteLax,
        #[serde(rename = "SchemefulSameSiteUnspecifiedTreatedAsLax")]
        SchemefulSameSiteUnspecifiedTreatedAsLax,
        #[serde(rename = "NameValuePairExceedsMaxSize")]
        NameValuePairExceedsMaxSize,
        #[serde(rename = "PortMismatch")]
        PortMismatch,
        #[serde(rename = "SchemeMismatch")]
        SchemeMismatch,
        #[serde(rename = "AnonymousContext")]
        AnonymousContext,
    }
    impl From<&str> for CookieBlockedReason {
        fn from(s: &str) -> Self {
            match s {
                "SecureOnly" => Self::SecureOnly,
                "NotOnPath" => Self::NotOnPath,
                "DomainMismatch" => Self::DomainMismatch,
                "SameSiteStrict" => Self::SameSiteStrict,
                "SameSiteLax" => Self::SameSiteLax,
                "SameSiteUnspecifiedTreatedAsLax" => Self::SameSiteUnspecifiedTreatedAsLax,
                "SameSiteNoneInsecure" => Self::SameSiteNoneInsecure,
                "UserPreferences" => Self::UserPreferences,
                "ThirdPartyPhaseout" => Self::ThirdPartyPhaseout,
                "ThirdPartyBlockedInFirstPartySet" => Self::ThirdPartyBlockedInFirstPartySet,
                "UnknownError" => Self::UnknownError,
                "SchemefulSameSiteStrict" => Self::SchemefulSameSiteStrict,
                "SchemefulSameSiteLax" => Self::SchemefulSameSiteLax,
                "SchemefulSameSiteUnspecifiedTreatedAsLax" => {
                    Self::SchemefulSameSiteUnspecifiedTreatedAsLax
                }
                "NameValuePairExceedsMaxSize" => Self::NameValuePairExceedsMaxSize,
                "PortMismatch" => Self::PortMismatch,
                "SchemeMismatch" => Self::SchemeMismatch,
                "AnonymousContext" => Self::AnonymousContext,
                _ => Self::SecureOnly,
            }
        }
    }
    impl From<String> for CookieBlockedReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CookieExemptionReason {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "UserSetting")]
        UserSetting,
        #[serde(rename = "TPCDMetadata")]
        TpcdMetadata,
        #[serde(rename = "TPCDDeprecationTrial")]
        TpcdDeprecationTrial,
        #[serde(rename = "TopLevelTPCDDeprecationTrial")]
        TopLevelTpcdDeprecationTrial,
        #[serde(rename = "TPCDHeuristics")]
        TpcdHeuristics,
        #[serde(rename = "EnterprisePolicy")]
        EnterprisePolicy,
        #[serde(rename = "StorageAccess")]
        StorageAccess,
        #[serde(rename = "TopLevelStorageAccess")]
        TopLevelStorageAccess,
        #[serde(rename = "Scheme")]
        Scheme,
        #[serde(rename = "SameSiteNoneCookiesInSandbox")]
        SameSiteNoneCookiesInSandbox,
    }
    impl From<&str> for CookieExemptionReason {
        fn from(s: &str) -> Self {
            match s {
                "None" => Self::None,
                "UserSetting" => Self::UserSetting,
                "TPCDMetadata" => Self::TpcdMetadata,
                "TPCDDeprecationTrial" => Self::TpcdDeprecationTrial,
                "TopLevelTPCDDeprecationTrial" => Self::TopLevelTpcdDeprecationTrial,
                "TPCDHeuristics" => Self::TpcdHeuristics,
                "EnterprisePolicy" => Self::EnterprisePolicy,
                "StorageAccess" => Self::StorageAccess,
                "TopLevelStorageAccess" => Self::TopLevelStorageAccess,
                "Scheme" => Self::Scheme,
                "SameSiteNoneCookiesInSandbox" => Self::SameSiteNoneCookiesInSandbox,
                _ => Self::None,
            }
        }
    }
    impl From<String> for CookieExemptionReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A cookie which was not stored from a response with the corresponding reason.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BlockedSetCookieWithReason {
        /// The reason(s) this cookie was blocked.
        #[serde(rename = "blockedReasons")]
        pub blocked_reasons: Vec<SetCookieBlockedReason>,
        /// The string representing this individual cookie as it would appear in the header. This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
        #[serde(rename = "cookieLine")]
        pub cookie_line: String,
        /// The cookie object which represents the cookie which was not stored. It is optional because sometimes complete cookie information is not available, such as in the case of parsing errors.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub cookie: Option<Cookie>,
    }

    /// A cookie should have been blocked by 3PCD but is exempted and stored from a response with the corresponding reason. A cookie could only have at most one exemption reason.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExemptedSetCookieWithReason {
        /// The reason the cookie was exempted.
        #[serde(rename = "exemptionReason")]
        pub exemption_reason: CookieExemptionReason,
        /// The string representing this individual cookie as it would appear in the header.
        #[serde(rename = "cookieLine")]
        pub cookie_line: String,
        /// The cookie object representing the cookie.
        pub cookie: Cookie,
    }

    /// A cookie associated with the request which may or may not be sent with it. Includes the cookies itself and reasons for blocking or exemption.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AssociatedCookie {
        /// The cookie object representing the cookie which was not sent.
        pub cookie: Cookie,
        /// The reason(s) the cookie was blocked. If empty means the cookie is included.
        #[serde(rename = "blockedReasons")]
        pub blocked_reasons: Vec<CookieBlockedReason>,
        /// The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could only have at most one exemption reason.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "exemptionReason")]
        pub exemption_reason: Option<CookieExemptionReason>,
    }

    /// Cookie parameter object
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CookieParam {
        /// Cookie name.
        pub name: String,
        /// Cookie value.
        pub value: String,
        /// The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// Cookie domain.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub domain: Option<String>,
        /// Cookie path.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub path: Option<String>,
        /// True if cookie is secure.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub secure: Option<bool>,
        /// True if cookie is http-only.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "httpOnly")]
        pub http_only: Option<bool>,
        /// Cookie SameSite type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
        /// Cookie expiration date, session cookie if not set
        #[serde(skip_serializing_if = "Option::is_none")]
        pub expires: Option<TimeSinceEpoch>,
        /// Cookie Priority.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub priority: Option<CookiePriority>,
        /// Cookie source scheme type.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceScheme")]
        pub source_scheme: Option<CookieSourceScheme>,
        /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourcePort")]
        pub source_port: Option<i64>,
        /// Cookie partition key. If not set, the cookie will be set as not partitioned.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitionKey")]
        pub partition_key: Option<CookiePartitionKey>,
    }

    /// Authorization challenge for HTTP status code 401 or 407.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AuthChallenge {
        /// Source of the authentication challenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub source: Option<String>,
        /// Origin of the challenger.
        pub origin: String,
        /// The authentication scheme used, such as basic or digest
        pub scheme: String,
        /// The realm of the challenge. May be empty.
        pub realm: String,
    }

    /// Response to an AuthChallenge.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AuthChallengeResponse {
        /// The decision on what to do in response to the authorization challenge. Default means deferring to the default behavior of the net stack, which will likely either the Cancel authentication or display a popup dialog box.
        pub response: String,
        /// The username to provide, possibly empty. Should only be set if response is ProvideCredentials.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub username: Option<String>,
        /// The password to provide, possibly empty. Should only be set if response is ProvideCredentials.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub password: Option<String>,
    }

    /// Stages of the interception to begin intercepting. Request will intercept before the request is sent. Response will intercept after the response is received.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InterceptionStage {
        #[serde(rename = "Request")]
        Request,
        #[serde(rename = "HeadersReceived")]
        HeadersReceived,
    }
    impl From<&str> for InterceptionStage {
        fn from(s: &str) -> Self {
            match s {
                "Request" => Self::Request,
                "HeadersReceived" => Self::HeadersReceived,
                _ => Self::Request,
            }
        }
    }
    impl From<String> for InterceptionStage {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Request pattern for interception.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestPattern {
        /// Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is backslash. Omitting is equivalent to `"*"`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlPattern")]
        pub url_pattern: Option<String>,
        /// If set, only requests for matching resource types will be intercepted.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resourceType")]
        pub resource_type: Option<ResourceType>,
        /// Stage at which to begin intercepting requests. Default is Request.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "interceptionStage")]
        pub interception_stage: Option<InterceptionStage>,
    }

    /// Information about a signed exchange signature. https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedExchangeSignature {
        /// Signed exchange signature label.
        pub label: String,
        /// The hex string of signed exchange signature.
        pub signature: String,
        /// Signed exchange signature integrity.
        pub integrity: String,
        /// Signed exchange signature cert Url.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "certUrl")]
        pub cert_url: Option<String>,
        /// The hex string of signed exchange signature cert sha256.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "certSha256")]
        pub cert_sha256: Option<String>,
        /// Signed exchange signature validity Url.
        #[serde(rename = "validityUrl")]
        pub validity_url: String,
        /// Signed exchange signature date.
        pub date: i64,
        /// Signed exchange signature expires.
        pub expires: i64,
        /// The encoded certificates.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub certificates: Option<Vec<String>>,
    }

    /// Information about a signed exchange header. https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedExchangeHeader {
        /// Signed exchange request URL.
        #[serde(rename = "requestUrl")]
        pub request_url: String,
        /// Signed exchange response code.
        #[serde(rename = "responseCode")]
        pub response_code: i64,
        /// Signed exchange response headers.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Headers,
        /// Signed exchange response signature.
        pub signatures: Vec<SignedExchangeSignature>,
        /// Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
        #[serde(rename = "headerIntegrity")]
        pub header_integrity: String,
    }

    /// Field type for a signed exchange related error.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SignedExchangeErrorField {
        #[serde(rename = "signatureSig")]
        SignatureSig,
        #[serde(rename = "signatureIntegrity")]
        SignatureIntegrity,
        #[serde(rename = "signatureCertUrl")]
        SignatureCertUrl,
        #[serde(rename = "signatureCertSha256")]
        SignatureCertSha256,
        #[serde(rename = "signatureValidityUrl")]
        SignatureValidityUrl,
        #[serde(rename = "signatureTimestamps")]
        SignatureTimestamps,
    }
    impl From<&str> for SignedExchangeErrorField {
        fn from(s: &str) -> Self {
            match s {
                "signatureSig" => Self::SignatureSig,
                "signatureIntegrity" => Self::SignatureIntegrity,
                "signatureCertUrl" => Self::SignatureCertUrl,
                "signatureCertSha256" => Self::SignatureCertSha256,
                "signatureValidityUrl" => Self::SignatureValidityUrl,
                "signatureTimestamps" => Self::SignatureTimestamps,
                _ => Self::SignatureSig,
            }
        }
    }
    impl From<String> for SignedExchangeErrorField {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Information about a signed exchange response.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedExchangeError {
        /// Error message.
        pub message: String,
        /// The index of the signature which caused the error.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "signatureIndex")]
        pub signature_index: Option<i64>,
        /// The field which caused the error.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "errorField")]
        pub error_field: Option<SignedExchangeErrorField>,
    }

    /// Information about a signed exchange response.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedExchangeInfo {
        /// The outer response of signed HTTP exchange which was received from network.
        #[serde(rename = "outerResponse")]
        pub outer_response: Response,
        /// Whether network response for the signed exchange was accompanied by extra headers.
        #[serde(rename = "hasExtraInfo")]
        pub has_extra_info: bool,
        /// Information about the signed exchange header.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub header: Option<SignedExchangeHeader>,
        /// Security details for the signed exchange header.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityDetails")]
        pub security_details: Option<SecurityDetails>,
        /// Errors occurred while handling the signed exchange.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<SignedExchangeError>>,
    }

    /// List of content encodings supported by the backend.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContentEncoding {
        #[serde(rename = "deflate")]
        Deflate,
        #[serde(rename = "gzip")]
        Gzip,
        #[serde(rename = "br")]
        Br,
        #[serde(rename = "zstd")]
        Zstd,
    }
    impl From<&str> for ContentEncoding {
        fn from(s: &str) -> Self {
            match s {
                "deflate" => Self::Deflate,
                "gzip" => Self::Gzip,
                "br" => Self::Br,
                "zstd" => Self::Zstd,
                _ => Self::Deflate,
            }
        }
    }
    impl From<String> for ContentEncoding {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NetworkConditions {
        /// Only matching requests will be affected by these conditions. Patterns use the URLPattern constructor string syntax (https://urlpattern.spec.whatwg.org/) and must be absolute. If the pattern is empty, all requests are matched (including p2p connections).
        #[serde(rename = "urlPattern")]
        pub url_pattern: String,
        /// Minimum latency from request sent to response headers received (ms).
        pub latency: f64,
        /// Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
        #[serde(rename = "downloadThroughput")]
        pub download_throughput: f64,
        /// Maximal aggregated upload throughput (bytes/sec). -1 disables upload throttling.
        #[serde(rename = "uploadThroughput")]
        pub upload_throughput: f64,
        /// Connection type if known.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "connectionType")]
        pub connection_type: Option<ConnectionType>,
        /// WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetLoss")]
        pub packet_loss: Option<f64>,
        /// WebRTC packet queue length (packet). 0 removes any queue length limitations.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetQueueLength")]
        pub packet_queue_length: Option<i64>,
        /// WebRTC packetReordering feature.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetReordering")]
        pub packet_reordering: Option<bool>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BlockPattern {
        /// URL pattern to match. Patterns use the URLPattern constructor string syntax (https://urlpattern.spec.whatwg.org/) and must be absolute. Example: `*://*:*/*.css`.
        #[serde(rename = "urlPattern")]
        pub url_pattern: String,
        /// Whether or not to block the pattern. If false, a matching request will not be blocked even if it matches a later `BlockPattern`.
        pub block: bool,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DirectSocketDnsQueryType {
        #[serde(rename = "ipv4")]
        Ipv4,
        #[serde(rename = "ipv6")]
        Ipv6,
    }
    impl From<&str> for DirectSocketDnsQueryType {
        fn from(s: &str) -> Self {
            match s {
                "ipv4" => Self::Ipv4,
                "ipv6" => Self::Ipv6,
                _ => Self::Ipv4,
            }
        }
    }
    impl From<String> for DirectSocketDnsQueryType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTCPSocketOptions {
        /// TCP_NODELAY option
        #[serde(rename = "noDelay")]
        pub no_delay: bool,
        /// Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keepAliveDelay")]
        pub keep_alive_delay: Option<f64>,
        /// Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sendBufferSize")]
        pub send_buffer_size: Option<f64>,
        /// Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "receiveBufferSize")]
        pub receive_buffer_size: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dnsQueryType")]
        pub dns_query_type: Option<DirectSocketDnsQueryType>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUDPSocketOptions {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remoteAddr")]
        pub remote_addr: Option<String>,
        /// Unsigned int 16.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remotePort")]
        pub remote_port: Option<i64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "localAddr")]
        pub local_addr: Option<String>,
        /// Unsigned int 16.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "localPort")]
        pub local_port: Option<i64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dnsQueryType")]
        pub dns_query_type: Option<DirectSocketDnsQueryType>,
        /// Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sendBufferSize")]
        pub send_buffer_size: Option<f64>,
        /// Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "receiveBufferSize")]
        pub receive_buffer_size: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "multicastLoopback")]
        pub multicast_loopback: Option<bool>,
        /// Unsigned int 8.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "multicastTimeToLive")]
        pub multicast_time_to_live: Option<i64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "multicastAllowAddressSharing")]
        pub multicast_allow_address_sharing: Option<bool>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUDPMessage {
        pub data: String,
        /// Null for connected mode.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remoteAddr")]
        pub remote_addr: Option<String>,
        /// Null for connected mode. Expected to be unsigned integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "remotePort")]
        pub remote_port: Option<i64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LocalNetworkAccessRequestPolicy {
        #[serde(rename = "Allow")]
        Allow,
        #[serde(rename = "BlockFromInsecureToMorePrivate")]
        BlockFromInsecureToMorePrivate,
        #[serde(rename = "WarnFromInsecureToMorePrivate")]
        WarnFromInsecureToMorePrivate,
        #[serde(rename = "PermissionBlock")]
        PermissionBlock,
        #[serde(rename = "PermissionWarn")]
        PermissionWarn,
    }
    impl From<&str> for LocalNetworkAccessRequestPolicy {
        fn from(s: &str) -> Self {
            match s {
                "Allow" => Self::Allow,
                "BlockFromInsecureToMorePrivate" => Self::BlockFromInsecureToMorePrivate,
                "WarnFromInsecureToMorePrivate" => Self::WarnFromInsecureToMorePrivate,
                "PermissionBlock" => Self::PermissionBlock,
                "PermissionWarn" => Self::PermissionWarn,
                _ => Self::Allow,
            }
        }
    }
    impl From<String> for LocalNetworkAccessRequestPolicy {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum IPAddressSpace {
        #[serde(rename = "Loopback")]
        Loopback,
        #[serde(rename = "Local")]
        Local,
        #[serde(rename = "Public")]
        Public,
        #[serde(rename = "Unknown")]
        Unknown,
    }
    impl From<&str> for IPAddressSpace {
        fn from(s: &str) -> Self {
            match s {
                "Loopback" => Self::Loopback,
                "Local" => Self::Local,
                "Public" => Self::Public,
                "Unknown" => Self::Unknown,
                _ => Self::Loopback,
            }
        }
    }
    impl From<String> for IPAddressSpace {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConnectTiming {
        /// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for the same request (but not for redirected requests).
        #[serde(rename = "requestTime")]
        pub request_time: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClientSecurityState {
        #[serde(rename = "initiatorIsSecureContext")]
        pub initiator_is_secure_context: bool,
        #[serde(rename = "initiatorIPAddressSpace")]
        pub initiator_ip_address_space: IPAddressSpace,
        #[serde(rename = "localNetworkAccessRequestPolicy")]
        pub local_network_access_request_policy: LocalNetworkAccessRequestPolicy,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CrossOriginOpenerPolicyValue {
        #[serde(rename = "SameOrigin")]
        SameOrigin,
        #[serde(rename = "SameOriginAllowPopups")]
        SameOriginAllowPopups,
        #[serde(rename = "RestrictProperties")]
        RestrictProperties,
        #[serde(rename = "UnsafeNone")]
        UnsafeNone,
        #[serde(rename = "SameOriginPlusCoep")]
        SameOriginPlusCoep,
        #[serde(rename = "RestrictPropertiesPlusCoep")]
        RestrictPropertiesPlusCoep,
        #[serde(rename = "NoopenerAllowPopups")]
        NoopenerAllowPopups,
    }
    impl From<&str> for CrossOriginOpenerPolicyValue {
        fn from(s: &str) -> Self {
            match s {
                "SameOrigin" => Self::SameOrigin,
                "SameOriginAllowPopups" => Self::SameOriginAllowPopups,
                "RestrictProperties" => Self::RestrictProperties,
                "UnsafeNone" => Self::UnsafeNone,
                "SameOriginPlusCoep" => Self::SameOriginPlusCoep,
                "RestrictPropertiesPlusCoep" => Self::RestrictPropertiesPlusCoep,
                "NoopenerAllowPopups" => Self::NoopenerAllowPopups,
                _ => Self::SameOrigin,
            }
        }
    }
    impl From<String> for CrossOriginOpenerPolicyValue {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CrossOriginOpenerPolicyStatus {
        pub value: CrossOriginOpenerPolicyValue,
        #[serde(rename = "reportOnlyValue")]
        pub report_only_value: CrossOriginOpenerPolicyValue,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportingEndpoint")]
        pub reporting_endpoint: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportOnlyReportingEndpoint")]
        pub report_only_reporting_endpoint: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CrossOriginEmbedderPolicyValue {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "Credentialless")]
        Credentialless,
        #[serde(rename = "RequireCorp")]
        RequireCorp,
    }
    impl From<&str> for CrossOriginEmbedderPolicyValue {
        fn from(s: &str) -> Self {
            match s {
                "None" => Self::None,
                "Credentialless" => Self::Credentialless,
                "RequireCorp" => Self::RequireCorp,
                _ => Self::None,
            }
        }
    }
    impl From<String> for CrossOriginEmbedderPolicyValue {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CrossOriginEmbedderPolicyStatus {
        pub value: CrossOriginEmbedderPolicyValue,
        #[serde(rename = "reportOnlyValue")]
        pub report_only_value: CrossOriginEmbedderPolicyValue,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportingEndpoint")]
        pub reporting_endpoint: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportOnlyReportingEndpoint")]
        pub report_only_reporting_endpoint: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContentSecurityPolicySource {
        #[serde(rename = "HTTP")]
        Http,
        #[serde(rename = "Meta")]
        Meta,
    }
    impl From<&str> for ContentSecurityPolicySource {
        fn from(s: &str) -> Self {
            match s {
                "HTTP" => Self::Http,
                "Meta" => Self::Meta,
                _ => Self::Http,
            }
        }
    }
    impl From<String> for ContentSecurityPolicySource {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContentSecurityPolicyStatus {
        #[serde(rename = "effectiveDirectives")]
        pub effective_directives: String,
        #[serde(rename = "isEnforced")]
        pub is_enforced: bool,
        pub source: ContentSecurityPolicySource,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SecurityIsolationStatus {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub coop: Option<CrossOriginOpenerPolicyStatus>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub coep: Option<CrossOriginEmbedderPolicyStatus>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub csp: Option<Vec<ContentSecurityPolicyStatus>>,
    }

    /// The status of a Reporting API report.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ReportStatus {
        #[serde(rename = "Queued")]
        Queued,
        #[serde(rename = "Pending")]
        Pending,
        #[serde(rename = "MarkedForRemoval")]
        MarkedForRemoval,
        #[serde(rename = "Success")]
        Success,
    }
    impl From<&str> for ReportStatus {
        fn from(s: &str) -> Self {
            match s {
                "Queued" => Self::Queued,
                "Pending" => Self::Pending,
                "MarkedForRemoval" => Self::MarkedForRemoval,
                "Success" => Self::Success,
                _ => Self::Queued,
            }
        }
    }
    impl From<String> for ReportStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type ReportId = String;

    /// An object representing a report generated by the Reporting API.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportingApiReport {
        pub id: ReportId,
        /// The URL of the document that triggered the report.
        #[serde(rename = "initiatorUrl")]
        pub initiator_url: String,
        /// The name of the endpoint group that should be used to deliver the report.
        pub destination: String,
        /// The type of the report (specifies the set of data that is contained in the report body).
        #[serde(rename = "type")]
        pub type_: String,
        /// When the report was generated.
        pub timestamp: network::TimeSinceEpoch,
        /// How many uploads deep the related request was.
        pub depth: i64,
        /// The number of delivery attempts made so far, not including an active attempt.
        #[serde(rename = "completedAttempts")]
        pub completed_attempts: i64,
        pub body: serde_json::Value,
        pub status: ReportStatus,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportingApiEndpoint {
        /// The URL of the endpoint to which reports may be delivered.
        pub url: String,
        /// Name of the endpoint group.
        #[serde(rename = "groupName")]
        pub group_name: String,
    }

    /// Unique identifier for a device bound session.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionKey {
        /// The site the session is set up for.
        pub site: String,
        /// The id of the session.
        pub id: String,
    }

    /// How a device bound session was used during a request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionWithUsage {
        /// The key for the session.
        #[serde(rename = "sessionKey")]
        pub session_key: DeviceBoundSessionKey,
        /// How the session was used (or not used).
        pub usage: String,
    }

    /// A device bound session's cookie craving.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionCookieCraving {
        /// The name of the craving.
        pub name: String,
        /// The domain of the craving.
        pub domain: String,
        /// The path of the craving.
        pub path: String,
        /// The `Secure` attribute of the craving attributes.
        pub secure: bool,
        /// The `HttpOnly` attribute of the craving attributes.
        #[serde(rename = "httpOnly")]
        pub http_only: bool,
        /// The `SameSite` attribute of the craving attributes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sameSite")]
        pub same_site: Option<CookieSameSite>,
    }

    /// A device bound session's inclusion URL rule.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionUrlRule {
        /// See comments on `net::device_bound_sessions::SessionInclusionRules::UrlRule::rule_type`.
        #[serde(rename = "ruleType")]
        pub rule_type: String,
        /// See comments on `net::device_bound_sessions::SessionInclusionRules::UrlRule::host_pattern`.
        #[serde(rename = "hostPattern")]
        pub host_pattern: String,
        /// See comments on `net::device_bound_sessions::SessionInclusionRules::UrlRule::path_prefix`.
        #[serde(rename = "pathPrefix")]
        pub path_prefix: String,
    }

    /// A device bound session's inclusion rules.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionInclusionRules {
        /// See comments on `net::device_bound_sessions::SessionInclusionRules::origin_`.
        pub origin: String,
        /// Whether the whole site is included. See comments on `net::device_bound_sessions::SessionInclusionRules::include_site_` for more details; this boolean is true if that value is populated.
        #[serde(rename = "includeSite")]
        pub include_site: bool,
        /// See comments on `net::device_bound_sessions::SessionInclusionRules::url_rules_`.
        #[serde(rename = "urlRules")]
        pub url_rules: Vec<DeviceBoundSessionUrlRule>,
    }

    /// A device bound session.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSession {
        /// The site and session ID of the session.
        pub key: DeviceBoundSessionKey,
        /// See comments on `net::device_bound_sessions::Session::refresh_url_`.
        #[serde(rename = "refreshUrl")]
        pub refresh_url: String,
        /// See comments on `net::device_bound_sessions::Session::inclusion_rules_`.
        #[serde(rename = "inclusionRules")]
        pub inclusion_rules: DeviceBoundSessionInclusionRules,
        /// See comments on `net::device_bound_sessions::Session::cookie_cravings_`.
        #[serde(rename = "cookieCravings")]
        pub cookie_cravings: Vec<DeviceBoundSessionCookieCraving>,
        /// See comments on `net::device_bound_sessions::Session::expiry_date_`.
        #[serde(rename = "expiryDate")]
        pub expiry_date: network::TimeSinceEpoch,
        /// See comments on `net::device_bound_sessions::Session::cached_challenge__`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cachedChallenge")]
        pub cached_challenge: Option<String>,
        /// See comments on `net::device_bound_sessions::Session::allowed_refresh_initiators_`.
        #[serde(rename = "allowedRefreshInitiators")]
        pub allowed_refresh_initiators: Vec<String>,
    }

    /// A unique identifier for a device bound session event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type DeviceBoundSessionEventId = String;

    /// A fetch result for a device bound session creation or refresh.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DeviceBoundSessionFetchResult {
        #[serde(rename = "Success")]
        Success,
        #[serde(rename = "KeyError")]
        KeyError,
        #[serde(rename = "SigningError")]
        SigningError,
        #[serde(rename = "ServerRequestedTermination")]
        ServerRequestedTermination,
        #[serde(rename = "InvalidSessionId")]
        InvalidSessionId,
        #[serde(rename = "InvalidChallenge")]
        InvalidChallenge,
        #[serde(rename = "TooManyChallenges")]
        TooManyChallenges,
        #[serde(rename = "InvalidFetcherUrl")]
        InvalidFetcherUrl,
        #[serde(rename = "InvalidRefreshUrl")]
        InvalidRefreshUrl,
        #[serde(rename = "TransientHttpError")]
        TransientHttpError,
        #[serde(rename = "ScopeOriginSameSiteMismatch")]
        ScopeOriginSameSiteMismatch,
        #[serde(rename = "RefreshUrlSameSiteMismatch")]
        RefreshUrlSameSiteMismatch,
        #[serde(rename = "MismatchedSessionId")]
        MismatchedSessionId,
        #[serde(rename = "MissingScope")]
        MissingScope,
        #[serde(rename = "NoCredentials")]
        NoCredentials,
        #[serde(rename = "SubdomainRegistrationWellKnownUnavailable")]
        SubdomainRegistrationWellKnownUnavailable,
        #[serde(rename = "SubdomainRegistrationUnauthorized")]
        SubdomainRegistrationUnauthorized,
        #[serde(rename = "SubdomainRegistrationWellKnownMalformed")]
        SubdomainRegistrationWellKnownMalformed,
        #[serde(rename = "SessionProviderWellKnownUnavailable")]
        SessionProviderWellKnownUnavailable,
        #[serde(rename = "RelyingPartyWellKnownUnavailable")]
        RelyingPartyWellKnownUnavailable,
        #[serde(rename = "FederatedKeyThumbprintMismatch")]
        FederatedKeyThumbprintMismatch,
        #[serde(rename = "InvalidFederatedSessionUrl")]
        InvalidFederatedSessionUrl,
        #[serde(rename = "InvalidFederatedKey")]
        InvalidFederatedKey,
        #[serde(rename = "TooManyRelyingOriginLabels")]
        TooManyRelyingOriginLabels,
        #[serde(rename = "BoundCookieSetForbidden")]
        BoundCookieSetForbidden,
        #[serde(rename = "NetError")]
        NetError,
        #[serde(rename = "ProxyError")]
        ProxyError,
        #[serde(rename = "EmptySessionConfig")]
        EmptySessionConfig,
        #[serde(rename = "InvalidCredentialsConfig")]
        InvalidCredentialsConfig,
        #[serde(rename = "InvalidCredentialsType")]
        InvalidCredentialsType,
        #[serde(rename = "InvalidCredentialsEmptyName")]
        InvalidCredentialsEmptyName,
        #[serde(rename = "InvalidCredentialsCookie")]
        InvalidCredentialsCookie,
        #[serde(rename = "PersistentHttpError")]
        PersistentHttpError,
        #[serde(rename = "RegistrationAttemptedChallenge")]
        RegistrationAttemptedChallenge,
        #[serde(rename = "InvalidScopeOrigin")]
        InvalidScopeOrigin,
        #[serde(rename = "ScopeOriginContainsPath")]
        ScopeOriginContainsPath,
        #[serde(rename = "RefreshInitiatorNotString")]
        RefreshInitiatorNotString,
        #[serde(rename = "RefreshInitiatorInvalidHostPattern")]
        RefreshInitiatorInvalidHostPattern,
        #[serde(rename = "InvalidScopeSpecification")]
        InvalidScopeSpecification,
        #[serde(rename = "MissingScopeSpecificationType")]
        MissingScopeSpecificationType,
        #[serde(rename = "EmptyScopeSpecificationDomain")]
        EmptyScopeSpecificationDomain,
        #[serde(rename = "EmptyScopeSpecificationPath")]
        EmptyScopeSpecificationPath,
        #[serde(rename = "InvalidScopeSpecificationType")]
        InvalidScopeSpecificationType,
        #[serde(rename = "InvalidScopeIncludeSite")]
        InvalidScopeIncludeSite,
        #[serde(rename = "MissingScopeIncludeSite")]
        MissingScopeIncludeSite,
        #[serde(rename = "FederatedNotAuthorizedByProvider")]
        FederatedNotAuthorizedByProvider,
        #[serde(rename = "FederatedNotAuthorizedByRelyingParty")]
        FederatedNotAuthorizedByRelyingParty,
        #[serde(rename = "SessionProviderWellKnownMalformed")]
        SessionProviderWellKnownMalformed,
        #[serde(rename = "SessionProviderWellKnownHasProviderOrigin")]
        SessionProviderWellKnownHasProviderOrigin,
        #[serde(rename = "RelyingPartyWellKnownMalformed")]
        RelyingPartyWellKnownMalformed,
        #[serde(rename = "RelyingPartyWellKnownHasRelyingOrigins")]
        RelyingPartyWellKnownHasRelyingOrigins,
        #[serde(rename = "InvalidFederatedSessionProviderSessionMissing")]
        InvalidFederatedSessionProviderSessionMissing,
        #[serde(rename = "InvalidFederatedSessionWrongProviderOrigin")]
        InvalidFederatedSessionWrongProviderOrigin,
        #[serde(rename = "InvalidCredentialsCookieCreationTime")]
        InvalidCredentialsCookieCreationTime,
        #[serde(rename = "InvalidCredentialsCookieName")]
        InvalidCredentialsCookieName,
        #[serde(rename = "InvalidCredentialsCookieParsing")]
        InvalidCredentialsCookieParsing,
        #[serde(rename = "InvalidCredentialsCookieUnpermittedAttribute")]
        InvalidCredentialsCookieUnpermittedAttribute,
        #[serde(rename = "InvalidCredentialsCookieInvalidDomain")]
        InvalidCredentialsCookieInvalidDomain,
        #[serde(rename = "InvalidCredentialsCookiePrefix")]
        InvalidCredentialsCookiePrefix,
        #[serde(rename = "InvalidScopeRulePath")]
        InvalidScopeRulePath,
        #[serde(rename = "InvalidScopeRuleHostPattern")]
        InvalidScopeRuleHostPattern,
        #[serde(rename = "ScopeRuleOriginScopedHostPatternMismatch")]
        ScopeRuleOriginScopedHostPatternMismatch,
        #[serde(rename = "ScopeRuleSiteScopedHostPatternMismatch")]
        ScopeRuleSiteScopedHostPatternMismatch,
        #[serde(rename = "SigningQuotaExceeded")]
        SigningQuotaExceeded,
        #[serde(rename = "InvalidConfigJson")]
        InvalidConfigJson,
        #[serde(rename = "InvalidFederatedSessionProviderFailedToRestoreKey")]
        InvalidFederatedSessionProviderFailedToRestoreKey,
        #[serde(rename = "FailedToUnwrapKey")]
        FailedToUnwrapKey,
        #[serde(rename = "SessionDeletedDuringRefresh")]
        SessionDeletedDuringRefresh,
    }
    impl From<&str> for DeviceBoundSessionFetchResult {
        fn from(s: &str) -> Self {
            match s {
                "Success" => Self::Success,
                "KeyError" => Self::KeyError,
                "SigningError" => Self::SigningError,
                "ServerRequestedTermination" => Self::ServerRequestedTermination,
                "InvalidSessionId" => Self::InvalidSessionId,
                "InvalidChallenge" => Self::InvalidChallenge,
                "TooManyChallenges" => Self::TooManyChallenges,
                "InvalidFetcherUrl" => Self::InvalidFetcherUrl,
                "InvalidRefreshUrl" => Self::InvalidRefreshUrl,
                "TransientHttpError" => Self::TransientHttpError,
                "ScopeOriginSameSiteMismatch" => Self::ScopeOriginSameSiteMismatch,
                "RefreshUrlSameSiteMismatch" => Self::RefreshUrlSameSiteMismatch,
                "MismatchedSessionId" => Self::MismatchedSessionId,
                "MissingScope" => Self::MissingScope,
                "NoCredentials" => Self::NoCredentials,
                "SubdomainRegistrationWellKnownUnavailable" => {
                    Self::SubdomainRegistrationWellKnownUnavailable
                }
                "SubdomainRegistrationUnauthorized" => Self::SubdomainRegistrationUnauthorized,
                "SubdomainRegistrationWellKnownMalformed" => {
                    Self::SubdomainRegistrationWellKnownMalformed
                }
                "SessionProviderWellKnownUnavailable" => Self::SessionProviderWellKnownUnavailable,
                "RelyingPartyWellKnownUnavailable" => Self::RelyingPartyWellKnownUnavailable,
                "FederatedKeyThumbprintMismatch" => Self::FederatedKeyThumbprintMismatch,
                "InvalidFederatedSessionUrl" => Self::InvalidFederatedSessionUrl,
                "InvalidFederatedKey" => Self::InvalidFederatedKey,
                "TooManyRelyingOriginLabels" => Self::TooManyRelyingOriginLabels,
                "BoundCookieSetForbidden" => Self::BoundCookieSetForbidden,
                "NetError" => Self::NetError,
                "ProxyError" => Self::ProxyError,
                "EmptySessionConfig" => Self::EmptySessionConfig,
                "InvalidCredentialsConfig" => Self::InvalidCredentialsConfig,
                "InvalidCredentialsType" => Self::InvalidCredentialsType,
                "InvalidCredentialsEmptyName" => Self::InvalidCredentialsEmptyName,
                "InvalidCredentialsCookie" => Self::InvalidCredentialsCookie,
                "PersistentHttpError" => Self::PersistentHttpError,
                "RegistrationAttemptedChallenge" => Self::RegistrationAttemptedChallenge,
                "InvalidScopeOrigin" => Self::InvalidScopeOrigin,
                "ScopeOriginContainsPath" => Self::ScopeOriginContainsPath,
                "RefreshInitiatorNotString" => Self::RefreshInitiatorNotString,
                "RefreshInitiatorInvalidHostPattern" => Self::RefreshInitiatorInvalidHostPattern,
                "InvalidScopeSpecification" => Self::InvalidScopeSpecification,
                "MissingScopeSpecificationType" => Self::MissingScopeSpecificationType,
                "EmptyScopeSpecificationDomain" => Self::EmptyScopeSpecificationDomain,
                "EmptyScopeSpecificationPath" => Self::EmptyScopeSpecificationPath,
                "InvalidScopeSpecificationType" => Self::InvalidScopeSpecificationType,
                "InvalidScopeIncludeSite" => Self::InvalidScopeIncludeSite,
                "MissingScopeIncludeSite" => Self::MissingScopeIncludeSite,
                "FederatedNotAuthorizedByProvider" => Self::FederatedNotAuthorizedByProvider,
                "FederatedNotAuthorizedByRelyingParty" => {
                    Self::FederatedNotAuthorizedByRelyingParty
                }
                "SessionProviderWellKnownMalformed" => Self::SessionProviderWellKnownMalformed,
                "SessionProviderWellKnownHasProviderOrigin" => {
                    Self::SessionProviderWellKnownHasProviderOrigin
                }
                "RelyingPartyWellKnownMalformed" => Self::RelyingPartyWellKnownMalformed,
                "RelyingPartyWellKnownHasRelyingOrigins" => {
                    Self::RelyingPartyWellKnownHasRelyingOrigins
                }
                "InvalidFederatedSessionProviderSessionMissing" => {
                    Self::InvalidFederatedSessionProviderSessionMissing
                }
                "InvalidFederatedSessionWrongProviderOrigin" => {
                    Self::InvalidFederatedSessionWrongProviderOrigin
                }
                "InvalidCredentialsCookieCreationTime" => {
                    Self::InvalidCredentialsCookieCreationTime
                }
                "InvalidCredentialsCookieName" => Self::InvalidCredentialsCookieName,
                "InvalidCredentialsCookieParsing" => Self::InvalidCredentialsCookieParsing,
                "InvalidCredentialsCookieUnpermittedAttribute" => {
                    Self::InvalidCredentialsCookieUnpermittedAttribute
                }
                "InvalidCredentialsCookieInvalidDomain" => {
                    Self::InvalidCredentialsCookieInvalidDomain
                }
                "InvalidCredentialsCookiePrefix" => Self::InvalidCredentialsCookiePrefix,
                "InvalidScopeRulePath" => Self::InvalidScopeRulePath,
                "InvalidScopeRuleHostPattern" => Self::InvalidScopeRuleHostPattern,
                "ScopeRuleOriginScopedHostPatternMismatch" => {
                    Self::ScopeRuleOriginScopedHostPatternMismatch
                }
                "ScopeRuleSiteScopedHostPatternMismatch" => {
                    Self::ScopeRuleSiteScopedHostPatternMismatch
                }
                "SigningQuotaExceeded" => Self::SigningQuotaExceeded,
                "InvalidConfigJson" => Self::InvalidConfigJson,
                "InvalidFederatedSessionProviderFailedToRestoreKey" => {
                    Self::InvalidFederatedSessionProviderFailedToRestoreKey
                }
                "FailedToUnwrapKey" => Self::FailedToUnwrapKey,
                "SessionDeletedDuringRefresh" => Self::SessionDeletedDuringRefresh,
                _ => Self::Success,
            }
        }
    }
    impl From<String> for DeviceBoundSessionFetchResult {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Session event details specific to creation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreationEventDetails {
        /// The result of the fetch attempt.
        #[serde(rename = "fetchResult")]
        pub fetch_result: DeviceBoundSessionFetchResult,
        /// The session if there was a newly created session. This is populated for all successful creation events.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "newSession")]
        pub new_session: Option<DeviceBoundSession>,
    }

    /// Session event details specific to refresh.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RefreshEventDetails {
        /// The result of a refresh.
        #[serde(rename = "refreshResult")]
        pub refresh_result: String,
        /// If there was a fetch attempt, the result of that.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fetchResult")]
        pub fetch_result: Option<DeviceBoundSessionFetchResult>,
        /// The session display if there was a newly created session. This is populated for any refresh event that modifies the session config.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "newSession")]
        pub new_session: Option<DeviceBoundSession>,
        /// See comments on `net::device_bound_sessions::RefreshEventResult::was_fully_proactive_refresh`.
        #[serde(rename = "wasFullyProactiveRefresh")]
        pub was_fully_proactive_refresh: bool,
    }

    /// Session event details specific to termination.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TerminationEventDetails {
        /// The reason for a session being deleted.
        #[serde(rename = "deletionReason")]
        pub deletion_reason: String,
    }

    /// Session event details specific to challenges.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ChallengeEventDetails {
        /// The result of a challenge.
        #[serde(rename = "challengeResult")]
        pub challenge_result: String,
        /// The challenge set.
        pub challenge: String,
    }

    /// An object providing the result of a network resource load.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadNetworkResourcePageResult {
        pub success: bool,
        /// Optional values used for error reporting.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "netError")]
        pub net_error: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "netErrorName")]
        pub net_error_name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "httpStatusCode")]
        pub http_status_code: Option<f64>,
        /// If successful, one of the following two fields holds the result.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub stream: Option<io::StreamHandle>,
        /// Response headers.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub headers: Option<network::Headers>,
    }

    /// An options object that may be extended later to better support CORS, CORB and streaming.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadNetworkResourceOptions {
        #[serde(rename = "disableCache")]
        pub disable_cache: bool,
        #[serde(rename = "includeCredentials")]
        pub include_credentials: bool,
    }

    /// Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAcceptedEncodings {
        /// List of accepted content encodings.
        encodings: Vec<ContentEncoding>,
    }

    impl SetAcceptedEncodings {
        pub fn new(encodings: impl Into<Vec<ContentEncoding>>) -> Self {
            Self {
                encodings: encodings.into(),
            }
        }
    }

    impl Command for SetAcceptedEncodings {
        type Response = ();
        const METHOD: &'static str = "Network.setAcceptedEncodings";
    }

    /// Clears accepted encodings set by setAcceptedEncodings
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearAcceptedEncodingsOverride {}

    impl ClearAcceptedEncodingsOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearAcceptedEncodingsOverride {
        type Response = ();
        const METHOD: &'static str = "Network.clearAcceptedEncodingsOverride";
    }

    /// Tells whether clearing browser cache is supported.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanClearBrowserCache {}

    impl CanClearBrowserCache {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CanClearBrowserCache {
        type Response = CanClearBrowserCacheResult;
        const METHOD: &'static str = "Network.canClearBrowserCache";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanClearBrowserCacheResult {
        /// True if browser cache can be cleared.
        pub result: bool,
    }

    /// Tells whether clearing browser cookies is supported.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanClearBrowserCookies {}

    impl CanClearBrowserCookies {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CanClearBrowserCookies {
        type Response = CanClearBrowserCookiesResult;
        const METHOD: &'static str = "Network.canClearBrowserCookies";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanClearBrowserCookiesResult {
        /// True if browser cookies can be cleared.
        pub result: bool,
    }

    /// Tells whether emulation of network conditions is supported.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanEmulateNetworkConditions {}

    impl CanEmulateNetworkConditions {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CanEmulateNetworkConditions {
        type Response = CanEmulateNetworkConditionsResult;
        const METHOD: &'static str = "Network.canEmulateNetworkConditions";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CanEmulateNetworkConditionsResult {
        /// True if emulation of network conditions is supported.
        pub result: bool,
    }

    /// Clears browser cache.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearBrowserCache {}

    impl ClearBrowserCache {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearBrowserCache {
        type Response = ();
        const METHOD: &'static str = "Network.clearBrowserCache";
    }

    /// Clears browser cookies.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearBrowserCookies {}

    impl ClearBrowserCookies {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearBrowserCookies {
        type Response = ();
        const METHOD: &'static str = "Network.clearBrowserCookies";
    }

    /// Response to Network.requestIntercepted which either modifies the request to continue with any modifications, or blocks it, or completes it with the provided response bytes. If a network fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted event will be sent with the same InterceptionId. Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContinueInterceptedRequest {
        #[serde(rename = "interceptionId")]
        interception_id: InterceptionId,
        /// If set this causes the request to fail with the given reason. Passing `Aborted` for requests marked with `isNavigationRequest` also cancels the navigation. Must not be set in response to an authChallenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "errorReason")]
        error_reason: Option<ErrorReason>,
        /// If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rawResponse")]
        raw_response: Option<String>,
        /// If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
        /// If set this allows the request method to be overridden. Must not be set in response to an authChallenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        method: Option<String>,
        /// If set this allows postData to be set. Must not be set in response to an authChallenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "postData")]
        post_data: Option<String>,
        /// If set this allows the request headers to be changed. Must not be set in response to an authChallenge.
        #[serde(skip_serializing_if = "Option::is_none")]
        headers: Option<Headers>,
        /// Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "authChallengeResponse")]
        auth_challenge_response: Option<AuthChallengeResponse>,
    }

    impl ContinueInterceptedRequest {
        pub fn new(interception_id: impl Into<InterceptionId>) -> Self {
            Self {
                interception_id: interception_id.into(),
                error_reason: None,
                raw_response: None,
                url: None,
                method: None,
                post_data: None,
                headers: None,
                auth_challenge_response: None,
            }
        }

        pub fn with_error_reason(mut self, error_reason: impl Into<ErrorReason>) -> Self {
            self.error_reason = Some(error_reason.into());
            self
        }

        pub fn with_raw_response(mut self, raw_response: impl Into<String>) -> Self {
            self.raw_response = Some(raw_response.into());
            self
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }

        pub fn with_method(mut self, method: impl Into<String>) -> Self {
            self.method = Some(method.into());
            self
        }

        pub fn with_post_data(mut self, post_data: impl Into<String>) -> Self {
            self.post_data = Some(post_data.into());
            self
        }

        pub fn with_headers(mut self, headers: impl Into<Headers>) -> Self {
            self.headers = Some(headers.into());
            self
        }

        pub fn with_auth_challenge_response(
            mut self,
            auth_challenge_response: impl Into<AuthChallengeResponse>,
        ) -> Self {
            self.auth_challenge_response = Some(auth_challenge_response.into());
            self
        }
    }

    impl Command for ContinueInterceptedRequest {
        type Response = ();
        const METHOD: &'static str = "Network.continueInterceptedRequest";
    }

    /// Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteCookies {
        /// Name of the cookies to remove.
        name: String,
        /// If specified, deletes all the cookies with the given name where domain and path match provided URL.
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
        /// If specified, deletes only cookies with the exact domain.
        #[serde(skip_serializing_if = "Option::is_none")]
        domain: Option<String>,
        /// If specified, deletes only cookies with the exact path.
        #[serde(skip_serializing_if = "Option::is_none")]
        path: Option<String>,
        /// If specified, deletes only cookies with the the given name and partitionKey where all partition key attributes match the cookie partition key attribute.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitionKey")]
        partition_key: Option<CookiePartitionKey>,
    }

    impl DeleteCookies {
        pub fn new(name: impl Into<String>) -> Self {
            Self {
                name: name.into(),
                url: None,
                domain: None,
                path: None,
                partition_key: None,
            }
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }

        pub fn with_domain(mut self, domain: impl Into<String>) -> Self {
            self.domain = Some(domain.into());
            self
        }

        pub fn with_path(mut self, path: impl Into<String>) -> Self {
            self.path = Some(path.into());
            self
        }

        pub fn with_partition_key(mut self, partition_key: impl Into<CookiePartitionKey>) -> Self {
            self.partition_key = Some(partition_key.into());
            self
        }
    }

    impl Command for DeleteCookies {
        type Response = ();
        const METHOD: &'static str = "Network.deleteCookies";
    }

    /// Disables network tracking, prevents network events from being sent to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Network.disable";
    }

    /// Activates emulation of network conditions. This command is deprecated in favor of the emulateNetworkConditionsByRule and overrideNetworkState commands, which can be used together to the same effect.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EmulateNetworkConditions {
        /// True to emulate internet disconnection.
        offline: bool,
        /// Minimum latency from request sent to response headers received (ms).
        latency: f64,
        /// Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
        #[serde(rename = "downloadThroughput")]
        download_throughput: f64,
        /// Maximal aggregated upload throughput (bytes/sec). -1 disables upload throttling.
        #[serde(rename = "uploadThroughput")]
        upload_throughput: f64,
        /// Connection type if known.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "connectionType")]
        connection_type: Option<ConnectionType>,
        /// WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetLoss")]
        packet_loss: Option<f64>,
        /// WebRTC packet queue length (packet). 0 removes any queue length limitations.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetQueueLength")]
        packet_queue_length: Option<i64>,
        /// WebRTC packetReordering feature.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "packetReordering")]
        packet_reordering: Option<bool>,
    }

    impl EmulateNetworkConditions {
        pub fn new(
            offline: impl Into<bool>,
            latency: impl Into<f64>,
            download_throughput: impl Into<f64>,
            upload_throughput: impl Into<f64>,
        ) -> Self {
            Self {
                offline: offline.into(),
                latency: latency.into(),
                download_throughput: download_throughput.into(),
                upload_throughput: upload_throughput.into(),
                connection_type: None,
                packet_loss: None,
                packet_queue_length: None,
                packet_reordering: None,
            }
        }

        pub fn with_connection_type(mut self, connection_type: impl Into<ConnectionType>) -> Self {
            self.connection_type = Some(connection_type.into());
            self
        }

        pub fn with_packet_loss(mut self, packet_loss: impl Into<f64>) -> Self {
            self.packet_loss = Some(packet_loss.into());
            self
        }

        pub fn with_packet_queue_length(mut self, packet_queue_length: impl Into<i64>) -> Self {
            self.packet_queue_length = Some(packet_queue_length.into());
            self
        }

        pub fn with_packet_reordering(mut self, packet_reordering: impl Into<bool>) -> Self {
            self.packet_reordering = Some(packet_reordering.into());
            self
        }
    }

    impl Command for EmulateNetworkConditions {
        type Response = ();
        const METHOD: &'static str = "Network.emulateNetworkConditions";
    }

    /// Activates emulation of network conditions for individual requests using URL match patterns. Unlike the deprecated Network.emulateNetworkConditions this method does not affect `navigator` state. Use Network.overrideNetworkState to explicitly modify `navigator` behavior.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EmulateNetworkConditionsByRule {
        /// True to emulate internet disconnection.
        offline: bool,
        /// Configure conditions for matching requests. If multiple entries match a request, the first entry wins. Global conditions can be configured by leaving the urlPattern for the conditions empty. These global conditions are also applied for throttling of p2p connections.
        #[serde(rename = "matchedNetworkConditions")]
        matched_network_conditions: Vec<NetworkConditions>,
    }

    impl EmulateNetworkConditionsByRule {
        pub fn new(
            offline: impl Into<bool>,
            matched_network_conditions: impl Into<Vec<NetworkConditions>>,
        ) -> Self {
            Self {
                offline: offline.into(),
                matched_network_conditions: matched_network_conditions.into(),
            }
        }
    }

    impl Command for EmulateNetworkConditionsByRule {
        type Response = EmulateNetworkConditionsByRuleResult;
        const METHOD: &'static str = "Network.emulateNetworkConditionsByRule";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EmulateNetworkConditionsByRuleResult {
        /// An id for each entry in matchedNetworkConditions. The id will be included in the requestWillBeSentExtraInfo for requests affected by a rule.
        #[serde(rename = "ruleIds")]
        pub rule_ids: Vec<String>,
    }

    /// Override the state of navigator.onLine and navigator.connection.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OverrideNetworkState {
        /// True to emulate internet disconnection.
        offline: bool,
        /// Minimum latency from request sent to response headers received (ms).
        latency: f64,
        /// Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
        #[serde(rename = "downloadThroughput")]
        download_throughput: f64,
        /// Maximal aggregated upload throughput (bytes/sec). -1 disables upload throttling.
        #[serde(rename = "uploadThroughput")]
        upload_throughput: f64,
        /// Connection type if known.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "connectionType")]
        connection_type: Option<ConnectionType>,
    }

    impl OverrideNetworkState {
        pub fn new(
            offline: impl Into<bool>,
            latency: impl Into<f64>,
            download_throughput: impl Into<f64>,
            upload_throughput: impl Into<f64>,
        ) -> Self {
            Self {
                offline: offline.into(),
                latency: latency.into(),
                download_throughput: download_throughput.into(),
                upload_throughput: upload_throughput.into(),
                connection_type: None,
            }
        }

        pub fn with_connection_type(mut self, connection_type: impl Into<ConnectionType>) -> Self {
            self.connection_type = Some(connection_type.into());
            self
        }
    }

    impl Command for OverrideNetworkState {
        type Response = ();
        const METHOD: &'static str = "Network.overrideNetworkState";
    }

    /// Enables network tracking, network events will now be delivered to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// Buffer size in bytes to use when preserving network payloads (XHRs, etc).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxTotalBufferSize")]
        max_total_buffer_size: Option<i64>,
        /// Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxResourceBufferSize")]
        max_resource_buffer_size: Option<i64>,
        /// Longest post body size (in bytes) that would be included in requestWillBeSent notification
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxPostDataSize")]
        max_post_data_size: Option<i64>,
        /// Whether DirectSocket chunk send/receive events should be reported.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportDirectSocketTraffic")]
        report_direct_socket_traffic: Option<bool>,
        /// Enable storing response bodies outside of renderer, so that these survive a cross-process navigation. Requires maxTotalBufferSize to be set. Currently defaults to false. This field is being deprecated in favor of the dedicated configureDurableMessages command, due to the possibility of deadlocks when awaiting Network.enable before issuing Runtime.runIfWaitingForDebugger.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableDurableMessages")]
        enable_durable_messages: Option<bool>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                max_total_buffer_size: None,
                max_resource_buffer_size: None,
                max_post_data_size: None,
                report_direct_socket_traffic: None,
                enable_durable_messages: None,
            }
        }

        pub fn with_max_total_buffer_size(mut self, max_total_buffer_size: impl Into<i64>) -> Self {
            self.max_total_buffer_size = Some(max_total_buffer_size.into());
            self
        }

        pub fn with_max_resource_buffer_size(
            mut self,
            max_resource_buffer_size: impl Into<i64>,
        ) -> Self {
            self.max_resource_buffer_size = Some(max_resource_buffer_size.into());
            self
        }

        pub fn with_max_post_data_size(mut self, max_post_data_size: impl Into<i64>) -> Self {
            self.max_post_data_size = Some(max_post_data_size.into());
            self
        }

        pub fn with_report_direct_socket_traffic(
            mut self,
            report_direct_socket_traffic: impl Into<bool>,
        ) -> Self {
            self.report_direct_socket_traffic = Some(report_direct_socket_traffic.into());
            self
        }

        pub fn with_enable_durable_messages(
            mut self,
            enable_durable_messages: impl Into<bool>,
        ) -> Self {
            self.enable_durable_messages = Some(enable_durable_messages.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Network.enable";
    }

    /// Configures storing response bodies outside of renderer, so that these survive a cross-process navigation. If maxTotalBufferSize is not set, durable messages are disabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConfigureDurableMessages {
        /// Buffer size in bytes to use when preserving network payloads (XHRs, etc).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxTotalBufferSize")]
        max_total_buffer_size: Option<i64>,
        /// Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxResourceBufferSize")]
        max_resource_buffer_size: Option<i64>,
    }

    impl ConfigureDurableMessages {
        pub fn new() -> Self {
            Self {
                max_total_buffer_size: None,
                max_resource_buffer_size: None,
            }
        }

        pub fn with_max_total_buffer_size(mut self, max_total_buffer_size: impl Into<i64>) -> Self {
            self.max_total_buffer_size = Some(max_total_buffer_size.into());
            self
        }

        pub fn with_max_resource_buffer_size(
            mut self,
            max_resource_buffer_size: impl Into<i64>,
        ) -> Self {
            self.max_resource_buffer_size = Some(max_resource_buffer_size.into());
            self
        }
    }

    impl Command for ConfigureDurableMessages {
        type Response = ();
        const METHOD: &'static str = "Network.configureDurableMessages";
    }

    /// Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the `cookies` field. Deprecated. Use Storage.getCookies instead.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAllCookies {}

    impl GetAllCookies {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetAllCookies {
        type Response = GetAllCookiesResult;
        const METHOD: &'static str = "Network.getAllCookies";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAllCookiesResult {
        /// Array of cookie objects.
        pub cookies: Vec<Cookie>,
    }

    /// Returns the DER-encoded certificate.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCertificate {
        /// Origin to get certificate for.
        origin: String,
    }

    impl GetCertificate {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for GetCertificate {
        type Response = GetCertificateResult;
        const METHOD: &'static str = "Network.getCertificate";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCertificateResult {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<String>,
    }

    /// Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the `cookies` field.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCookies {
        /// The list of URLs for which applicable cookies will be fetched. If not specified, it's assumed to be set to the list containing the URLs of the page and all of its subframes.
        #[serde(skip_serializing_if = "Option::is_none")]
        urls: Option<Vec<String>>,
    }

    impl GetCookies {
        pub fn new() -> Self {
            Self { urls: None }
        }

        pub fn with_urls(mut self, urls: impl Into<Vec<String>>) -> Self {
            self.urls = Some(urls.into());
            self
        }
    }

    impl Command for GetCookies {
        type Response = GetCookiesResult;
        const METHOD: &'static str = "Network.getCookies";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCookiesResult {
        /// Array of cookie objects.
        pub cookies: Vec<Cookie>,
    }

    /// Returns content served for the given request.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBody {
        /// Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl GetResponseBody {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for GetResponseBody {
        type Response = GetResponseBodyResult;
        const METHOD: &'static str = "Network.getResponseBody";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBodyResult {
        /// Response body.
        pub body: String,
        /// True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: bool,
    }

    /// Returns post data sent with the request. Returns an error when no data was sent with the request.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRequestPostData {
        /// Identifier of the network request to get content for.
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl GetRequestPostData {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for GetRequestPostData {
        type Response = GetRequestPostDataResult;
        const METHOD: &'static str = "Network.getRequestPostData";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRequestPostDataResult {
        /// Request body string, omitting files from multipart requests
        #[serde(rename = "postData")]
        pub post_data: String,
        /// True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: bool,
    }

    /// Returns content served for the given currently intercepted request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBodyForInterception {
        /// Identifier for the intercepted request to get body for.
        #[serde(rename = "interceptionId")]
        interception_id: InterceptionId,
    }

    impl GetResponseBodyForInterception {
        pub fn new(interception_id: impl Into<InterceptionId>) -> Self {
            Self {
                interception_id: interception_id.into(),
            }
        }
    }

    impl Command for GetResponseBodyForInterception {
        type Response = GetResponseBodyForInterceptionResult;
        const METHOD: &'static str = "Network.getResponseBodyForInterception";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResponseBodyForInterceptionResult {
        /// Response body.
        pub body: String,
        /// True, if content was sent as base64.
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: bool,
    }

    /// Returns a handle to the stream representing the response body. Note that after this command, the intercepted request can't be continued as is -- you either need to cancel it or to provide the response body. The stream only supports sequential read, IO.read will fail if the position is specified.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeResponseBodyForInterceptionAsStream {
        #[serde(rename = "interceptionId")]
        interception_id: InterceptionId,
    }

    impl TakeResponseBodyForInterceptionAsStream {
        pub fn new(interception_id: impl Into<InterceptionId>) -> Self {
            Self {
                interception_id: interception_id.into(),
            }
        }
    }

    impl Command for TakeResponseBodyForInterceptionAsStream {
        type Response = TakeResponseBodyForInterceptionAsStreamResult;
        const METHOD: &'static str = "Network.takeResponseBodyForInterceptionAsStream";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeResponseBodyForInterceptionAsStreamResult {
        pub stream: io::StreamHandle,
    }

    /// This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReplayXhr {
        /// Identifier of XHR to replay.
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl ReplayXhr {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for ReplayXhr {
        type Response = ();
        const METHOD: &'static str = "Network.replayXHR";
    }

    /// Searches for given string in response content.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInResponseBody {
        /// Identifier of the network response to search.
        #[serde(rename = "requestId")]
        request_id: RequestId,
        /// String to search for.
        query: String,
        /// If true, search is case sensitive.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "caseSensitive")]
        case_sensitive: Option<bool>,
        /// If true, treats string parameter as regex.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isRegex")]
        is_regex: Option<bool>,
    }

    impl SearchInResponseBody {
        pub fn new(request_id: impl Into<RequestId>, query: impl Into<String>) -> Self {
            Self {
                request_id: request_id.into(),
                query: query.into(),
                case_sensitive: None,
                is_regex: None,
            }
        }

        pub fn with_case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
            self.case_sensitive = Some(case_sensitive.into());
            self
        }

        pub fn with_is_regex(mut self, is_regex: impl Into<bool>) -> Self {
            self.is_regex = Some(is_regex.into());
            self
        }
    }

    impl Command for SearchInResponseBody {
        type Response = SearchInResponseBodyResult;
        const METHOD: &'static str = "Network.searchInResponseBody";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInResponseBodyResult {
        /// List of search matches.
        pub result: Vec<debugger::SearchMatch>,
    }

    /// Blocks URLs from loading.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBlockedUrLs {
        /// Patterns to match in the order in which they are given. These patterns also take precedence over any wildcard patterns defined in `urls`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlPatterns")]
        url_patterns: Option<Vec<BlockPattern>>,
        /// URL patterns to block. Wildcards ('*') are allowed.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        urls: Option<Vec<String>>,
    }

    impl SetBlockedUrLs {
        pub fn new() -> Self {
            Self {
                url_patterns: None,
                urls: None,
            }
        }

        pub fn with_url_patterns(mut self, url_patterns: impl Into<Vec<BlockPattern>>) -> Self {
            self.url_patterns = Some(url_patterns.into());
            self
        }

        pub fn with_urls(mut self, urls: impl Into<Vec<String>>) -> Self {
            self.urls = Some(urls.into());
            self
        }
    }

    impl Command for SetBlockedUrLs {
        type Response = ();
        const METHOD: &'static str = "Network.setBlockedURLs";
    }

    /// Toggles ignoring of service worker for each request.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBypassServiceWorker {
        /// Bypass service worker and load from network.
        bypass: bool,
    }

    impl SetBypassServiceWorker {
        pub fn new(bypass: impl Into<bool>) -> Self {
            Self {
                bypass: bypass.into(),
            }
        }
    }

    impl Command for SetBypassServiceWorker {
        type Response = ();
        const METHOD: &'static str = "Network.setBypassServiceWorker";
    }

    /// Toggles ignoring cache for each request. If `true`, cache will not be used.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCacheDisabled {
        /// Cache disabled state.
        #[serde(rename = "cacheDisabled")]
        cache_disabled: bool,
    }

    impl SetCacheDisabled {
        pub fn new(cache_disabled: impl Into<bool>) -> Self {
            Self {
                cache_disabled: cache_disabled.into(),
            }
        }
    }

    impl Command for SetCacheDisabled {
        type Response = ();
        const METHOD: &'static str = "Network.setCacheDisabled";
    }

    /// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCookie {
        /// Cookie name.
        name: String,
        /// Cookie value.
        value: String,
        /// The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
        /// Cookie domain.
        #[serde(skip_serializing_if = "Option::is_none")]
        domain: Option<String>,
        /// Cookie path.
        #[serde(skip_serializing_if = "Option::is_none")]
        path: Option<String>,
        /// True if cookie is secure.
        #[serde(skip_serializing_if = "Option::is_none")]
        secure: Option<bool>,
        /// True if cookie is http-only.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "httpOnly")]
        http_only: Option<bool>,
        /// Cookie SameSite type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sameSite")]
        same_site: Option<CookieSameSite>,
        /// Cookie expiration date, session cookie if not set
        #[serde(skip_serializing_if = "Option::is_none")]
        expires: Option<TimeSinceEpoch>,
        /// Cookie Priority type.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        priority: Option<CookiePriority>,
        /// Cookie source scheme type.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourceScheme")]
        source_scheme: Option<CookieSourceScheme>,
        /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sourcePort")]
        source_port: Option<i64>,
        /// Cookie partition key. If not set, the cookie will be set as not partitioned.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "partitionKey")]
        partition_key: Option<CookiePartitionKey>,
    }

    impl SetCookie {
        pub fn new(name: impl Into<String>, value: impl Into<String>) -> Self {
            Self {
                name: name.into(),
                value: value.into(),
                url: None,
                domain: None,
                path: None,
                secure: None,
                http_only: None,
                same_site: None,
                expires: None,
                priority: None,
                source_scheme: None,
                source_port: None,
                partition_key: None,
            }
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }

        pub fn with_domain(mut self, domain: impl Into<String>) -> Self {
            self.domain = Some(domain.into());
            self
        }

        pub fn with_path(mut self, path: impl Into<String>) -> Self {
            self.path = Some(path.into());
            self
        }

        pub fn with_secure(mut self, secure: impl Into<bool>) -> Self {
            self.secure = Some(secure.into());
            self
        }

        pub fn with_http_only(mut self, http_only: impl Into<bool>) -> Self {
            self.http_only = Some(http_only.into());
            self
        }

        pub fn with_same_site(mut self, same_site: impl Into<CookieSameSite>) -> Self {
            self.same_site = Some(same_site.into());
            self
        }

        pub fn with_expires(mut self, expires: impl Into<TimeSinceEpoch>) -> Self {
            self.expires = Some(expires.into());
            self
        }

        pub fn with_priority(mut self, priority: impl Into<CookiePriority>) -> Self {
            self.priority = Some(priority.into());
            self
        }

        pub fn with_source_scheme(mut self, source_scheme: impl Into<CookieSourceScheme>) -> Self {
            self.source_scheme = Some(source_scheme.into());
            self
        }

        pub fn with_source_port(mut self, source_port: impl Into<i64>) -> Self {
            self.source_port = Some(source_port.into());
            self
        }

        pub fn with_partition_key(mut self, partition_key: impl Into<CookiePartitionKey>) -> Self {
            self.partition_key = Some(partition_key.into());
            self
        }
    }

    impl Command for SetCookie {
        type Response = SetCookieResult;
        const METHOD: &'static str = "Network.setCookie";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCookieResult {
        /// Always set to true. If an error occurs, the response indicates protocol error.
        #[deprecated]
        pub success: bool,
    }

    /// Sets given cookies.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCookies {
        /// Cookies to be set.
        cookies: Vec<CookieParam>,
    }

    impl SetCookies {
        pub fn new(cookies: impl Into<Vec<CookieParam>>) -> Self {
            Self {
                cookies: cookies.into(),
            }
        }
    }

    impl Command for SetCookies {
        type Response = ();
        const METHOD: &'static str = "Network.setCookies";
    }

    /// Specifies whether to always send extra HTTP headers with the requests from this page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetExtraHttpHeaders {
        /// Map with extra HTTP headers.
        headers: Headers,
    }

    impl SetExtraHttpHeaders {
        pub fn new(headers: impl Into<Headers>) -> Self {
            Self {
                headers: headers.into(),
            }
        }
    }

    impl Command for SetExtraHttpHeaders {
        type Response = ();
        const METHOD: &'static str = "Network.setExtraHTTPHeaders";
    }

    /// Specifies whether to attach a page script stack id in requests
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttachDebugStack {
        /// Whether to attach a page script stack for debugging purpose.
        enabled: bool,
    }

    impl SetAttachDebugStack {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetAttachDebugStack {
        type Response = ();
        const METHOD: &'static str = "Network.setAttachDebugStack";
    }

    /// Sets the requests to intercept that match the provided patterns and optionally resource types. Deprecated, please use Fetch.enable instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRequestInterception {
        /// Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call.
        patterns: Vec<RequestPattern>,
    }

    impl SetRequestInterception {
        pub fn new(patterns: impl Into<Vec<RequestPattern>>) -> Self {
            Self {
                patterns: patterns.into(),
            }
        }
    }

    impl Command for SetRequestInterception {
        type Response = ();
        const METHOD: &'static str = "Network.setRequestInterception";
    }

    /// Allows overriding user agent with the given string.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetUserAgentOverride {
        /// User agent to use.
        #[serde(rename = "userAgent")]
        user_agent: String,
        /// Browser language to emulate.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "acceptLanguage")]
        accept_language: Option<String>,
        /// The platform navigator.platform should return.
        #[serde(skip_serializing_if = "Option::is_none")]
        platform: Option<String>,
        /// To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userAgentMetadata")]
        user_agent_metadata: Option<emulation::UserAgentMetadata>,
    }

    impl SetUserAgentOverride {
        pub fn new(user_agent: impl Into<String>) -> Self {
            Self {
                user_agent: user_agent.into(),
                accept_language: None,
                platform: None,
                user_agent_metadata: None,
            }
        }

        pub fn with_accept_language(mut self, accept_language: impl Into<String>) -> Self {
            self.accept_language = Some(accept_language.into());
            self
        }

        pub fn with_platform(mut self, platform: impl Into<String>) -> Self {
            self.platform = Some(platform.into());
            self
        }

        pub fn with_user_agent_metadata(
            mut self,
            user_agent_metadata: impl Into<emulation::UserAgentMetadata>,
        ) -> Self {
            self.user_agent_metadata = Some(user_agent_metadata.into());
            self
        }
    }

    impl Command for SetUserAgentOverride {
        type Response = ();
        const METHOD: &'static str = "Network.setUserAgentOverride";
    }

    /// Enables streaming of the response for the given requestId. If enabled, the dataReceived event contains the data that was received during streaming.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StreamResourceContent {
        /// Identifier of the request to stream.
        #[serde(rename = "requestId")]
        request_id: RequestId,
    }

    impl StreamResourceContent {
        pub fn new(request_id: impl Into<RequestId>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for StreamResourceContent {
        type Response = StreamResourceContentResult;
        const METHOD: &'static str = "Network.streamResourceContent";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StreamResourceContentResult {
        /// Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "bufferedData")]
        pub buffered_data: String,
    }

    /// Returns information about the COEP/COOP isolation status.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSecurityIsolationStatus {
        /// If no frameId is provided, the status of the target is provided.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
    }

    impl GetSecurityIsolationStatus {
        pub fn new() -> Self {
            Self { frame_id: None }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for GetSecurityIsolationStatus {
        type Response = GetSecurityIsolationStatusResult;
        const METHOD: &'static str = "Network.getSecurityIsolationStatus";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSecurityIsolationStatusResult {
        pub status: SecurityIsolationStatus,
    }

    /// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client. Enabling triggers 'reportingApiReportAdded' for all existing reports.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EnableReportingApi {
        /// Whether to enable or disable events for the Reporting API
        enable: bool,
    }

    impl EnableReportingApi {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for EnableReportingApi {
        type Response = ();
        const METHOD: &'static str = "Network.enableReportingApi";
    }

    /// Sets up tracking device bound sessions and fetching of initial set of sessions.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EnableDeviceBoundSessions {
        /// Whether to enable or disable events.
        enable: bool,
    }

    impl EnableDeviceBoundSessions {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for EnableDeviceBoundSessions {
        type Response = ();
        const METHOD: &'static str = "Network.enableDeviceBoundSessions";
    }

    /// Fetches the schemeful site for a specific origin.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FetchSchemefulSite {
        /// The URL origin.
        origin: String,
    }

    impl FetchSchemefulSite {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for FetchSchemefulSite {
        type Response = FetchSchemefulSiteResult;
        const METHOD: &'static str = "Network.fetchSchemefulSite";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FetchSchemefulSiteResult {
        /// The corresponding schemeful site.
        #[serde(rename = "schemefulSite")]
        pub schemeful_site: String,
    }

    /// Fetches the resource and returns the content.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadNetworkResource {
        /// Frame id to get the resource for. Mandatory for frame targets, and should be omitted for worker targets.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
        /// URL of the resource to get content for.
        url: String,
        /// Options for the request.
        options: LoadNetworkResourceOptions,
    }

    impl LoadNetworkResource {
        pub fn new(url: impl Into<String>, options: impl Into<LoadNetworkResourceOptions>) -> Self {
            Self {
                frame_id: None,
                url: url.into(),
                options: options.into(),
            }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for LoadNetworkResource {
        type Response = LoadNetworkResourceResult;
        const METHOD: &'static str = "Network.loadNetworkResource";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadNetworkResourceResult {
        pub resource: LoadNetworkResourcePageResult,
    }

    /// Sets Controls for third-party cookie access Page reload is required before the new cookie behavior will be observed
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCookieControls {
        /// Whether 3pc restriction is enabled.
        #[serde(rename = "enableThirdPartyCookieRestriction")]
        enable_third_party_cookie_restriction: bool,
        /// Whether 3pc grace period exception should be enabled; false by default.
        #[serde(rename = "disableThirdPartyCookieMetadata")]
        disable_third_party_cookie_metadata: bool,
        /// Whether 3pc heuristics exceptions should be enabled; false by default.
        #[serde(rename = "disableThirdPartyCookieHeuristics")]
        disable_third_party_cookie_heuristics: bool,
    }

    impl SetCookieControls {
        pub fn new(
            enable_third_party_cookie_restriction: impl Into<bool>,
            disable_third_party_cookie_metadata: impl Into<bool>,
            disable_third_party_cookie_heuristics: impl Into<bool>,
        ) -> Self {
            Self {
                enable_third_party_cookie_restriction: enable_third_party_cookie_restriction.into(),
                disable_third_party_cookie_metadata: disable_third_party_cookie_metadata.into(),
                disable_third_party_cookie_heuristics: disable_third_party_cookie_heuristics.into(),
            }
        }
    }

    impl Command for SetCookieControls {
        type Response = ();
        const METHOD: &'static str = "Network.setCookieControls";
    }

    /// Fired when data chunk was received over the network.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DataReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Data chunk length.
        #[serde(rename = "dataLength")]
        pub data_length: i64,
        /// Actual bytes received (might be less than dataLength for compressed encodings).
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: i64,
        /// Data that was received. (Encoded as a base64 string when passed over JSON)
        /// **EXPERIMENTAL**
        pub data: Option<String>,
    }

    impl DataReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.dataReceived")
        }
    }

    /// Fired when EventSource message is received.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EventSourceMessageReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Message type.
        #[serde(rename = "eventName")]
        pub event_name: String,
        /// Message identifier.
        #[serde(rename = "eventId")]
        pub event_id: String,
        /// Message content.
        pub data: String,
    }

    impl EventSourceMessageReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.eventSourceMessageReceived")
        }
    }

    /// Fired when HTTP request has failed to load.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadingFailed {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Resource type.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        /// Error message. List of network errors: https://cs.chromium.org/chromium/src/net/base/net_error_list.h
        #[serde(rename = "errorText")]
        pub error_text: String,
        /// True if loading was canceled.
        pub canceled: Option<bool>,
        /// The reason why loading was blocked, if any.
        #[serde(rename = "blockedReason")]
        pub blocked_reason: Option<BlockedReason>,
        /// The reason why loading was blocked by CORS, if any.
        #[serde(rename = "corsErrorStatus")]
        pub cors_error_status: Option<CorsErrorStatus>,
    }

    impl LoadingFailed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.loadingFailed")
        }
    }

    /// Fired when HTTP request has finished loading.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadingFinished {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Total number of bytes received for this request.
        #[serde(rename = "encodedDataLength")]
        pub encoded_data_length: f64,
    }

    impl LoadingFinished {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.loadingFinished")
        }
    }

    /// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or mocked. Deprecated, use Fetch.requestPaused instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestIntercepted {
        /// Each request the page makes will have a unique id, however if any redirects are encountered while processing that fetch, they will be reported with the same id as the original fetch. Likewise if HTTP authentication is needed then the same fetch id will be used.
        #[serde(rename = "interceptionId")]
        pub interception_id: InterceptionId,
        pub request: Request,
        /// The id of the frame that initiated the request.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// How the requested resource will be used.
        #[serde(rename = "resourceType")]
        pub resource_type: ResourceType,
        /// Whether this is a navigation request, which can abort the navigation completely.
        #[serde(rename = "isNavigationRequest")]
        pub is_navigation_request: bool,
        /// Set if the request is a navigation that will result in a download. Only present after response is received from the server (i.e. HeadersReceived stage).
        #[serde(rename = "isDownload")]
        pub is_download: Option<bool>,
        /// Redirect location, only sent if a redirect was intercepted.
        #[serde(rename = "redirectUrl")]
        pub redirect_url: Option<String>,
        /// Details of the Authorization Challenge encountered. If this is set then continueInterceptedRequest must contain an authChallengeResponse.
        #[serde(rename = "authChallenge")]
        pub auth_challenge: Option<AuthChallenge>,
        /// Response error if intercepted at response stage or if redirect occurred while intercepting request.
        #[serde(rename = "responseErrorReason")]
        pub response_error_reason: Option<ErrorReason>,
        /// Response code if intercepted at response stage or if redirect occurred while intercepting request or auth retry occurred.
        #[serde(rename = "responseStatusCode")]
        pub response_status_code: Option<i64>,
        /// Response headers if intercepted at the response stage or if redirect occurred while intercepting request or auth retry occurred.
        #[serde(rename = "responseHeaders")]
        pub response_headers: Option<Headers>,
        /// If the intercepted request had a corresponding requestWillBeSent event fired for it, then this requestId will be the same as the requestId present in the requestWillBeSent event.
        #[serde(rename = "requestId")]
        pub request_id: Option<RequestId>,
    }

    impl RequestIntercepted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.requestIntercepted")
        }
    }

    /// Fired if request ended up loading from cache.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestServedFromCache {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
    }

    impl RequestServedFromCache {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.requestServedFromCache")
        }
    }

    /// Fired when page is about to send HTTP request.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestWillBeSent {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: LoaderId,
        /// URL of the document this request is loaded for.
        #[serde(rename = "documentURL")]
        pub document_url: String,
        /// Request data.
        pub request: Request,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Timestamp.
        #[serde(rename = "wallTime")]
        pub wall_time: TimeSinceEpoch,
        /// Request initiator.
        pub initiator: Initiator,
        /// In the case that redirectResponse is populated, this flag indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted for the request which was just redirected.
        /// **EXPERIMENTAL**
        #[serde(rename = "redirectHasExtraInfo")]
        pub redirect_has_extra_info: bool,
        /// Redirect response data.
        #[serde(rename = "redirectResponse")]
        pub redirect_response: Option<Response>,
        /// Type of this resource.
        #[serde(rename = "type")]
        pub type_: Option<ResourceType>,
        /// Frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
        /// Whether the request is initiated by a user gesture. Defaults to false.
        #[serde(rename = "hasUserGesture")]
        pub has_user_gesture: Option<bool>,
        /// The render blocking behavior of the request.
        /// **EXPERIMENTAL**
        #[serde(rename = "renderBlockingBehavior")]
        pub render_blocking_behavior: Option<RenderBlockingBehavior>,
    }

    impl RequestWillBeSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.requestWillBeSent")
        }
    }

    /// Fired when resource loading priority is changed
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResourceChangedPriority {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// New priority
        #[serde(rename = "newPriority")]
        pub new_priority: ResourcePriority,
        /// Timestamp.
        pub timestamp: MonotonicTime,
    }

    impl ResourceChangedPriority {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.resourceChangedPriority")
        }
    }

    /// Fired when a signed exchange was received over the network
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SignedExchangeReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Information about the signed exchange response.
        pub info: SignedExchangeInfo,
    }

    impl SignedExchangeReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.signedExchangeReceived")
        }
    }

    /// Fired when HTTP response is available.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResponseReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: LoaderId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Resource type.
        #[serde(rename = "type")]
        pub type_: ResourceType,
        /// Response data.
        pub response: Response,
        /// Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted for this request.
        /// **EXPERIMENTAL**
        #[serde(rename = "hasExtraInfo")]
        pub has_extra_info: bool,
        /// Frame identifier.
        #[serde(rename = "frameId")]
        pub frame_id: Option<page::FrameId>,
    }

    impl ResponseReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.responseReceived")
        }
    }

    /// Fired when WebSocket is closed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketClosed {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
    }

    impl WebSocketClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webSocketClosed")
        }
    }

    /// Fired upon WebSocket creation.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketCreated {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// WebSocket request URL.
        pub url: String,
        /// Request initiator.
        pub initiator: Option<Initiator>,
    }

    impl WebSocketCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webSocketCreated")
        }
    }

    /// Fired when WebSocket message error occurs.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketFrameError {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// WebSocket error message.
        #[serde(rename = "errorMessage")]
        pub error_message: String,
    }

    impl WebSocketFrameError {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webSocketFrameError")
        }
    }

    /// Fired when WebSocket message is received.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketFrameReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// WebSocket response data.
        pub response: WebSocketFrame,
    }

    impl WebSocketFrameReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webSocketFrameReceived")
        }
    }

    /// Fired when WebSocket message is sent.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketFrameSent {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// WebSocket response data.
        pub response: WebSocketFrame,
    }

    impl WebSocketFrameSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webSocketFrameSent")
        }
    }

    /// Fired when WebSocket handshake response becomes available.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketHandshakeResponseReceived {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// WebSocket response data.
        pub response: WebSocketResponse,
    }

    impl WebSocketHandshakeResponseReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.webSocketHandshakeResponseReceived")
        }
    }

    /// Fired when WebSocket is about to initiate handshake.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebSocketWillSendHandshakeRequest {
        /// Request identifier.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// UTC Timestamp.
        #[serde(rename = "wallTime")]
        pub wall_time: TimeSinceEpoch,
        /// WebSocket request data.
        pub request: WebSocketRequest,
    }

    impl WebSocketWillSendHandshakeRequest {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.webSocketWillSendHandshakeRequest")
        }
    }

    /// Fired upon WebTransport creation.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebTransportCreated {
        /// WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        /// WebTransport request URL.
        pub url: String,
        /// Timestamp.
        pub timestamp: MonotonicTime,
        /// Request initiator.
        pub initiator: Option<Initiator>,
    }

    impl WebTransportCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webTransportCreated")
        }
    }

    /// Fired when WebTransport handshake is finished.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebTransportConnectionEstablished {
        /// WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
    }

    impl WebTransportConnectionEstablished {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.webTransportConnectionEstablished")
        }
    }

    /// Fired when WebTransport is disposed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebTransportClosed {
        /// WebTransport identifier.
        #[serde(rename = "transportId")]
        pub transport_id: RequestId,
        /// Timestamp.
        pub timestamp: MonotonicTime,
    }

    impl WebTransportClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.webTransportClosed")
        }
    }

    /// Fired upon direct_socket.TCPSocket creation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketCreated {
        pub identifier: RequestId,
        #[serde(rename = "remoteAddr")]
        pub remote_addr: String,
        /// Unsigned int 16.
        #[serde(rename = "remotePort")]
        pub remote_port: i64,
        pub options: DirectTCPSocketOptions,
        pub timestamp: MonotonicTime,
        pub initiator: Option<Initiator>,
    }

    impl DirectTcpSocketCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directTCPSocketCreated")
        }
    }

    /// Fired when direct_socket.TCPSocket connection is opened.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketOpened {
        pub identifier: RequestId,
        #[serde(rename = "remoteAddr")]
        pub remote_addr: String,
        /// Expected to be unsigned integer.
        #[serde(rename = "remotePort")]
        pub remote_port: i64,
        pub timestamp: MonotonicTime,
        #[serde(rename = "localAddr")]
        pub local_addr: Option<String>,
        /// Expected to be unsigned integer.
        #[serde(rename = "localPort")]
        pub local_port: Option<i64>,
    }

    impl DirectTcpSocketOpened {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directTCPSocketOpened")
        }
    }

    /// Fired when direct_socket.TCPSocket is aborted.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketAborted {
        pub identifier: RequestId,
        #[serde(rename = "errorMessage")]
        pub error_message: String,
        pub timestamp: MonotonicTime,
    }

    impl DirectTcpSocketAborted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directTCPSocketAborted")
        }
    }

    /// Fired when direct_socket.TCPSocket is closed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketClosed {
        pub identifier: RequestId,
        pub timestamp: MonotonicTime,
    }

    impl DirectTcpSocketClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directTCPSocketClosed")
        }
    }

    /// Fired when data is sent to tcp direct socket stream.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketChunkSent {
        pub identifier: RequestId,
        pub data: String,
        pub timestamp: MonotonicTime,
    }

    impl DirectTcpSocketChunkSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directTCPSocketChunkSent")
        }
    }

    /// Fired when data is received from tcp direct socket stream.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectTcpSocketChunkReceived {
        pub identifier: RequestId,
        pub data: String,
        pub timestamp: MonotonicTime,
    }

    impl DirectTcpSocketChunkReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.directTCPSocketChunkReceived")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketJoinedMulticastGroup {
        pub identifier: RequestId,
        #[serde(rename = "IPAddress")]
        pub ip_address: String,
    }

    impl DirectUdpSocketJoinedMulticastGroup {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.directUDPSocketJoinedMulticastGroup")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketLeftMulticastGroup {
        pub identifier: RequestId,
        #[serde(rename = "IPAddress")]
        pub ip_address: String,
    }

    impl DirectUdpSocketLeftMulticastGroup {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.directUDPSocketLeftMulticastGroup")
        }
    }

    /// Fired upon direct_socket.UDPSocket creation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketCreated {
        pub identifier: RequestId,
        pub options: DirectUDPSocketOptions,
        pub timestamp: MonotonicTime,
        pub initiator: Option<Initiator>,
    }

    impl DirectUdpSocketCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directUDPSocketCreated")
        }
    }

    /// Fired when direct_socket.UDPSocket connection is opened.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketOpened {
        pub identifier: RequestId,
        #[serde(rename = "localAddr")]
        pub local_addr: String,
        /// Expected to be unsigned integer.
        #[serde(rename = "localPort")]
        pub local_port: i64,
        pub timestamp: MonotonicTime,
        #[serde(rename = "remoteAddr")]
        pub remote_addr: Option<String>,
        /// Expected to be unsigned integer.
        #[serde(rename = "remotePort")]
        pub remote_port: Option<i64>,
    }

    impl DirectUdpSocketOpened {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directUDPSocketOpened")
        }
    }

    /// Fired when direct_socket.UDPSocket is aborted.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketAborted {
        pub identifier: RequestId,
        #[serde(rename = "errorMessage")]
        pub error_message: String,
        pub timestamp: MonotonicTime,
    }

    impl DirectUdpSocketAborted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directUDPSocketAborted")
        }
    }

    /// Fired when direct_socket.UDPSocket is closed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketClosed {
        pub identifier: RequestId,
        pub timestamp: MonotonicTime,
    }

    impl DirectUdpSocketClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directUDPSocketClosed")
        }
    }

    /// Fired when message is sent to udp direct socket stream.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketChunkSent {
        pub identifier: RequestId,
        pub message: DirectUDPMessage,
        pub timestamp: MonotonicTime,
    }

    impl DirectUdpSocketChunkSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.directUDPSocketChunkSent")
        }
    }

    /// Fired when message is received from udp direct socket stream.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DirectUdpSocketChunkReceived {
        pub identifier: RequestId,
        pub message: DirectUDPMessage,
        pub timestamp: MonotonicTime,
    }

    impl DirectUdpSocketChunkReceived {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.directUDPSocketChunkReceived")
        }
    }

    /// Fired when additional information about a requestWillBeSent event is available from the network stack. Not every requestWillBeSent event will have an additional requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent or requestWillBeSentExtraInfo will be fired first for the same request.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestWillBeSentExtraInfo {
        /// Request identifier. Used to match this information to an existing requestWillBeSent event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// A list of cookies potentially associated to the requested URL. This includes both cookies sent with the request and the ones not sent; the latter are distinguished by having blockedReasons field set.
        #[serde(rename = "associatedCookies")]
        pub associated_cookies: Vec<AssociatedCookie>,
        /// Raw request headers as they will be sent over the wire.
        pub headers: Headers,
        /// Connection timing information for the request.
        /// **EXPERIMENTAL**
        #[serde(rename = "connectTiming")]
        pub connect_timing: ConnectTiming,
        /// How the request site's device bound sessions were used during this request.
        #[serde(rename = "deviceBoundSessionUsages")]
        pub device_bound_session_usages: Option<Vec<DeviceBoundSessionWithUsage>>,
        /// The client security state set for the request.
        #[serde(rename = "clientSecurityState")]
        pub client_security_state: Option<ClientSecurityState>,
        /// Whether the site has partitioned cookies stored in a partition different than the current one.
        #[serde(rename = "siteHasCookieInOtherPartition")]
        pub site_has_cookie_in_other_partition: Option<bool>,
        /// The network conditions id if this request was affected by network conditions configured via emulateNetworkConditionsByRule.
        #[serde(rename = "appliedNetworkConditionsId")]
        pub applied_network_conditions_id: Option<String>,
    }

    impl RequestWillBeSentExtraInfo {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.requestWillBeSentExtraInfo")
        }
    }

    /// Fired when additional information about a responseReceived event is available from the network stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for it, and responseReceivedExtraInfo may be fired before or after responseReceived.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResponseReceivedExtraInfo {
        /// Request identifier. Used to match this information to another responseReceived event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// A list of cookies which were not stored from the response along with the corresponding reasons for blocking. The cookies here may not be valid due to syntax errors, which are represented by the invalid cookie line string instead of a proper cookie.
        #[serde(rename = "blockedCookies")]
        pub blocked_cookies: Vec<BlockedSetCookieWithReason>,
        /// Raw response headers as they were received over the wire. Duplicate headers in the response are represented as a single key with their values concatentated using `\n` as the separator. See also `headersText` that contains verbatim text for HTTP/1.*.
        pub headers: Headers,
        /// The IP address space of the resource. The address space can only be determined once the transport established the connection, so we can't send it in `requestWillBeSentExtraInfo`.
        #[serde(rename = "resourceIPAddressSpace")]
        pub resource_ip_address_space: IPAddressSpace,
        /// The status code of the response. This is useful in cases the request failed and no responseReceived event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code for cached requests, where the status in responseReceived is a 200 and this will be 304.
        #[serde(rename = "statusCode")]
        pub status_code: i64,
        /// Raw response header text as it was received over the wire. The raw text may not always be available, such as in the case of HTTP/2 or QUIC.
        #[serde(rename = "headersText")]
        pub headers_text: Option<String>,
        /// The cookie partition key that will be used to store partitioned cookies set in this response. Only sent when partitioned cookies are enabled.
        /// **EXPERIMENTAL**
        #[serde(rename = "cookiePartitionKey")]
        pub cookie_partition_key: Option<CookiePartitionKey>,
        /// True if partitioned cookies are enabled, but the partition key is not serializable to string.
        #[serde(rename = "cookiePartitionKeyOpaque")]
        pub cookie_partition_key_opaque: Option<bool>,
        /// A list of cookies which should have been blocked by 3PCD but are exempted and stored from the response with the corresponding reason.
        #[serde(rename = "exemptedCookies")]
        pub exempted_cookies: Option<Vec<ExemptedSetCookieWithReason>>,
    }

    impl ResponseReceivedExtraInfo {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.responseReceivedExtraInfo")
        }
    }

    /// Fired when 103 Early Hints headers is received in addition to the common response. Not every responseReceived event will have an responseReceivedEarlyHints fired. Only one responseReceivedEarlyHints may be fired for eached responseReceived event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResponseReceivedEarlyHints {
        /// Request identifier. Used to match this information to another responseReceived event.
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Raw response headers as they were received over the wire. Duplicate headers in the response are represented as a single key with their values concatentated using `\n` as the separator. See also `headersText` that contains verbatim text for HTTP/1.*.
        pub headers: Headers,
    }

    impl ResponseReceivedEarlyHints {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.responseReceivedEarlyHints")
        }
    }

    /// Fired exactly once for each Trust Token operation. Depending on the type of the operation and whether the operation succeeded or failed, the event is fired before the corresponding request was sent or after the response was received.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrustTokenOperationDone {
        /// Detailed success or error status of the operation. 'AlreadyExists' also signifies a successful operation, as the result of the operation already exists und thus, the operation was abort preemptively (e.g. a cache hit).
        pub status: String,
        #[serde(rename = "type")]
        pub type_: TrustTokenOperationType,
        #[serde(rename = "requestId")]
        pub request_id: RequestId,
        /// Top level origin. The context in which the operation was attempted.
        #[serde(rename = "topLevelOrigin")]
        pub top_level_origin: Option<String>,
        /// Origin of the issuer in case of a "Issuance" or "Redemption" operation.
        #[serde(rename = "issuerOrigin")]
        pub issuer_origin: Option<String>,
        /// The number of obtained Trust Tokens on a successful "Issuance" operation.
        #[serde(rename = "issuedTokenCount")]
        pub issued_token_count: Option<i64>,
    }

    impl TrustTokenOperationDone {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.trustTokenOperationDone")
        }
    }

    /// Fired once security policy has been updated.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PolicyUpdated {}

    impl PolicyUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.policyUpdated")
        }
    }

    /// Is sent whenever a new report is added. And after 'enableReportingApi' for all existing reports.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportingApiReportAdded {
        pub report: ReportingApiReport,
    }

    impl ReportingApiReportAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.reportingApiReportAdded")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportingApiReportUpdated {
        pub report: ReportingApiReport,
    }

    impl ReportingApiReportUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.reportingApiReportUpdated")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportingApiEndpointsChangedForOrigin {
        /// Origin of the document(s) which configured the endpoints.
        pub origin: String,
        pub endpoints: Vec<ReportingApiEndpoint>,
    }

    impl ReportingApiEndpointsChangedForOrigin {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.reportingApiEndpointsChangedForOrigin")
        }
    }

    /// Triggered when the initial set of device bound sessions is added.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionsAdded {
        /// The device bound sessions.
        pub sessions: Vec<DeviceBoundSession>,
    }

    impl DeviceBoundSessionsAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Network.deviceBoundSessionsAdded")
        }
    }

    /// Triggered when a device bound session event occurs.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeviceBoundSessionEventOccurred {
        /// A unique identifier for this session event.
        #[serde(rename = "eventId")]
        pub event_id: DeviceBoundSessionEventId,
        /// The site this session event is associated with.
        pub site: String,
        /// Whether this event was considered successful.
        pub succeeded: bool,
        /// The session ID this event is associated with. May not be populated for failed events.
        #[serde(rename = "sessionId")]
        pub session_id: Option<String>,
        /// The below are the different session event type details. Exactly one is populated.
        #[serde(rename = "creationEventDetails")]
        pub creation_event_details: Option<CreationEventDetails>,
        #[serde(rename = "refreshEventDetails")]
        pub refresh_event_details: Option<RefreshEventDetails>,
        #[serde(rename = "terminationEventDetails")]
        pub termination_event_details: Option<TerminationEventDetails>,
        #[serde(rename = "challengeEventDetails")]
        pub challenge_event_details: Option<ChallengeEventDetails>,
    }

    impl DeviceBoundSessionEventOccurred {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Network.deviceBoundSessionEventOccurred")
        }
    }
}

pub mod overlay {
    use super::*;

    /// Configuration data for drawing the source order of an elements children.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SourceOrderConfig {
        /// the color to outline the given element in.
        #[serde(rename = "parentOutlineColor")]
        pub parent_outline_color: dom::RGBA,
        /// the color to outline the child elements in.
        #[serde(rename = "childOutlineColor")]
        pub child_outline_color: dom::RGBA,
    }

    /// Configuration data for the highlighting of Grid elements.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GridHighlightConfig {
        /// Whether the extension lines from grid cells to the rulers should be shown (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showGridExtensionLines")]
        pub show_grid_extension_lines: Option<bool>,
        /// Show Positive line number labels (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showPositiveLineNumbers")]
        pub show_positive_line_numbers: Option<bool>,
        /// Show Negative line number labels (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showNegativeLineNumbers")]
        pub show_negative_line_numbers: Option<bool>,
        /// Show area name labels (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showAreaNames")]
        pub show_area_names: Option<bool>,
        /// Show line name labels (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showLineNames")]
        pub show_line_names: Option<bool>,
        /// Show track size labels (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showTrackSizes")]
        pub show_track_sizes: Option<bool>,
        /// The grid container border highlight color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gridBorderColor")]
        pub grid_border_color: Option<dom::RGBA>,
        /// The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cellBorderColor")]
        pub cell_border_color: Option<dom::RGBA>,
        /// The row line color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rowLineColor")]
        pub row_line_color: Option<dom::RGBA>,
        /// The column line color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnLineColor")]
        pub column_line_color: Option<dom::RGBA>,
        /// Whether the grid border is dashed (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gridBorderDash")]
        pub grid_border_dash: Option<bool>,
        /// Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cellBorderDash")]
        pub cell_border_dash: Option<bool>,
        /// Whether row lines are dashed (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rowLineDash")]
        pub row_line_dash: Option<bool>,
        /// Whether column lines are dashed (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnLineDash")]
        pub column_line_dash: Option<bool>,
        /// The row gap highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rowGapColor")]
        pub row_gap_color: Option<dom::RGBA>,
        /// The row gap hatching fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rowHatchColor")]
        pub row_hatch_color: Option<dom::RGBA>,
        /// The column gap highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnGapColor")]
        pub column_gap_color: Option<dom::RGBA>,
        /// The column gap hatching fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnHatchColor")]
        pub column_hatch_color: Option<dom::RGBA>,
        /// The named grid areas border color (Default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "areaBorderColor")]
        pub area_border_color: Option<dom::RGBA>,
        /// The grid container background color (Default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gridBackgroundColor")]
        pub grid_background_color: Option<dom::RGBA>,
    }

    /// Configuration data for the highlighting of Flex container elements.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FlexContainerHighlightConfig {
        /// The style of the container border
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerBorder")]
        pub container_border: Option<LineStyle>,
        /// The style of the separator between lines
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lineSeparator")]
        pub line_separator: Option<LineStyle>,
        /// The style of the separator between items
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "itemSeparator")]
        pub item_separator: Option<LineStyle>,
        /// Style of content-distribution space on the main axis (justify-content).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "mainDistributedSpace")]
        pub main_distributed_space: Option<BoxStyle>,
        /// Style of content-distribution space on the cross axis (align-content).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "crossDistributedSpace")]
        pub cross_distributed_space: Option<BoxStyle>,
        /// Style of empty space caused by row gaps (gap/row-gap).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rowGapSpace")]
        pub row_gap_space: Option<BoxStyle>,
        /// Style of empty space caused by columns gaps (gap/column-gap).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnGapSpace")]
        pub column_gap_space: Option<BoxStyle>,
        /// Style of the self-alignment line (align-items).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "crossAlignment")]
        pub cross_alignment: Option<LineStyle>,
    }

    /// Configuration data for the highlighting of Flex item elements.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FlexItemHighlightConfig {
        /// Style of the box representing the item's base size
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "baseSizeBox")]
        pub base_size_box: Option<BoxStyle>,
        /// Style of the border around the box representing the item's base size
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "baseSizeBorder")]
        pub base_size_border: Option<LineStyle>,
        /// Style of the arrow representing if the item grew or shrank
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "flexibilityArrow")]
        pub flexibility_arrow: Option<LineStyle>,
    }

    /// Style information for drawing a line.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LineStyle {
        /// The color of the line (default: transparent)
        #[serde(skip_serializing_if = "Option::is_none")]
        pub color: Option<dom::RGBA>,
        /// The line pattern (default: solid)
        #[serde(skip_serializing_if = "Option::is_none")]
        pub pattern: Option<String>,
    }

    /// Style information for drawing a box.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BoxStyle {
        /// The background color for the box (default: transparent)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fillColor")]
        pub fill_color: Option<dom::RGBA>,
        /// The hatching color for the box (default: transparent)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hatchColor")]
        pub hatch_color: Option<dom::RGBA>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContrastAlgorithm {
        #[serde(rename = "aa")]
        Aa,
        #[serde(rename = "aaa")]
        Aaa,
        #[serde(rename = "apca")]
        Apca,
    }
    impl From<&str> for ContrastAlgorithm {
        fn from(s: &str) -> Self {
            match s {
                "aa" => Self::Aa,
                "aaa" => Self::Aaa,
                "apca" => Self::Apca,
                _ => Self::Aa,
            }
        }
    }
    impl From<String> for ContrastAlgorithm {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Configuration data for the highlighting of page elements.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightConfig {
        /// Whether the node info tooltip should be shown (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showInfo")]
        pub show_info: Option<bool>,
        /// Whether the node styles in the tooltip (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showStyles")]
        pub show_styles: Option<bool>,
        /// Whether the rulers should be shown (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showRulers")]
        pub show_rulers: Option<bool>,
        /// Whether the a11y info should be shown (default: true).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showAccessibilityInfo")]
        pub show_accessibility_info: Option<bool>,
        /// Whether the extension lines from node to the rulers should be shown (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showExtensionLines")]
        pub show_extension_lines: Option<bool>,
        /// The content box highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentColor")]
        pub content_color: Option<dom::RGBA>,
        /// The padding highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "paddingColor")]
        pub padding_color: Option<dom::RGBA>,
        /// The border highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "borderColor")]
        pub border_color: Option<dom::RGBA>,
        /// The margin highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "marginColor")]
        pub margin_color: Option<dom::RGBA>,
        /// The event target element highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "eventTargetColor")]
        pub event_target_color: Option<dom::RGBA>,
        /// The shape outside fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shapeColor")]
        pub shape_color: Option<dom::RGBA>,
        /// The shape margin fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shapeMarginColor")]
        pub shape_margin_color: Option<dom::RGBA>,
        /// The grid layout color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "cssGridColor")]
        pub css_grid_color: Option<dom::RGBA>,
        /// The color format used to format color styles (default: hex).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "colorFormat")]
        pub color_format: Option<ColorFormat>,
        /// The grid layout highlight configuration (default: all transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "gridHighlightConfig")]
        pub grid_highlight_config: Option<GridHighlightConfig>,
        /// The flex container highlight configuration (default: all transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "flexContainerHighlightConfig")]
        pub flex_container_highlight_config: Option<FlexContainerHighlightConfig>,
        /// The flex item highlight configuration (default: all transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "flexItemHighlightConfig")]
        pub flex_item_highlight_config: Option<FlexItemHighlightConfig>,
        /// The contrast algorithm to use for the contrast ratio (default: aa).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contrastAlgorithm")]
        pub contrast_algorithm: Option<ContrastAlgorithm>,
        /// The container query container highlight configuration (default: all transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerQueryContainerHighlightConfig")]
        pub container_query_container_highlight_config:
            Option<ContainerQueryContainerHighlightConfig>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ColorFormat {
        #[serde(rename = "rgb")]
        Rgb,
        #[serde(rename = "hsl")]
        Hsl,
        #[serde(rename = "hwb")]
        Hwb,
        #[serde(rename = "hex")]
        Hex,
    }
    impl From<&str> for ColorFormat {
        fn from(s: &str) -> Self {
            match s {
                "rgb" => Self::Rgb,
                "hsl" => Self::Hsl,
                "hwb" => Self::Hwb,
                "hex" => Self::Hex,
                _ => Self::Rgb,
            }
        }
    }
    impl From<String> for ColorFormat {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Configurations for Persistent Grid Highlight
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GridNodeHighlightConfig {
        /// A descriptor for the highlight appearance.
        #[serde(rename = "gridHighlightConfig")]
        pub grid_highlight_config: GridHighlightConfig,
        /// Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FlexNodeHighlightConfig {
        /// A descriptor for the highlight appearance of flex containers.
        #[serde(rename = "flexContainerHighlightConfig")]
        pub flex_container_highlight_config: FlexContainerHighlightConfig,
        /// Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScrollSnapContainerHighlightConfig {
        /// The style of the snapport border (default: transparent)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "snapportBorder")]
        pub snapport_border: Option<LineStyle>,
        /// The style of the snap area border (default: transparent)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "snapAreaBorder")]
        pub snap_area_border: Option<LineStyle>,
        /// The margin highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollMarginColor")]
        pub scroll_margin_color: Option<dom::RGBA>,
        /// The padding highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scrollPaddingColor")]
        pub scroll_padding_color: Option<dom::RGBA>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScrollSnapHighlightConfig {
        /// A descriptor for the highlight appearance of scroll snap containers.
        #[serde(rename = "scrollSnapContainerHighlightConfig")]
        pub scroll_snap_container_highlight_config: ScrollSnapContainerHighlightConfig,
        /// Identifier of the node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    /// Configuration for dual screen hinge
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HingeConfig {
        /// A rectangle represent hinge
        pub rect: dom::Rect,
        /// The content box highlight fill color (default: a dark color).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentColor")]
        pub content_color: Option<dom::RGBA>,
        /// The content box highlight outline color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "outlineColor")]
        pub outline_color: Option<dom::RGBA>,
    }

    /// Configuration for Window Controls Overlay
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WindowControlsOverlayConfig {
        /// Whether the title bar CSS should be shown when emulating the Window Controls Overlay.
        #[serde(rename = "showCSS")]
        pub show_css: bool,
        /// Selected platforms to show the overlay.
        #[serde(rename = "selectedPlatform")]
        pub selected_platform: String,
        /// The theme color defined in app manifest.
        #[serde(rename = "themeColor")]
        pub theme_color: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContainerQueryHighlightConfig {
        /// A descriptor for the highlight appearance of container query containers.
        #[serde(rename = "containerQueryContainerHighlightConfig")]
        pub container_query_container_highlight_config: ContainerQueryContainerHighlightConfig,
        /// Identifier of the container node to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContainerQueryContainerHighlightConfig {
        /// The style of the container border.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "containerBorder")]
        pub container_border: Option<LineStyle>,
        /// The style of the descendants' borders.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "descendantBorder")]
        pub descendant_border: Option<LineStyle>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IsolatedElementHighlightConfig {
        /// A descriptor for the highlight appearance of an element in isolation mode.
        #[serde(rename = "isolationModeHighlightConfig")]
        pub isolation_mode_highlight_config: IsolationModeHighlightConfig,
        /// Identifier of the isolated element to highlight.
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IsolationModeHighlightConfig {
        /// The fill color of the resizers (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resizerColor")]
        pub resizer_color: Option<dom::RGBA>,
        /// The fill color for resizer handles (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "resizerHandleColor")]
        pub resizer_handle_color: Option<dom::RGBA>,
        /// The fill color for the mask covering non-isolated elements (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maskColor")]
        pub mask_color: Option<dom::RGBA>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InspectMode {
        #[serde(rename = "searchForNode")]
        SearchForNode,
        #[serde(rename = "searchForUAShadowDOM")]
        SearchForUaShadowDom,
        #[serde(rename = "captureAreaScreenshot")]
        CaptureAreaScreenshot,
        #[serde(rename = "none")]
        None,
    }
    impl From<&str> for InspectMode {
        fn from(s: &str) -> Self {
            match s {
                "searchForNode" => Self::SearchForNode,
                "searchForUAShadowDOM" => Self::SearchForUaShadowDom,
                "captureAreaScreenshot" => Self::CaptureAreaScreenshot,
                "none" => Self::None,
                _ => Self::SearchForNode,
            }
        }
    }
    impl From<String> for InspectMode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Disables domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Overlay.disable";
    }

    /// Enables domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Overlay.enable";
    }

    /// For testing.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHighlightObjectForTest {
        /// Id of the node to get highlight object for.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
        /// Whether to include distance info.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeDistance")]
        include_distance: Option<bool>,
        /// Whether to include style info.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeStyle")]
        include_style: Option<bool>,
        /// The color format to get config with (default: hex).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "colorFormat")]
        color_format: Option<ColorFormat>,
        /// Whether to show accessibility info (default: true).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "showAccessibilityInfo")]
        show_accessibility_info: Option<bool>,
    }

    impl GetHighlightObjectForTest {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
                include_distance: None,
                include_style: None,
                color_format: None,
                show_accessibility_info: None,
            }
        }

        pub fn with_include_distance(mut self, include_distance: impl Into<bool>) -> Self {
            self.include_distance = Some(include_distance.into());
            self
        }

        pub fn with_include_style(mut self, include_style: impl Into<bool>) -> Self {
            self.include_style = Some(include_style.into());
            self
        }

        pub fn with_color_format(mut self, color_format: impl Into<ColorFormat>) -> Self {
            self.color_format = Some(color_format.into());
            self
        }

        pub fn with_show_accessibility_info(
            mut self,
            show_accessibility_info: impl Into<bool>,
        ) -> Self {
            self.show_accessibility_info = Some(show_accessibility_info.into());
            self
        }
    }

    impl Command for GetHighlightObjectForTest {
        type Response = GetHighlightObjectForTestResult;
        const METHOD: &'static str = "Overlay.getHighlightObjectForTest";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHighlightObjectForTestResult {
        /// Highlight data for the node.
        pub highlight: serde_json::Value,
    }

    /// For Persistent Grid testing.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetGridHighlightObjectsForTest {
        /// Ids of the node to get highlight object for.
        #[serde(rename = "nodeIds")]
        node_ids: Vec<dom::NodeId>,
    }

    impl GetGridHighlightObjectsForTest {
        pub fn new(node_ids: impl Into<Vec<dom::NodeId>>) -> Self {
            Self {
                node_ids: node_ids.into(),
            }
        }
    }

    impl Command for GetGridHighlightObjectsForTest {
        type Response = GetGridHighlightObjectsForTestResult;
        const METHOD: &'static str = "Overlay.getGridHighlightObjectsForTest";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetGridHighlightObjectsForTestResult {
        /// Grid Highlight data for the node ids provided.
        pub highlights: serde_json::Value,
    }

    /// For Source Order Viewer testing.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSourceOrderHighlightObjectForTest {
        /// Id of the node to highlight.
        #[serde(rename = "nodeId")]
        node_id: dom::NodeId,
    }

    impl GetSourceOrderHighlightObjectForTest {
        pub fn new(node_id: impl Into<dom::NodeId>) -> Self {
            Self {
                node_id: node_id.into(),
            }
        }
    }

    impl Command for GetSourceOrderHighlightObjectForTest {
        type Response = GetSourceOrderHighlightObjectForTestResult;
        const METHOD: &'static str = "Overlay.getSourceOrderHighlightObjectForTest";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSourceOrderHighlightObjectForTestResult {
        /// Source order highlight data for the node id provided.
        pub highlight: serde_json::Value,
    }

    /// Hides any highlight.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HideHighlight {}

    impl HideHighlight {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for HideHighlight {
        type Response = ();
        const METHOD: &'static str = "Overlay.hideHighlight";
    }

    /// Highlights owner element of the frame with given id. Deprecated: Doesn't work reliably and cannot be fixed due to process separation (the owner node might be in a different process). Determine the owner node in the client and use highlightNode.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightFrame {
        /// Identifier of the frame to highlight.
        #[serde(rename = "frameId")]
        frame_id: page::FrameId,
        /// The content box highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentColor")]
        content_color: Option<dom::RGBA>,
        /// The content box highlight outline color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentOutlineColor")]
        content_outline_color: Option<dom::RGBA>,
    }

    impl HighlightFrame {
        pub fn new(frame_id: impl Into<page::FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
                content_color: None,
                content_outline_color: None,
            }
        }

        pub fn with_content_color(mut self, content_color: impl Into<dom::RGBA>) -> Self {
            self.content_color = Some(content_color.into());
            self
        }

        pub fn with_content_outline_color(
            mut self,
            content_outline_color: impl Into<dom::RGBA>,
        ) -> Self {
            self.content_outline_color = Some(content_outline_color.into());
            self
        }
    }

    impl Command for HighlightFrame {
        type Response = ();
        const METHOD: &'static str = "Overlay.highlightFrame";
    }

    /// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightNode {
        /// A descriptor for the highlight appearance.
        #[serde(rename = "highlightConfig")]
        highlight_config: HighlightConfig,
        /// Identifier of the node to highlight.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
        /// Identifier of the backend node to highlight.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// JavaScript object id of the node to be highlighted.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
        /// Selectors to highlight relevant nodes.
        #[serde(skip_serializing_if = "Option::is_none")]
        selector: Option<String>,
    }

    impl HighlightNode {
        pub fn new(highlight_config: impl Into<HighlightConfig>) -> Self {
            Self {
                highlight_config: highlight_config.into(),
                node_id: None,
                backend_node_id: None,
                object_id: None,
                selector: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_selector(mut self, selector: impl Into<String>) -> Self {
            self.selector = Some(selector.into());
            self
        }
    }

    impl Command for HighlightNode {
        type Response = ();
        const METHOD: &'static str = "Overlay.highlightNode";
    }

    /// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightQuad {
        /// Quad to highlight
        quad: dom::Quad,
        /// The highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        color: Option<dom::RGBA>,
        /// The highlight outline color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "outlineColor")]
        outline_color: Option<dom::RGBA>,
    }

    impl HighlightQuad {
        pub fn new(quad: impl Into<dom::Quad>) -> Self {
            Self {
                quad: quad.into(),
                color: None,
                outline_color: None,
            }
        }

        pub fn with_color(mut self, color: impl Into<dom::RGBA>) -> Self {
            self.color = Some(color.into());
            self
        }

        pub fn with_outline_color(mut self, outline_color: impl Into<dom::RGBA>) -> Self {
            self.outline_color = Some(outline_color.into());
            self
        }
    }

    impl Command for HighlightQuad {
        type Response = ();
        const METHOD: &'static str = "Overlay.highlightQuad";
    }

    /// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. Issue: the method does not handle device pixel ratio (DPR) correctly. The coordinates currently have to be adjusted by the client if DPR is not 1 (see crbug.com/437807128).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightRect {
        /// X coordinate
        x: i64,
        /// Y coordinate
        y: i64,
        /// Rectangle width
        width: i64,
        /// Rectangle height
        height: i64,
        /// The highlight fill color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        color: Option<dom::RGBA>,
        /// The highlight outline color (default: transparent).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "outlineColor")]
        outline_color: Option<dom::RGBA>,
    }

    impl HighlightRect {
        pub fn new(
            x: impl Into<i64>,
            y: impl Into<i64>,
            width: impl Into<i64>,
            height: impl Into<i64>,
        ) -> Self {
            Self {
                x: x.into(),
                y: y.into(),
                width: width.into(),
                height: height.into(),
                color: None,
                outline_color: None,
            }
        }

        pub fn with_color(mut self, color: impl Into<dom::RGBA>) -> Self {
            self.color = Some(color.into());
            self
        }

        pub fn with_outline_color(mut self, outline_color: impl Into<dom::RGBA>) -> Self {
            self.outline_color = Some(outline_color.into());
            self
        }
    }

    impl Command for HighlightRect {
        type Response = ();
        const METHOD: &'static str = "Overlay.highlightRect";
    }

    /// Highlights the source order of the children of the DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HighlightSourceOrder {
        /// A descriptor for the appearance of the overlay drawing.
        #[serde(rename = "sourceOrderConfig")]
        source_order_config: SourceOrderConfig,
        /// Identifier of the node to highlight.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        node_id: Option<dom::NodeId>,
        /// Identifier of the backend node to highlight.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        backend_node_id: Option<dom::BackendNodeId>,
        /// JavaScript object id of the node to be highlighted.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<runtime::RemoteObjectId>,
    }

    impl HighlightSourceOrder {
        pub fn new(source_order_config: impl Into<SourceOrderConfig>) -> Self {
            Self {
                source_order_config: source_order_config.into(),
                node_id: None,
                backend_node_id: None,
                object_id: None,
            }
        }

        pub fn with_node_id(mut self, node_id: impl Into<dom::NodeId>) -> Self {
            self.node_id = Some(node_id.into());
            self
        }

        pub fn with_backend_node_id(
            mut self,
            backend_node_id: impl Into<dom::BackendNodeId>,
        ) -> Self {
            self.backend_node_id = Some(backend_node_id.into());
            self
        }

        pub fn with_object_id(mut self, object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }
    }

    impl Command for HighlightSourceOrder {
        type Response = ();
        const METHOD: &'static str = "Overlay.highlightSourceOrder";
    }

    /// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInspectMode {
        /// Set an inspection mode.
        mode: InspectMode,
        /// A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled == false`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "highlightConfig")]
        highlight_config: Option<HighlightConfig>,
    }

    impl SetInspectMode {
        pub fn new(mode: impl Into<InspectMode>) -> Self {
            Self {
                mode: mode.into(),
                highlight_config: None,
            }
        }

        pub fn with_highlight_config(
            mut self,
            highlight_config: impl Into<HighlightConfig>,
        ) -> Self {
            self.highlight_config = Some(highlight_config.into());
            self
        }
    }

    impl Command for SetInspectMode {
        type Response = ();
        const METHOD: &'static str = "Overlay.setInspectMode";
    }

    /// Highlights owner element of all frames detected to be ads.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowAdHighlights {
        /// True for showing ad highlights
        show: bool,
    }

    impl SetShowAdHighlights {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowAdHighlights {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowAdHighlights";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPausedInDebuggerMessage {
        /// The message to display, also triggers resume and step over controls.
        #[serde(skip_serializing_if = "Option::is_none")]
        message: Option<String>,
    }

    impl SetPausedInDebuggerMessage {
        pub fn new() -> Self {
            Self { message: None }
        }

        pub fn with_message(mut self, message: impl Into<String>) -> Self {
            self.message = Some(message.into());
            self
        }
    }

    impl Command for SetPausedInDebuggerMessage {
        type Response = ();
        const METHOD: &'static str = "Overlay.setPausedInDebuggerMessage";
    }

    /// Requests that backend shows debug borders on layers
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowDebugBorders {
        /// True for showing debug borders
        show: bool,
    }

    impl SetShowDebugBorders {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowDebugBorders {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowDebugBorders";
    }

    /// Requests that backend shows the FPS counter
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowFpsCounter {
        /// True for showing the FPS counter
        show: bool,
    }

    impl SetShowFpsCounter {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowFpsCounter {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowFPSCounter";
    }

    /// Highlight multiple elements with the CSS Grid overlay.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowGridOverlays {
        /// An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "gridNodeHighlightConfigs")]
        grid_node_highlight_configs: Vec<GridNodeHighlightConfig>,
    }

    impl SetShowGridOverlays {
        pub fn new(grid_node_highlight_configs: impl Into<Vec<GridNodeHighlightConfig>>) -> Self {
            Self {
                grid_node_highlight_configs: grid_node_highlight_configs.into(),
            }
        }
    }

    impl Command for SetShowGridOverlays {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowGridOverlays";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowFlexOverlays {
        /// An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "flexNodeHighlightConfigs")]
        flex_node_highlight_configs: Vec<FlexNodeHighlightConfig>,
    }

    impl SetShowFlexOverlays {
        pub fn new(flex_node_highlight_configs: impl Into<Vec<FlexNodeHighlightConfig>>) -> Self {
            Self {
                flex_node_highlight_configs: flex_node_highlight_configs.into(),
            }
        }
    }

    impl Command for SetShowFlexOverlays {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowFlexOverlays";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowScrollSnapOverlays {
        /// An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "scrollSnapHighlightConfigs")]
        scroll_snap_highlight_configs: Vec<ScrollSnapHighlightConfig>,
    }

    impl SetShowScrollSnapOverlays {
        pub fn new(
            scroll_snap_highlight_configs: impl Into<Vec<ScrollSnapHighlightConfig>>,
        ) -> Self {
            Self {
                scroll_snap_highlight_configs: scroll_snap_highlight_configs.into(),
            }
        }
    }

    impl Command for SetShowScrollSnapOverlays {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowScrollSnapOverlays";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowContainerQueryOverlays {
        /// An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "containerQueryHighlightConfigs")]
        container_query_highlight_configs: Vec<ContainerQueryHighlightConfig>,
    }

    impl SetShowContainerQueryOverlays {
        pub fn new(
            container_query_highlight_configs: impl Into<Vec<ContainerQueryHighlightConfig>>,
        ) -> Self {
            Self {
                container_query_highlight_configs: container_query_highlight_configs.into(),
            }
        }
    }

    impl Command for SetShowContainerQueryOverlays {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowContainerQueryOverlays";
    }

    /// Requests that backend shows paint rectangles
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowPaintRects {
        /// True for showing paint rectangles
        result: bool,
    }

    impl SetShowPaintRects {
        pub fn new(result: impl Into<bool>) -> Self {
            Self {
                result: result.into(),
            }
        }
    }

    impl Command for SetShowPaintRects {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowPaintRects";
    }

    /// Requests that backend shows layout shift regions
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowLayoutShiftRegions {
        /// True for showing layout shift regions
        result: bool,
    }

    impl SetShowLayoutShiftRegions {
        pub fn new(result: impl Into<bool>) -> Self {
            Self {
                result: result.into(),
            }
        }
    }

    impl Command for SetShowLayoutShiftRegions {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowLayoutShiftRegions";
    }

    /// Requests that backend shows scroll bottleneck rects
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowScrollBottleneckRects {
        /// True for showing scroll bottleneck rects
        show: bool,
    }

    impl SetShowScrollBottleneckRects {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowScrollBottleneckRects {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowScrollBottleneckRects";
    }

    /// Deprecated, no longer has any effect.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowHitTestBorders {
        /// True for showing hit-test borders
        show: bool,
    }

    impl SetShowHitTestBorders {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowHitTestBorders {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowHitTestBorders";
    }

    /// Deprecated, no longer has any effect.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowWebVitals {
        show: bool,
    }

    impl SetShowWebVitals {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowWebVitals {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowWebVitals";
    }

    /// Paints viewport size upon main frame resize.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowViewportSizeOnResize {
        /// Whether to paint size or not.
        show: bool,
    }

    impl SetShowViewportSizeOnResize {
        pub fn new(show: impl Into<bool>) -> Self {
            Self { show: show.into() }
        }
    }

    impl Command for SetShowViewportSizeOnResize {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowViewportSizeOnResize";
    }

    /// Add a dual screen device hinge
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowHinge {
        /// hinge data, null means hideHinge
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hingeConfig")]
        hinge_config: Option<HingeConfig>,
    }

    impl SetShowHinge {
        pub fn new() -> Self {
            Self { hinge_config: None }
        }

        pub fn with_hinge_config(mut self, hinge_config: impl Into<HingeConfig>) -> Self {
            self.hinge_config = Some(hinge_config.into());
            self
        }
    }

    impl Command for SetShowHinge {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowHinge";
    }

    /// Show elements in isolation mode with overlays.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowIsolatedElements {
        /// An array of node identifiers and descriptors for the highlight appearance.
        #[serde(rename = "isolatedElementHighlightConfigs")]
        isolated_element_highlight_configs: Vec<IsolatedElementHighlightConfig>,
    }

    impl SetShowIsolatedElements {
        pub fn new(
            isolated_element_highlight_configs: impl Into<Vec<IsolatedElementHighlightConfig>>,
        ) -> Self {
            Self {
                isolated_element_highlight_configs: isolated_element_highlight_configs.into(),
            }
        }
    }

    impl Command for SetShowIsolatedElements {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowIsolatedElements";
    }

    /// Show Window Controls Overlay for PWA
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetShowWindowControlsOverlay {
        /// Window Controls Overlay data, null means hide Window Controls Overlay
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "windowControlsOverlayConfig")]
        window_controls_overlay_config: Option<WindowControlsOverlayConfig>,
    }

    impl SetShowWindowControlsOverlay {
        pub fn new() -> Self {
            Self {
                window_controls_overlay_config: None,
            }
        }

        pub fn with_window_controls_overlay_config(
            mut self,
            window_controls_overlay_config: impl Into<WindowControlsOverlayConfig>,
        ) -> Self {
            self.window_controls_overlay_config = Some(window_controls_overlay_config.into());
            self
        }
    }

    impl Command for SetShowWindowControlsOverlay {
        type Response = ();
        const METHOD: &'static str = "Overlay.setShowWindowControlsOverlay";
    }

    /// Fired when the node should be inspected. This happens after call to `setInspectMode` or when user manually inspects an element.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InspectNodeRequested {
        /// Id of the node to inspect.
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: dom::BackendNodeId,
    }

    impl InspectNodeRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Overlay.inspectNodeRequested")
        }
    }

    /// Fired when the node should be highlighted. This happens after call to `setInspectMode`.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodeHighlightRequested {
        #[serde(rename = "nodeId")]
        pub node_id: dom::NodeId,
    }

    impl NodeHighlightRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Overlay.nodeHighlightRequested")
        }
    }

    /// Fired when user asks to capture screenshot of some area on the page.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreenshotRequested {
        /// Viewport to capture, in device independent pixels (dip).
        pub viewport: page::Viewport,
    }

    impl ScreenshotRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Overlay.screenshotRequested")
        }
    }

    /// Fired when user cancels the inspect mode.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InspectModeCanceled {}

    impl InspectModeCanceled {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Overlay.inspectModeCanceled")
        }
    }
}

pub mod pwa {
    use super::*;

    /// The following types are the replica of https://crsrc.org/c/chrome/browser/web_applications/proto/web_app_os_integration_state.proto;drc=9910d3be894c8f142c977ba1023f30a656bc13fc;l=67
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FileHandlerAccept {
        /// New name of the mimetype according to https://www.iana.org/assignments/media-types/media-types.xhtml
        #[serde(rename = "mediaType")]
        pub media_type: String,
        #[serde(rename = "fileExtensions")]
        pub file_extensions: Vec<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FileHandler {
        pub action: String,
        pub accepts: Vec<FileHandlerAccept>,
        #[serde(rename = "displayName")]
        pub display_name: String,
    }

    /// If user prefers opening the app in browser or an app window.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DisplayMode {
        #[serde(rename = "standalone")]
        Standalone,
        #[serde(rename = "browser")]
        Browser,
    }
    impl From<&str> for DisplayMode {
        fn from(s: &str) -> Self {
            match s {
                "standalone" => Self::Standalone,
                "browser" => Self::Browser,
                _ => Self::Standalone,
            }
        }
    }
    impl From<String> for DisplayMode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Returns the following OS state for the given manifest id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOsAppState {
        /// The id from the webapp's manifest file, commonly it's the url of the site installing the webapp. See https://web.dev/learn/pwa/web-app-manifest.
        #[serde(rename = "manifestId")]
        manifest_id: String,
    }

    impl GetOsAppState {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
            }
        }
    }

    impl Command for GetOsAppState {
        type Response = GetOsAppStateResult;
        const METHOD: &'static str = "PWA.getOsAppState";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOsAppStateResult {
        #[serde(rename = "badgeCount")]
        pub badge_count: i64,
        #[serde(rename = "fileHandlers")]
        pub file_handlers: Vec<FileHandler>,
    }

    /// Installs the given manifest identity, optionally using the given installUrlOrBundleUrl IWA-specific install description: manifestId corresponds to isolated-app:// + web_package::SignedWebBundleId File installation mode: The installUrlOrBundleUrl can be either file:// or http(s):// pointing to a signed web bundle (.swbn). In this case SignedWebBundleId must correspond to The .swbn file's signing key. Dev proxy installation mode: installUrlOrBundleUrl must be http(s):// that serves dev mode IWA. web_package::SignedWebBundleId must be of type dev proxy. The advantage of dev proxy mode is that all changes to IWA automatically will be reflected in the running app without reinstallation. To generate bundle id for proxy mode: 1. Generate 32 random bytes. 2. Add a specific suffix at the end following the documentation  https://github.com/WICG/isolated-web-apps/blob/main/Scheme.md#suffix 3. Encode the entire sequence using Base32 without padding. If Chrome is not in IWA dev mode, the installation will fail, regardless of the state of the allowlist.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Install {
        #[serde(rename = "manifestId")]
        manifest_id: String,
        /// The location of the app or bundle overriding the one derived from the manifestId.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "installUrlOrBundleUrl")]
        install_url_or_bundle_url: Option<String>,
    }

    impl Install {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
                install_url_or_bundle_url: None,
            }
        }

        pub fn with_install_url_or_bundle_url(
            mut self,
            install_url_or_bundle_url: impl Into<String>,
        ) -> Self {
            self.install_url_or_bundle_url = Some(install_url_or_bundle_url.into());
            self
        }
    }

    impl Command for Install {
        type Response = ();
        const METHOD: &'static str = "PWA.install";
    }

    /// Uninstalls the given manifest_id and closes any opened app windows.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Uninstall {
        #[serde(rename = "manifestId")]
        manifest_id: String,
    }

    impl Uninstall {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
            }
        }
    }

    impl Command for Uninstall {
        type Response = ();
        const METHOD: &'static str = "PWA.uninstall";
    }

    /// Launches the installed web app, or an url in the same web app instead of the default start url if it is provided. Returns a page Target.TargetID which can be used to attach to via Target.attachToTarget or similar APIs.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Launch {
        #[serde(rename = "manifestId")]
        manifest_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
    }

    impl Launch {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
                url: None,
            }
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }
    }

    impl Command for Launch {
        type Response = LaunchResult;
        const METHOD: &'static str = "PWA.launch";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LaunchResult {
        /// ID of the tab target created as a result.
        #[serde(rename = "targetId")]
        pub target_id: target::TargetID,
    }

    /// Opens one or more local files from an installed web app identified by its manifestId. The web app needs to have file handlers registered to process the files. The API returns one or more page Target.TargetIDs which can be used to attach to via Target.attachToTarget or similar APIs. If some files in the parameters cannot be handled by the web app, they will be ignored. If none of the files can be handled, this API returns an error. If no files are provided as the parameter, this API also returns an error. According to the definition of the file handlers in the manifest file, one Target.TargetID may represent a page handling one or more files. The order of the returned Target.TargetIDs is not guaranteed. TODO(crbug.com/339454034): Check the existences of the input files.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LaunchFilesInApp {
        #[serde(rename = "manifestId")]
        manifest_id: String,
        files: Vec<String>,
    }

    impl LaunchFilesInApp {
        pub fn new(manifest_id: impl Into<String>, files: impl Into<Vec<String>>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
                files: files.into(),
            }
        }
    }

    impl Command for LaunchFilesInApp {
        type Response = LaunchFilesInAppResult;
        const METHOD: &'static str = "PWA.launchFilesInApp";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LaunchFilesInAppResult {
        /// IDs of the tab targets created as the result.
        #[serde(rename = "targetIds")]
        pub target_ids: Vec<target::TargetID>,
    }

    /// Opens the current page in its web app identified by the manifest id, needs to be called on a page target. This function returns immediately without waiting for the app to finish loading.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OpenCurrentPageInApp {
        #[serde(rename = "manifestId")]
        manifest_id: String,
    }

    impl OpenCurrentPageInApp {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
            }
        }
    }

    impl Command for OpenCurrentPageInApp {
        type Response = ();
        const METHOD: &'static str = "PWA.openCurrentPageInApp";
    }

    /// Changes user settings of the web app identified by its manifestId. If the app was not installed, this command returns an error. Unset parameters will be ignored; unrecognized values will cause an error. Unlike the ones defined in the manifest files of the web apps, these settings are provided by the browser and controlled by the users, they impact the way the browser handling the web apps. See the comment of each parameter.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ChangeAppUserSettings {
        #[serde(rename = "manifestId")]
        manifest_id: String,
        /// If user allows the links clicked on by the user in the app's scope, or extended scope if the manifest has scope extensions and the flags `DesktopPWAsLinkCapturingWithScopeExtensions` and `WebAppEnableScopeExtensions` are enabled. Note, the API does not support resetting the linkCapturing to the initial value, uninstalling and installing the web app again will reset it. TODO(crbug.com/339453269): Setting this value on ChromeOS is not supported yet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "linkCapturing")]
        link_capturing: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "displayMode")]
        display_mode: Option<DisplayMode>,
    }

    impl ChangeAppUserSettings {
        pub fn new(manifest_id: impl Into<String>) -> Self {
            Self {
                manifest_id: manifest_id.into(),
                link_capturing: None,
                display_mode: None,
            }
        }

        pub fn with_link_capturing(mut self, link_capturing: impl Into<bool>) -> Self {
            self.link_capturing = Some(link_capturing.into());
            self
        }

        pub fn with_display_mode(mut self, display_mode: impl Into<DisplayMode>) -> Self {
            self.display_mode = Some(display_mode.into());
            self
        }
    }

    impl Command for ChangeAppUserSettings {
        type Response = ();
        const METHOD: &'static str = "PWA.changeAppUserSettings";
    }
}

pub mod page {
    use super::*;

    /// Unique frame identifier.
    pub type FrameId = String;

    /// Indicates whether a frame has been identified as an ad.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AdFrameType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "child")]
        Child,
        #[serde(rename = "root")]
        Root,
    }
    impl From<&str> for AdFrameType {
        fn from(s: &str) -> Self {
            match s {
                "none" => Self::None,
                "child" => Self::Child,
                "root" => Self::Root,
                _ => Self::None,
            }
        }
    }
    impl From<String> for AdFrameType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AdFrameExplanation {
        #[serde(rename = "ParentIsAd")]
        ParentIsAd,
        #[serde(rename = "CreatedByAdScript")]
        CreatedByAdScript,
        #[serde(rename = "MatchedBlockingRule")]
        MatchedBlockingRule,
    }
    impl From<&str> for AdFrameExplanation {
        fn from(s: &str) -> Self {
            match s {
                "ParentIsAd" => Self::ParentIsAd,
                "CreatedByAdScript" => Self::CreatedByAdScript,
                "MatchedBlockingRule" => Self::MatchedBlockingRule,
                _ => Self::ParentIsAd,
            }
        }
    }
    impl From<String> for AdFrameExplanation {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates whether a frame has been identified as an ad and why.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AdFrameStatus {
        #[serde(rename = "adFrameType")]
        pub ad_frame_type: AdFrameType,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub explanations: Option<Vec<AdFrameExplanation>>,
    }

    /// Identifies the script which caused a script or frame to be labelled as an ad.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AdScriptId {
        /// Script Id of the script which caused a script or frame to be labelled as an ad.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// Id of scriptId's debugger.
        #[serde(rename = "debuggerId")]
        pub debugger_id: runtime::UniqueDebuggerId,
    }

    /// Encapsulates the script ancestry and the root script filterlist rule that caused the frame to be labelled as an ad. Only created when `ancestryChain` is not empty.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AdScriptAncestry {
        /// A chain of `AdScriptId`s representing the ancestry of an ad script that led to the creation of a frame. The chain is ordered from the script itself (lower level) up to its root ancestor that was flagged by filterlist.
        #[serde(rename = "ancestryChain")]
        pub ancestry_chain: Vec<AdScriptId>,
        /// The filterlist rule that caused the root (last) script in `ancestryChain` to be ad-tagged. Only populated if the rule is available.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rootScriptFilterlistRule")]
        pub root_script_filterlist_rule: Option<String>,
    }

    /// Indicates whether the frame is a secure context and why it is the case.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SecureContextType {
        #[serde(rename = "Secure")]
        Secure,
        #[serde(rename = "SecureLocalhost")]
        SecureLocalhost,
        #[serde(rename = "InsecureScheme")]
        InsecureScheme,
        #[serde(rename = "InsecureAncestor")]
        InsecureAncestor,
    }
    impl From<&str> for SecureContextType {
        fn from(s: &str) -> Self {
            match s {
                "Secure" => Self::Secure,
                "SecureLocalhost" => Self::SecureLocalhost,
                "InsecureScheme" => Self::InsecureScheme,
                "InsecureAncestor" => Self::InsecureAncestor,
                _ => Self::Secure,
            }
        }
    }
    impl From<String> for SecureContextType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates whether the frame is cross-origin isolated and why it is the case.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CrossOriginIsolatedContextType {
        #[serde(rename = "Isolated")]
        Isolated,
        #[serde(rename = "NotIsolated")]
        NotIsolated,
        #[serde(rename = "NotIsolatedFeatureDisabled")]
        NotIsolatedFeatureDisabled,
    }
    impl From<&str> for CrossOriginIsolatedContextType {
        fn from(s: &str) -> Self {
            match s {
                "Isolated" => Self::Isolated,
                "NotIsolated" => Self::NotIsolated,
                "NotIsolatedFeatureDisabled" => Self::NotIsolatedFeatureDisabled,
                _ => Self::Isolated,
            }
        }
    }
    impl From<String> for CrossOriginIsolatedContextType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum GatedAPIFeatures {
        #[serde(rename = "SharedArrayBuffers")]
        SharedArrayBuffers,
        #[serde(rename = "SharedArrayBuffersTransferAllowed")]
        SharedArrayBuffersTransferAllowed,
        #[serde(rename = "PerformanceMeasureMemory")]
        PerformanceMeasureMemory,
        #[serde(rename = "PerformanceProfile")]
        PerformanceProfile,
    }
    impl From<&str> for GatedAPIFeatures {
        fn from(s: &str) -> Self {
            match s {
                "SharedArrayBuffers" => Self::SharedArrayBuffers,
                "SharedArrayBuffersTransferAllowed" => Self::SharedArrayBuffersTransferAllowed,
                "PerformanceMeasureMemory" => Self::PerformanceMeasureMemory,
                "PerformanceProfile" => Self::PerformanceProfile,
                _ => Self::SharedArrayBuffers,
            }
        }
    }
    impl From<String> for GatedAPIFeatures {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// All Permissions Policy features. This enum should match the one defined in services/network/public/cpp/permissions_policy/permissions_policy_features.json5. LINT.IfChange(PermissionsPolicyFeature)
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PermissionsPolicyFeature {
        #[serde(rename = "accelerometer")]
        Accelerometer,
        #[serde(rename = "all-screens-capture")]
        AllScreensCapture,
        #[serde(rename = "ambient-light-sensor")]
        AmbientLightSensor,
        #[serde(rename = "aria-notify")]
        AriaNotify,
        #[serde(rename = "attribution-reporting")]
        AttributionReporting,
        #[serde(rename = "autofill")]
        Autofill,
        #[serde(rename = "autoplay")]
        Autoplay,
        #[serde(rename = "bluetooth")]
        Bluetooth,
        #[serde(rename = "browsing-topics")]
        BrowsingTopics,
        #[serde(rename = "camera")]
        Camera,
        #[serde(rename = "captured-surface-control")]
        CapturedSurfaceControl,
        #[serde(rename = "ch-dpr")]
        ChDpr,
        #[serde(rename = "ch-device-memory")]
        ChDeviceMemory,
        #[serde(rename = "ch-downlink")]
        ChDownlink,
        #[serde(rename = "ch-ect")]
        ChEct,
        #[serde(rename = "ch-prefers-color-scheme")]
        ChPrefersColorScheme,
        #[serde(rename = "ch-prefers-reduced-motion")]
        ChPrefersReducedMotion,
        #[serde(rename = "ch-prefers-reduced-transparency")]
        ChPrefersReducedTransparency,
        #[serde(rename = "ch-rtt")]
        ChRtt,
        #[serde(rename = "ch-save-data")]
        ChSaveData,
        #[serde(rename = "ch-ua")]
        ChUa,
        #[serde(rename = "ch-ua-arch")]
        ChUaArch,
        #[serde(rename = "ch-ua-bitness")]
        ChUaBitness,
        #[serde(rename = "ch-ua-high-entropy-values")]
        ChUaHighEntropyValues,
        #[serde(rename = "ch-ua-platform")]
        ChUaPlatform,
        #[serde(rename = "ch-ua-model")]
        ChUaModel,
        #[serde(rename = "ch-ua-mobile")]
        ChUaMobile,
        #[serde(rename = "ch-ua-form-factors")]
        ChUaFormFactors,
        #[serde(rename = "ch-ua-full-version")]
        ChUaFullVersion,
        #[serde(rename = "ch-ua-full-version-list")]
        ChUaFullVersionList,
        #[serde(rename = "ch-ua-platform-version")]
        ChUaPlatformVersion,
        #[serde(rename = "ch-ua-wow64")]
        ChUaWow64,
        #[serde(rename = "ch-viewport-height")]
        ChViewportHeight,
        #[serde(rename = "ch-viewport-width")]
        ChViewportWidth,
        #[serde(rename = "ch-width")]
        ChWidth,
        #[serde(rename = "clipboard-read")]
        ClipboardRead,
        #[serde(rename = "clipboard-write")]
        ClipboardWrite,
        #[serde(rename = "compute-pressure")]
        ComputePressure,
        #[serde(rename = "controlled-frame")]
        ControlledFrame,
        #[serde(rename = "cross-origin-isolated")]
        CrossOriginIsolated,
        #[serde(rename = "deferred-fetch")]
        DeferredFetch,
        #[serde(rename = "deferred-fetch-minimal")]
        DeferredFetchMinimal,
        #[serde(rename = "device-attributes")]
        DeviceAttributes,
        #[serde(rename = "digital-credentials-create")]
        DigitalCredentialsCreate,
        #[serde(rename = "digital-credentials-get")]
        DigitalCredentialsGet,
        #[serde(rename = "direct-sockets")]
        DirectSockets,
        #[serde(rename = "direct-sockets-multicast")]
        DirectSocketsMulticast,
        #[serde(rename = "direct-sockets-private")]
        DirectSocketsPrivate,
        #[serde(rename = "display-capture")]
        DisplayCapture,
        #[serde(rename = "document-domain")]
        DocumentDomain,
        #[serde(rename = "encrypted-media")]
        EncryptedMedia,
        #[serde(rename = "execution-while-out-of-viewport")]
        ExecutionWhileOutOfViewport,
        #[serde(rename = "execution-while-not-rendered")]
        ExecutionWhileNotRendered,
        #[serde(rename = "fenced-unpartitioned-storage-read")]
        FencedUnpartitionedStorageRead,
        #[serde(rename = "focus-without-user-activation")]
        FocusWithoutUserActivation,
        #[serde(rename = "fullscreen")]
        Fullscreen,
        #[serde(rename = "frobulate")]
        Frobulate,
        #[serde(rename = "gamepad")]
        Gamepad,
        #[serde(rename = "geolocation")]
        Geolocation,
        #[serde(rename = "gyroscope")]
        Gyroscope,
        #[serde(rename = "hid")]
        Hid,
        #[serde(rename = "identity-credentials-get")]
        IdentityCredentialsGet,
        #[serde(rename = "idle-detection")]
        IdleDetection,
        #[serde(rename = "interest-cohort")]
        InterestCohort,
        #[serde(rename = "join-ad-interest-group")]
        JoinAdInterestGroup,
        #[serde(rename = "keyboard-map")]
        KeyboardMap,
        #[serde(rename = "language-detector")]
        LanguageDetector,
        #[serde(rename = "language-model")]
        LanguageModel,
        #[serde(rename = "local-fonts")]
        LocalFonts,
        #[serde(rename = "local-network")]
        LocalNetwork,
        #[serde(rename = "local-network-access")]
        LocalNetworkAccess,
        #[serde(rename = "loopback-network")]
        LoopbackNetwork,
        #[serde(rename = "magnetometer")]
        Magnetometer,
        #[serde(rename = "manual-text")]
        ManualText,
        #[serde(rename = "media-playback-while-not-visible")]
        MediaPlaybackWhileNotVisible,
        #[serde(rename = "microphone")]
        Microphone,
        #[serde(rename = "midi")]
        Midi,
        #[serde(rename = "on-device-speech-recognition")]
        OnDeviceSpeechRecognition,
        #[serde(rename = "otp-credentials")]
        OtpCredentials,
        #[serde(rename = "payment")]
        Payment,
        #[serde(rename = "picture-in-picture")]
        PictureInPicture,
        #[serde(rename = "private-aggregation")]
        PrivateAggregation,
        #[serde(rename = "private-state-token-issuance")]
        PrivateStateTokenIssuance,
        #[serde(rename = "private-state-token-redemption")]
        PrivateStateTokenRedemption,
        #[serde(rename = "publickey-credentials-create")]
        PublickeyCredentialsCreate,
        #[serde(rename = "publickey-credentials-get")]
        PublickeyCredentialsGet,
        #[serde(rename = "record-ad-auction-events")]
        RecordAdAuctionEvents,
        #[serde(rename = "rewriter")]
        Rewriter,
        #[serde(rename = "run-ad-auction")]
        RunAdAuction,
        #[serde(rename = "screen-wake-lock")]
        ScreenWakeLock,
        #[serde(rename = "serial")]
        Serial,
        #[serde(rename = "shared-storage")]
        SharedStorage,
        #[serde(rename = "shared-storage-select-url")]
        SharedStorageSelectUrl,
        #[serde(rename = "smart-card")]
        SmartCard,
        #[serde(rename = "speaker-selection")]
        SpeakerSelection,
        #[serde(rename = "storage-access")]
        StorageAccess,
        #[serde(rename = "sub-apps")]
        SubApps,
        #[serde(rename = "summarizer")]
        Summarizer,
        #[serde(rename = "sync-xhr")]
        SyncXhr,
        #[serde(rename = "translator")]
        Translator,
        #[serde(rename = "unload")]
        Unload,
        #[serde(rename = "usb")]
        Usb,
        #[serde(rename = "usb-unrestricted")]
        UsbUnrestricted,
        #[serde(rename = "vertical-scroll")]
        VerticalScroll,
        #[serde(rename = "web-app-installation")]
        WebAppInstallation,
        #[serde(rename = "web-printing")]
        WebPrinting,
        #[serde(rename = "web-share")]
        WebShare,
        #[serde(rename = "window-management")]
        WindowManagement,
        #[serde(rename = "writer")]
        Writer,
        #[serde(rename = "xr-spatial-tracking")]
        XrSpatialTracking,
    }
    impl From<&str> for PermissionsPolicyFeature {
        fn from(s: &str) -> Self {
            match s {
                "accelerometer" => Self::Accelerometer,
                "all-screens-capture" => Self::AllScreensCapture,
                "ambient-light-sensor" => Self::AmbientLightSensor,
                "aria-notify" => Self::AriaNotify,
                "attribution-reporting" => Self::AttributionReporting,
                "autofill" => Self::Autofill,
                "autoplay" => Self::Autoplay,
                "bluetooth" => Self::Bluetooth,
                "browsing-topics" => Self::BrowsingTopics,
                "camera" => Self::Camera,
                "captured-surface-control" => Self::CapturedSurfaceControl,
                "ch-dpr" => Self::ChDpr,
                "ch-device-memory" => Self::ChDeviceMemory,
                "ch-downlink" => Self::ChDownlink,
                "ch-ect" => Self::ChEct,
                "ch-prefers-color-scheme" => Self::ChPrefersColorScheme,
                "ch-prefers-reduced-motion" => Self::ChPrefersReducedMotion,
                "ch-prefers-reduced-transparency" => Self::ChPrefersReducedTransparency,
                "ch-rtt" => Self::ChRtt,
                "ch-save-data" => Self::ChSaveData,
                "ch-ua" => Self::ChUa,
                "ch-ua-arch" => Self::ChUaArch,
                "ch-ua-bitness" => Self::ChUaBitness,
                "ch-ua-high-entropy-values" => Self::ChUaHighEntropyValues,
                "ch-ua-platform" => Self::ChUaPlatform,
                "ch-ua-model" => Self::ChUaModel,
                "ch-ua-mobile" => Self::ChUaMobile,
                "ch-ua-form-factors" => Self::ChUaFormFactors,
                "ch-ua-full-version" => Self::ChUaFullVersion,
                "ch-ua-full-version-list" => Self::ChUaFullVersionList,
                "ch-ua-platform-version" => Self::ChUaPlatformVersion,
                "ch-ua-wow64" => Self::ChUaWow64,
                "ch-viewport-height" => Self::ChViewportHeight,
                "ch-viewport-width" => Self::ChViewportWidth,
                "ch-width" => Self::ChWidth,
                "clipboard-read" => Self::ClipboardRead,
                "clipboard-write" => Self::ClipboardWrite,
                "compute-pressure" => Self::ComputePressure,
                "controlled-frame" => Self::ControlledFrame,
                "cross-origin-isolated" => Self::CrossOriginIsolated,
                "deferred-fetch" => Self::DeferredFetch,
                "deferred-fetch-minimal" => Self::DeferredFetchMinimal,
                "device-attributes" => Self::DeviceAttributes,
                "digital-credentials-create" => Self::DigitalCredentialsCreate,
                "digital-credentials-get" => Self::DigitalCredentialsGet,
                "direct-sockets" => Self::DirectSockets,
                "direct-sockets-multicast" => Self::DirectSocketsMulticast,
                "direct-sockets-private" => Self::DirectSocketsPrivate,
                "display-capture" => Self::DisplayCapture,
                "document-domain" => Self::DocumentDomain,
                "encrypted-media" => Self::EncryptedMedia,
                "execution-while-out-of-viewport" => Self::ExecutionWhileOutOfViewport,
                "execution-while-not-rendered" => Self::ExecutionWhileNotRendered,
                "fenced-unpartitioned-storage-read" => Self::FencedUnpartitionedStorageRead,
                "focus-without-user-activation" => Self::FocusWithoutUserActivation,
                "fullscreen" => Self::Fullscreen,
                "frobulate" => Self::Frobulate,
                "gamepad" => Self::Gamepad,
                "geolocation" => Self::Geolocation,
                "gyroscope" => Self::Gyroscope,
                "hid" => Self::Hid,
                "identity-credentials-get" => Self::IdentityCredentialsGet,
                "idle-detection" => Self::IdleDetection,
                "interest-cohort" => Self::InterestCohort,
                "join-ad-interest-group" => Self::JoinAdInterestGroup,
                "keyboard-map" => Self::KeyboardMap,
                "language-detector" => Self::LanguageDetector,
                "language-model" => Self::LanguageModel,
                "local-fonts" => Self::LocalFonts,
                "local-network" => Self::LocalNetwork,
                "local-network-access" => Self::LocalNetworkAccess,
                "loopback-network" => Self::LoopbackNetwork,
                "magnetometer" => Self::Magnetometer,
                "manual-text" => Self::ManualText,
                "media-playback-while-not-visible" => Self::MediaPlaybackWhileNotVisible,
                "microphone" => Self::Microphone,
                "midi" => Self::Midi,
                "on-device-speech-recognition" => Self::OnDeviceSpeechRecognition,
                "otp-credentials" => Self::OtpCredentials,
                "payment" => Self::Payment,
                "picture-in-picture" => Self::PictureInPicture,
                "private-aggregation" => Self::PrivateAggregation,
                "private-state-token-issuance" => Self::PrivateStateTokenIssuance,
                "private-state-token-redemption" => Self::PrivateStateTokenRedemption,
                "publickey-credentials-create" => Self::PublickeyCredentialsCreate,
                "publickey-credentials-get" => Self::PublickeyCredentialsGet,
                "record-ad-auction-events" => Self::RecordAdAuctionEvents,
                "rewriter" => Self::Rewriter,
                "run-ad-auction" => Self::RunAdAuction,
                "screen-wake-lock" => Self::ScreenWakeLock,
                "serial" => Self::Serial,
                "shared-storage" => Self::SharedStorage,
                "shared-storage-select-url" => Self::SharedStorageSelectUrl,
                "smart-card" => Self::SmartCard,
                "speaker-selection" => Self::SpeakerSelection,
                "storage-access" => Self::StorageAccess,
                "sub-apps" => Self::SubApps,
                "summarizer" => Self::Summarizer,
                "sync-xhr" => Self::SyncXhr,
                "translator" => Self::Translator,
                "unload" => Self::Unload,
                "usb" => Self::Usb,
                "usb-unrestricted" => Self::UsbUnrestricted,
                "vertical-scroll" => Self::VerticalScroll,
                "web-app-installation" => Self::WebAppInstallation,
                "web-printing" => Self::WebPrinting,
                "web-share" => Self::WebShare,
                "window-management" => Self::WindowManagement,
                "writer" => Self::Writer,
                "xr-spatial-tracking" => Self::XrSpatialTracking,
                _ => Self::Accelerometer,
            }
        }
    }
    impl From<String> for PermissionsPolicyFeature {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Reason for a permissions policy feature to be disabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PermissionsPolicyBlockReason {
        #[serde(rename = "Header")]
        Header,
        #[serde(rename = "IframeAttribute")]
        IframeAttribute,
        #[serde(rename = "InFencedFrameTree")]
        InFencedFrameTree,
        #[serde(rename = "InIsolatedApp")]
        InIsolatedApp,
    }
    impl From<&str> for PermissionsPolicyBlockReason {
        fn from(s: &str) -> Self {
            match s {
                "Header" => Self::Header,
                "IframeAttribute" => Self::IframeAttribute,
                "InFencedFrameTree" => Self::InFencedFrameTree,
                "InIsolatedApp" => Self::InIsolatedApp,
                _ => Self::Header,
            }
        }
    }
    impl From<String> for PermissionsPolicyBlockReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PermissionsPolicyBlockLocator {
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        #[serde(rename = "blockReason")]
        pub block_reason: PermissionsPolicyBlockReason,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PermissionsPolicyFeatureState {
        pub feature: PermissionsPolicyFeature,
        pub allowed: bool,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub locator: Option<PermissionsPolicyBlockLocator>,
    }

    /// Origin Trial(https://www.chromium.org/blink/origin-trials) support. Status for an Origin Trial token.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum OriginTrialTokenStatus {
        #[serde(rename = "Success")]
        Success,
        #[serde(rename = "NotSupported")]
        NotSupported,
        #[serde(rename = "Insecure")]
        Insecure,
        #[serde(rename = "Expired")]
        Expired,
        #[serde(rename = "WrongOrigin")]
        WrongOrigin,
        #[serde(rename = "InvalidSignature")]
        InvalidSignature,
        #[serde(rename = "Malformed")]
        Malformed,
        #[serde(rename = "WrongVersion")]
        WrongVersion,
        #[serde(rename = "FeatureDisabled")]
        FeatureDisabled,
        #[serde(rename = "TokenDisabled")]
        TokenDisabled,
        #[serde(rename = "FeatureDisabledForUser")]
        FeatureDisabledForUser,
        #[serde(rename = "UnknownTrial")]
        UnknownTrial,
    }
    impl From<&str> for OriginTrialTokenStatus {
        fn from(s: &str) -> Self {
            match s {
                "Success" => Self::Success,
                "NotSupported" => Self::NotSupported,
                "Insecure" => Self::Insecure,
                "Expired" => Self::Expired,
                "WrongOrigin" => Self::WrongOrigin,
                "InvalidSignature" => Self::InvalidSignature,
                "Malformed" => Self::Malformed,
                "WrongVersion" => Self::WrongVersion,
                "FeatureDisabled" => Self::FeatureDisabled,
                "TokenDisabled" => Self::TokenDisabled,
                "FeatureDisabledForUser" => Self::FeatureDisabledForUser,
                "UnknownTrial" => Self::UnknownTrial,
                _ => Self::Success,
            }
        }
    }
    impl From<String> for OriginTrialTokenStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Status for an Origin Trial.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum OriginTrialStatus {
        #[serde(rename = "Enabled")]
        Enabled,
        #[serde(rename = "ValidTokenNotProvided")]
        ValidTokenNotProvided,
        #[serde(rename = "OSNotSupported")]
        OsNotSupported,
        #[serde(rename = "TrialNotAllowed")]
        TrialNotAllowed,
    }
    impl From<&str> for OriginTrialStatus {
        fn from(s: &str) -> Self {
            match s {
                "Enabled" => Self::Enabled,
                "ValidTokenNotProvided" => Self::ValidTokenNotProvided,
                "OSNotSupported" => Self::OsNotSupported,
                "TrialNotAllowed" => Self::TrialNotAllowed,
                _ => Self::Enabled,
            }
        }
    }
    impl From<String> for OriginTrialStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum OriginTrialUsageRestriction {
        #[serde(rename = "None")]
        None,
        #[serde(rename = "Subset")]
        Subset,
    }
    impl From<&str> for OriginTrialUsageRestriction {
        fn from(s: &str) -> Self {
            match s {
                "None" => Self::None,
                "Subset" => Self::Subset,
                _ => Self::None,
            }
        }
    }
    impl From<String> for OriginTrialUsageRestriction {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OriginTrialToken {
        pub origin: String,
        #[serde(rename = "matchSubDomains")]
        pub match_sub_domains: bool,
        #[serde(rename = "trialName")]
        pub trial_name: String,
        #[serde(rename = "expiryTime")]
        pub expiry_time: network::TimeSinceEpoch,
        #[serde(rename = "isThirdParty")]
        pub is_third_party: bool,
        #[serde(rename = "usageRestriction")]
        pub usage_restriction: OriginTrialUsageRestriction,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OriginTrialTokenWithStatus {
        #[serde(rename = "rawTokenText")]
        pub raw_token_text: String,
        /// `parsedToken` is present only when the token is extractable and parsable.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parsedToken")]
        pub parsed_token: Option<OriginTrialToken>,
        pub status: OriginTrialTokenStatus,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OriginTrial {
        #[serde(rename = "trialName")]
        pub trial_name: String,
        pub status: OriginTrialStatus,
        #[serde(rename = "tokensWithStatus")]
        pub tokens_with_status: Vec<OriginTrialTokenWithStatus>,
    }

    /// Additional information about the frame document's security origin.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SecurityOriginDetails {
        /// Indicates whether the frame document's security origin is one of the local hostnames (e.g. "localhost") or IP addresses (IPv4 127.0.0.0/8 or IPv6 ::1).
        #[serde(rename = "isLocalhost")]
        pub is_localhost: bool,
    }

    /// Information about the Frame on the page.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Frame {
        /// Frame unique identifier.
        pub id: FrameId,
        /// Parent frame identifier.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentId")]
        pub parent_id: Option<FrameId>,
        /// Identifier of the loader associated with this frame.
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        /// Frame's name as specified in the tag.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// Frame document's URL without fragment.
        pub url: String,
        /// Frame document's URL fragment including the '#'.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlFragment")]
        pub url_fragment: Option<String>,
        /// Frame document's registered domain, taking the public suffixes list into account. Extracted from the Frame's url. Example URLs: http://www.google.com/file.html -> "google.com"        http://a.b.co.uk/file.html   -> "b.co.uk"
        /// **EXPERIMENTAL**
        #[serde(rename = "domainAndRegistry")]
        pub domain_and_registry: String,
        /// Frame document's security origin.
        #[serde(rename = "securityOrigin")]
        pub security_origin: String,
        /// Additional details about the frame document's security origin.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "securityOriginDetails")]
        pub security_origin_details: Option<SecurityOriginDetails>,
        /// Frame document's mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        /// If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "unreachableUrl")]
        pub unreachable_url: Option<String>,
        /// Indicates whether this frame was tagged as an ad and why.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "adFrameStatus")]
        pub ad_frame_status: Option<AdFrameStatus>,
        /// Indicates whether the main document is a secure context and explains why that is the case.
        /// **EXPERIMENTAL**
        #[serde(rename = "secureContextType")]
        pub secure_context_type: SecureContextType,
        /// Indicates whether this is a cross origin isolated context.
        /// **EXPERIMENTAL**
        #[serde(rename = "crossOriginIsolatedContextType")]
        pub cross_origin_isolated_context_type: CrossOriginIsolatedContextType,
        /// Indicated which gated APIs / features are available.
        /// **EXPERIMENTAL**
        #[serde(rename = "gatedAPIFeatures")]
        pub gated_api_features: Vec<GatedAPIFeatures>,
    }

    /// Information about the Resource on the page.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameResource {
        /// Resource URL.
        pub url: String,
        /// Type of this resource.
        #[serde(rename = "type")]
        pub type_: network::ResourceType,
        /// Resource mimeType as determined by the browser.
        #[serde(rename = "mimeType")]
        pub mime_type: String,
        /// last-modified timestamp as reported by server.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lastModified")]
        pub last_modified: Option<network::TimeSinceEpoch>,
        /// Resource content size.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contentSize")]
        pub content_size: Option<f64>,
        /// True if the resource failed to load.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub failed: Option<bool>,
        /// True if the resource was canceled during loading.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub canceled: Option<bool>,
    }

    /// Information about the Frame hierarchy along with their cached resources.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameResourceTree {
        /// Frame information for this tree item.
        pub frame: Frame,
        /// Child frames.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "childFrames")]
        pub child_frames: Option<Vec<FrameResourceTree>>,
        /// Information about frame resources.
        pub resources: Vec<FrameResource>,
    }

    /// Information about the Frame hierarchy.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameTree {
        /// Frame information for this tree item.
        pub frame: Frame,
        /// Child frames.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "childFrames")]
        pub child_frames: Option<Vec<FrameTree>>,
    }

    /// Unique script identifier.
    pub type ScriptIdentifier = String;

    /// Transition type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum TransitionType {
        #[serde(rename = "link")]
        Link,
        #[serde(rename = "typed")]
        Typed,
        #[serde(rename = "address_bar")]
        AddressBar,
        #[serde(rename = "auto_bookmark")]
        AutoBookmark,
        #[serde(rename = "auto_subframe")]
        AutoSubframe,
        #[serde(rename = "manual_subframe")]
        ManualSubframe,
        #[serde(rename = "generated")]
        Generated,
        #[serde(rename = "auto_toplevel")]
        AutoToplevel,
        #[serde(rename = "form_submit")]
        FormSubmit,
        #[serde(rename = "reload")]
        Reload,
        #[serde(rename = "keyword")]
        Keyword,
        #[serde(rename = "keyword_generated")]
        KeywordGenerated,
        #[serde(rename = "other")]
        Other,
    }
    impl From<&str> for TransitionType {
        fn from(s: &str) -> Self {
            match s {
                "link" => Self::Link,
                "typed" => Self::Typed,
                "address_bar" => Self::AddressBar,
                "auto_bookmark" => Self::AutoBookmark,
                "auto_subframe" => Self::AutoSubframe,
                "manual_subframe" => Self::ManualSubframe,
                "generated" => Self::Generated,
                "auto_toplevel" => Self::AutoToplevel,
                "form_submit" => Self::FormSubmit,
                "reload" => Self::Reload,
                "keyword" => Self::Keyword,
                "keyword_generated" => Self::KeywordGenerated,
                "other" => Self::Other,
                _ => Self::Link,
            }
        }
    }
    impl From<String> for TransitionType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Navigation history entry.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NavigationEntry {
        /// Unique id of the navigation history entry.
        pub id: i64,
        /// URL of the navigation history entry.
        pub url: String,
        /// URL that the user typed in the url bar.
        #[serde(rename = "userTypedURL")]
        pub user_typed_url: String,
        /// Title of the navigation history entry.
        pub title: String,
        /// Transition type.
        #[serde(rename = "transitionType")]
        pub transition_type: TransitionType,
    }

    /// Screencast frame metadata.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreencastFrameMetadata {
        /// Top offset in DIP.
        #[serde(rename = "offsetTop")]
        pub offset_top: f64,
        /// Page scale factor.
        #[serde(rename = "pageScaleFactor")]
        pub page_scale_factor: f64,
        /// Device screen width in DIP.
        #[serde(rename = "deviceWidth")]
        pub device_width: f64,
        /// Device screen height in DIP.
        #[serde(rename = "deviceHeight")]
        pub device_height: f64,
        /// Position of horizontal scroll in CSS pixels.
        #[serde(rename = "scrollOffsetX")]
        pub scroll_offset_x: f64,
        /// Position of vertical scroll in CSS pixels.
        #[serde(rename = "scrollOffsetY")]
        pub scroll_offset_y: f64,
        /// Frame swap timestamp.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub timestamp: Option<network::TimeSinceEpoch>,
    }

    /// Javascript dialog type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum DialogType {
        #[serde(rename = "alert")]
        Alert,
        #[serde(rename = "confirm")]
        Confirm,
        #[serde(rename = "prompt")]
        Prompt,
        #[serde(rename = "beforeunload")]
        Beforeunload,
    }
    impl From<&str> for DialogType {
        fn from(s: &str) -> Self {
            match s {
                "alert" => Self::Alert,
                "confirm" => Self::Confirm,
                "prompt" => Self::Prompt,
                "beforeunload" => Self::Beforeunload,
                _ => Self::Alert,
            }
        }
    }
    impl From<String> for DialogType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Error while paring app manifest.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AppManifestError {
        /// Error message.
        pub message: String,
        /// If critical, this is a non-recoverable parse error.
        pub critical: i64,
        /// Error line.
        pub line: i64,
        /// Error column.
        pub column: i64,
    }

    /// Parsed app manifest properties.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AppManifestParsedProperties {
        /// Computed scope value
        pub scope: String,
    }

    /// Layout viewport position and dimensions.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayoutViewport {
        /// Horizontal offset relative to the document (CSS pixels).
        #[serde(rename = "pageX")]
        pub page_x: i64,
        /// Vertical offset relative to the document (CSS pixels).
        #[serde(rename = "pageY")]
        pub page_y: i64,
        /// Width (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientWidth")]
        pub client_width: i64,
        /// Height (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientHeight")]
        pub client_height: i64,
    }

    /// Visual viewport position, dimensions, and scale.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VisualViewport {
        /// Horizontal offset relative to the layout viewport (CSS pixels).
        #[serde(rename = "offsetX")]
        pub offset_x: f64,
        /// Vertical offset relative to the layout viewport (CSS pixels).
        #[serde(rename = "offsetY")]
        pub offset_y: f64,
        /// Horizontal offset relative to the document (CSS pixels).
        #[serde(rename = "pageX")]
        pub page_x: f64,
        /// Vertical offset relative to the document (CSS pixels).
        #[serde(rename = "pageY")]
        pub page_y: f64,
        /// Width (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientWidth")]
        pub client_width: f64,
        /// Height (CSS pixels), excludes scrollbar if present.
        #[serde(rename = "clientHeight")]
        pub client_height: f64,
        /// Scale relative to the ideal viewport (size at width=device-width).
        pub scale: f64,
        /// Page zoom factor (CSS to device independent pixels ratio).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub zoom: Option<f64>,
    }

    /// Viewport for capturing screenshot.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Viewport {
        /// X offset in device independent pixels (dip).
        pub x: f64,
        /// Y offset in device independent pixels (dip).
        pub y: f64,
        /// Rectangle width in device independent pixels (dip).
        pub width: f64,
        /// Rectangle height in device independent pixels (dip).
        pub height: f64,
        /// Page scale factor.
        pub scale: f64,
    }

    /// Generic font families collection.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FontFamilies {
        /// The standard font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub standard: Option<String>,
        /// The fixed font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub fixed: Option<String>,
        /// The serif font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub serif: Option<String>,
        /// The sansSerif font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sansSerif")]
        pub sans_serif: Option<String>,
        /// The cursive font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub cursive: Option<String>,
        /// The fantasy font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub fantasy: Option<String>,
        /// The math font-family.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub math: Option<String>,
    }

    /// Font families collection for a script.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScriptFontFamilies {
        /// Name of the script which these font families are defined for.
        pub script: String,
        /// Generic font families collection for the script.
        #[serde(rename = "fontFamilies")]
        pub font_families: FontFamilies,
    }

    /// Default font sizes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FontSizes {
        /// Default standard font size.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub standard: Option<i64>,
        /// Default fixed font size.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub fixed: Option<i64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ClientNavigationReason {
        #[serde(rename = "anchorClick")]
        AnchorClick,
        #[serde(rename = "formSubmissionGet")]
        FormSubmissionGet,
        #[serde(rename = "formSubmissionPost")]
        FormSubmissionPost,
        #[serde(rename = "httpHeaderRefresh")]
        HttpHeaderRefresh,
        #[serde(rename = "initialFrameNavigation")]
        InitialFrameNavigation,
        #[serde(rename = "metaTagRefresh")]
        MetaTagRefresh,
        #[serde(rename = "other")]
        Other,
        #[serde(rename = "pageBlockInterstitial")]
        PageBlockInterstitial,
        #[serde(rename = "reload")]
        Reload,
        #[serde(rename = "scriptInitiated")]
        ScriptInitiated,
    }
    impl From<&str> for ClientNavigationReason {
        fn from(s: &str) -> Self {
            match s {
                "anchorClick" => Self::AnchorClick,
                "formSubmissionGet" => Self::FormSubmissionGet,
                "formSubmissionPost" => Self::FormSubmissionPost,
                "httpHeaderRefresh" => Self::HttpHeaderRefresh,
                "initialFrameNavigation" => Self::InitialFrameNavigation,
                "metaTagRefresh" => Self::MetaTagRefresh,
                "other" => Self::Other,
                "pageBlockInterstitial" => Self::PageBlockInterstitial,
                "reload" => Self::Reload,
                "scriptInitiated" => Self::ScriptInitiated,
                _ => Self::AnchorClick,
            }
        }
    }
    impl From<String> for ClientNavigationReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ClientNavigationDisposition {
        #[serde(rename = "currentTab")]
        CurrentTab,
        #[serde(rename = "newTab")]
        NewTab,
        #[serde(rename = "newWindow")]
        NewWindow,
        #[serde(rename = "download")]
        Download,
    }
    impl From<&str> for ClientNavigationDisposition {
        fn from(s: &str) -> Self {
            match s {
                "currentTab" => Self::CurrentTab,
                "newTab" => Self::NewTab,
                "newWindow" => Self::NewWindow,
                "download" => Self::Download,
                _ => Self::CurrentTab,
            }
        }
    }
    impl From<String> for ClientNavigationDisposition {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InstallabilityErrorArgument {
        /// Argument name (e.g. name:'minimum-icon-size-in-pixels').
        pub name: String,
        /// Argument value (e.g. value:'64').
        pub value: String,
    }

    /// The installability error
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InstallabilityError {
        /// The error id (e.g. 'manifest-missing-suitable-icon').
        #[serde(rename = "errorId")]
        pub error_id: String,
        /// The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
        #[serde(rename = "errorArguments")]
        pub error_arguments: Vec<InstallabilityErrorArgument>,
    }

    /// The referring-policy used for the navigation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ReferrerPolicy {
        #[serde(rename = "noReferrer")]
        NoReferrer,
        #[serde(rename = "noReferrerWhenDowngrade")]
        NoReferrerWhenDowngrade,
        #[serde(rename = "origin")]
        Origin,
        #[serde(rename = "originWhenCrossOrigin")]
        OriginWhenCrossOrigin,
        #[serde(rename = "sameOrigin")]
        SameOrigin,
        #[serde(rename = "strictOrigin")]
        StrictOrigin,
        #[serde(rename = "strictOriginWhenCrossOrigin")]
        StrictOriginWhenCrossOrigin,
        #[serde(rename = "unsafeUrl")]
        UnsafeUrl,
    }
    impl From<&str> for ReferrerPolicy {
        fn from(s: &str) -> Self {
            match s {
                "noReferrer" => Self::NoReferrer,
                "noReferrerWhenDowngrade" => Self::NoReferrerWhenDowngrade,
                "origin" => Self::Origin,
                "originWhenCrossOrigin" => Self::OriginWhenCrossOrigin,
                "sameOrigin" => Self::SameOrigin,
                "strictOrigin" => Self::StrictOrigin,
                "strictOriginWhenCrossOrigin" => Self::StrictOriginWhenCrossOrigin,
                "unsafeUrl" => Self::UnsafeUrl,
                _ => Self::NoReferrer,
            }
        }
    }
    impl From<String> for ReferrerPolicy {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Per-script compilation cache parameters for `Page.produceCompilationCache`
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompilationCacheParams {
        /// The URL of the script to produce a compilation cache entry for.
        pub url: String,
        /// A hint to the backend whether eager compilation is recommended. (the actual compilation mode used is upon backend discretion).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub eager: Option<bool>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FileFilter {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub accepts: Option<Vec<String>>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FileHandler {
        pub action: String,
        pub name: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub icons: Option<Vec<ImageResource>>,
        /// Mimic a map, name is the key, accepts is the value.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub accepts: Option<Vec<FileFilter>>,
        /// Won't repeat the enums, using string for easy comparison. Same as the other enums below.
        #[serde(rename = "launchType")]
        pub launch_type: String,
    }

    /// The image definition used in both icon and screenshot.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ImageResource {
        /// The src field in the definition, but changing to url in favor of consistency.
        pub url: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub sizes: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "type")]
        pub type_: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LaunchHandler {
        #[serde(rename = "clientMode")]
        pub client_mode: String,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProtocolHandler {
        pub protocol: String,
        pub url: String,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RelatedApplication {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub id: Option<String>,
        pub url: String,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScopeExtension {
        /// Instead of using tuple, this field always returns the serialized string for easy understanding and comparison.
        pub origin: String,
        #[serde(rename = "hasOriginWildcard")]
        pub has_origin_wildcard: bool,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Screenshot {
        pub image: ImageResource,
        #[serde(rename = "formFactor")]
        pub form_factor: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ShareTarget {
        pub action: String,
        pub method: String,
        pub enctype: String,
        /// Embed the ShareTargetParams
        #[serde(skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub text: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub files: Option<Vec<FileFilter>>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Shortcut {
        pub name: String,
        pub url: String,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WebAppManifest {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backgroundColor")]
        pub background_color: Option<String>,
        /// The extra description provided by the manifest.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub dir: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub display: Option<String>,
        /// The overrided display mode controlled by the user.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "displayOverrides")]
        pub display_overrides: Option<Vec<String>>,
        /// The handlers to open files.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fileHandlers")]
        pub file_handlers: Option<Vec<FileHandler>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub icons: Option<Vec<ImageResource>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub id: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub lang: Option<String>,
        /// TODO(crbug.com/1231886): This field is non-standard and part of a Chrome experiment. See: https://github.com/WICG/web-app-launch/blob/main/launch_handler.md
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "launchHandler")]
        pub launch_handler: Option<LaunchHandler>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub orientation: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "preferRelatedApplications")]
        pub prefer_related_applications: Option<bool>,
        /// The handlers to open protocols.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "protocolHandlers")]
        pub protocol_handlers: Option<Vec<ProtocolHandler>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "relatedApplications")]
        pub related_applications: Option<Vec<RelatedApplication>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub scope: Option<String>,
        /// Non-standard, see https://github.com/WICG/manifest-incubations/blob/gh-pages/scope_extensions-explainer.md
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scopeExtensions")]
        pub scope_extensions: Option<Vec<ScopeExtension>>,
        /// The screenshots used by chromium.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub screenshots: Option<Vec<Screenshot>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shareTarget")]
        pub share_target: Option<ShareTarget>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "shortName")]
        pub short_name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub shortcuts: Option<Vec<Shortcut>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "startUrl")]
        pub start_url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "themeColor")]
        pub theme_color: Option<String>,
    }

    /// The type of a frameNavigated event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum NavigationType {
        #[serde(rename = "Navigation")]
        Navigation,
        #[serde(rename = "BackForwardCacheRestore")]
        BackForwardCacheRestore,
    }
    impl From<&str> for NavigationType {
        fn from(s: &str) -> Self {
            match s {
                "Navigation" => Self::Navigation,
                "BackForwardCacheRestore" => Self::BackForwardCacheRestore,
                _ => Self::Navigation,
            }
        }
    }
    impl From<String> for NavigationType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// List of not restored reasons for back-forward cache.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum BackForwardCacheNotRestoredReason {
        #[serde(rename = "NotPrimaryMainFrame")]
        NotPrimaryMainFrame,
        #[serde(rename = "BackForwardCacheDisabled")]
        BackForwardCacheDisabled,
        #[serde(rename = "RelatedActiveContentsExist")]
        RelatedActiveContentsExist,
        #[serde(rename = "HTTPStatusNotOK")]
        HttpStatusNotOk,
        #[serde(rename = "SchemeNotHTTPOrHTTPS")]
        SchemeNotHttpOrHttps,
        #[serde(rename = "Loading")]
        Loading,
        #[serde(rename = "WasGrantedMediaAccess")]
        WasGrantedMediaAccess,
        #[serde(rename = "DisableForRenderFrameHostCalled")]
        DisableForRenderFrameHostCalled,
        #[serde(rename = "DomainNotAllowed")]
        DomainNotAllowed,
        #[serde(rename = "HTTPMethodNotGET")]
        HttpMethodNotGet,
        #[serde(rename = "SubframeIsNavigating")]
        SubframeIsNavigating,
        #[serde(rename = "Timeout")]
        Timeout,
        #[serde(rename = "CacheLimit")]
        CacheLimit,
        #[serde(rename = "JavaScriptExecution")]
        JavaScriptExecution,
        #[serde(rename = "RendererProcessKilled")]
        RendererProcessKilled,
        #[serde(rename = "RendererProcessCrashed")]
        RendererProcessCrashed,
        #[serde(rename = "SchedulerTrackedFeatureUsed")]
        SchedulerTrackedFeatureUsed,
        #[serde(rename = "ConflictingBrowsingInstance")]
        ConflictingBrowsingInstance,
        #[serde(rename = "CacheFlushed")]
        CacheFlushed,
        #[serde(rename = "ServiceWorkerVersionActivation")]
        ServiceWorkerVersionActivation,
        #[serde(rename = "SessionRestored")]
        SessionRestored,
        #[serde(rename = "ServiceWorkerPostMessage")]
        ServiceWorkerPostMessage,
        #[serde(rename = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded")]
        EnteredBackForwardCacheBeforeServiceWorkerHostAdded,
        #[serde(rename = "RenderFrameHostReused_SameSite")]
        RenderFrameHostReusedSameSite,
        #[serde(rename = "RenderFrameHostReused_CrossSite")]
        RenderFrameHostReusedCrossSite,
        #[serde(rename = "ServiceWorkerClaim")]
        ServiceWorkerClaim,
        #[serde(rename = "IgnoreEventAndEvict")]
        IgnoreEventAndEvict,
        #[serde(rename = "HaveInnerContents")]
        HaveInnerContents,
        #[serde(rename = "TimeoutPuttingInCache")]
        TimeoutPuttingInCache,
        #[serde(rename = "BackForwardCacheDisabledByLowMemory")]
        BackForwardCacheDisabledByLowMemory,
        #[serde(rename = "BackForwardCacheDisabledByCommandLine")]
        BackForwardCacheDisabledByCommandLine,
        #[serde(rename = "NetworkRequestDatapipeDrainedAsBytesConsumer")]
        NetworkRequestDatapipeDrainedAsBytesConsumer,
        #[serde(rename = "NetworkRequestRedirected")]
        NetworkRequestRedirected,
        #[serde(rename = "NetworkRequestTimeout")]
        NetworkRequestTimeout,
        #[serde(rename = "NetworkExceedsBufferLimit")]
        NetworkExceedsBufferLimit,
        #[serde(rename = "NavigationCancelledWhileRestoring")]
        NavigationCancelledWhileRestoring,
        #[serde(rename = "NotMostRecentNavigationEntry")]
        NotMostRecentNavigationEntry,
        #[serde(rename = "BackForwardCacheDisabledForPrerender")]
        BackForwardCacheDisabledForPrerender,
        #[serde(rename = "UserAgentOverrideDiffers")]
        UserAgentOverrideDiffers,
        #[serde(rename = "ForegroundCacheLimit")]
        ForegroundCacheLimit,
        #[serde(rename = "BrowsingInstanceNotSwapped")]
        BrowsingInstanceNotSwapped,
        #[serde(rename = "BackForwardCacheDisabledForDelegate")]
        BackForwardCacheDisabledForDelegate,
        #[serde(rename = "UnloadHandlerExistsInMainFrame")]
        UnloadHandlerExistsInMainFrame,
        #[serde(rename = "UnloadHandlerExistsInSubFrame")]
        UnloadHandlerExistsInSubFrame,
        #[serde(rename = "ServiceWorkerUnregistration")]
        ServiceWorkerUnregistration,
        #[serde(rename = "CacheControlNoStore")]
        CacheControlNoStore,
        #[serde(rename = "CacheControlNoStoreCookieModified")]
        CacheControlNoStoreCookieModified,
        #[serde(rename = "CacheControlNoStoreHTTPOnlyCookieModified")]
        CacheControlNoStoreHttpOnlyCookieModified,
        #[serde(rename = "NoResponseHead")]
        NoResponseHead,
        #[serde(rename = "Unknown")]
        Unknown,
        #[serde(rename = "ActivationNavigationsDisallowedForBug1234857")]
        ActivationNavigationsDisallowedForBug1234857,
        #[serde(rename = "ErrorDocument")]
        ErrorDocument,
        #[serde(rename = "FencedFramesEmbedder")]
        FencedFramesEmbedder,
        #[serde(rename = "CookieDisabled")]
        CookieDisabled,
        #[serde(rename = "HTTPAuthRequired")]
        HttpAuthRequired,
        #[serde(rename = "CookieFlushed")]
        CookieFlushed,
        #[serde(rename = "BroadcastChannelOnMessage")]
        BroadcastChannelOnMessage,
        #[serde(rename = "WebViewSettingsChanged")]
        WebViewSettingsChanged,
        #[serde(rename = "WebViewJavaScriptObjectChanged")]
        WebViewJavaScriptObjectChanged,
        #[serde(rename = "WebViewMessageListenerInjected")]
        WebViewMessageListenerInjected,
        #[serde(rename = "WebViewSafeBrowsingAllowlistChanged")]
        WebViewSafeBrowsingAllowlistChanged,
        #[serde(rename = "WebViewDocumentStartJavascriptChanged")]
        WebViewDocumentStartJavascriptChanged,
        #[serde(rename = "WebSocket")]
        WebSocket,
        #[serde(rename = "WebTransport")]
        WebTransport,
        #[serde(rename = "WebRTC")]
        WebRtc,
        #[serde(rename = "MainResourceHasCacheControlNoStore")]
        MainResourceHasCacheControlNoStore,
        #[serde(rename = "MainResourceHasCacheControlNoCache")]
        MainResourceHasCacheControlNoCache,
        #[serde(rename = "SubresourceHasCacheControlNoStore")]
        SubresourceHasCacheControlNoStore,
        #[serde(rename = "SubresourceHasCacheControlNoCache")]
        SubresourceHasCacheControlNoCache,
        #[serde(rename = "ContainsPlugins")]
        ContainsPlugins,
        #[serde(rename = "DocumentLoaded")]
        DocumentLoaded,
        #[serde(rename = "OutstandingNetworkRequestOthers")]
        OutstandingNetworkRequestOthers,
        #[serde(rename = "RequestedMIDIPermission")]
        RequestedMidiPermission,
        #[serde(rename = "RequestedAudioCapturePermission")]
        RequestedAudioCapturePermission,
        #[serde(rename = "RequestedVideoCapturePermission")]
        RequestedVideoCapturePermission,
        #[serde(rename = "RequestedBackForwardCacheBlockedSensors")]
        RequestedBackForwardCacheBlockedSensors,
        #[serde(rename = "RequestedBackgroundWorkPermission")]
        RequestedBackgroundWorkPermission,
        #[serde(rename = "BroadcastChannel")]
        BroadcastChannel,
        #[serde(rename = "WebXR")]
        WebXr,
        #[serde(rename = "SharedWorker")]
        SharedWorker,
        #[serde(rename = "SharedWorkerMessage")]
        SharedWorkerMessage,
        #[serde(rename = "SharedWorkerWithNoActiveClient")]
        SharedWorkerWithNoActiveClient,
        #[serde(rename = "WebLocks")]
        WebLocks,
        #[serde(rename = "WebHID")]
        WebHid,
        #[serde(rename = "WebBluetooth")]
        WebBluetooth,
        #[serde(rename = "WebShare")]
        WebShare,
        #[serde(rename = "RequestedStorageAccessGrant")]
        RequestedStorageAccessGrant,
        #[serde(rename = "WebNfc")]
        WebNfc,
        #[serde(rename = "OutstandingNetworkRequestFetch")]
        OutstandingNetworkRequestFetch,
        #[serde(rename = "OutstandingNetworkRequestXHR")]
        OutstandingNetworkRequestXhr,
        #[serde(rename = "AppBanner")]
        AppBanner,
        #[serde(rename = "Printing")]
        Printing,
        #[serde(rename = "WebDatabase")]
        WebDatabase,
        #[serde(rename = "PictureInPicture")]
        PictureInPicture,
        #[serde(rename = "SpeechRecognizer")]
        SpeechRecognizer,
        #[serde(rename = "IdleManager")]
        IdleManager,
        #[serde(rename = "PaymentManager")]
        PaymentManager,
        #[serde(rename = "SpeechSynthesis")]
        SpeechSynthesis,
        #[serde(rename = "KeyboardLock")]
        KeyboardLock,
        #[serde(rename = "WebOTPService")]
        WebOtpService,
        #[serde(rename = "OutstandingNetworkRequestDirectSocket")]
        OutstandingNetworkRequestDirectSocket,
        #[serde(rename = "InjectedJavascript")]
        InjectedJavascript,
        #[serde(rename = "InjectedStyleSheet")]
        InjectedStyleSheet,
        #[serde(rename = "KeepaliveRequest")]
        KeepaliveRequest,
        #[serde(rename = "IndexedDBEvent")]
        IndexedDbEvent,
        #[serde(rename = "Dummy")]
        Dummy,
        #[serde(rename = "JsNetworkRequestReceivedCacheControlNoStoreResource")]
        JsNetworkRequestReceivedCacheControlNoStoreResource,
        #[serde(rename = "WebRTCUsedWithCCNS")]
        WebRtcUsedWithCcns,
        #[serde(rename = "WebTransportUsedWithCCNS")]
        WebTransportUsedWithCcns,
        #[serde(rename = "WebSocketUsedWithCCNS")]
        WebSocketUsedWithCcns,
        #[serde(rename = "SmartCard")]
        SmartCard,
        #[serde(rename = "LiveMediaStreamTrack")]
        LiveMediaStreamTrack,
        #[serde(rename = "UnloadHandler")]
        UnloadHandler,
        #[serde(rename = "ParserAborted")]
        ParserAborted,
        #[serde(rename = "ContentSecurityHandler")]
        ContentSecurityHandler,
        #[serde(rename = "ContentWebAuthenticationAPI")]
        ContentWebAuthenticationApi,
        #[serde(rename = "ContentFileChooser")]
        ContentFileChooser,
        #[serde(rename = "ContentSerial")]
        ContentSerial,
        #[serde(rename = "ContentFileSystemAccess")]
        ContentFileSystemAccess,
        #[serde(rename = "ContentMediaDevicesDispatcherHost")]
        ContentMediaDevicesDispatcherHost,
        #[serde(rename = "ContentWebBluetooth")]
        ContentWebBluetooth,
        #[serde(rename = "ContentWebUSB")]
        ContentWebUsb,
        #[serde(rename = "ContentMediaSessionService")]
        ContentMediaSessionService,
        #[serde(rename = "ContentScreenReader")]
        ContentScreenReader,
        #[serde(rename = "ContentDiscarded")]
        ContentDiscarded,
        #[serde(rename = "EmbedderPopupBlockerTabHelper")]
        EmbedderPopupBlockerTabHelper,
        #[serde(rename = "EmbedderSafeBrowsingTriggeredPopupBlocker")]
        EmbedderSafeBrowsingTriggeredPopupBlocker,
        #[serde(rename = "EmbedderSafeBrowsingThreatDetails")]
        EmbedderSafeBrowsingThreatDetails,
        #[serde(rename = "EmbedderAppBannerManager")]
        EmbedderAppBannerManager,
        #[serde(rename = "EmbedderDomDistillerViewerSource")]
        EmbedderDomDistillerViewerSource,
        #[serde(rename = "EmbedderDomDistillerSelfDeletingRequestDelegate")]
        EmbedderDomDistillerSelfDeletingRequestDelegate,
        #[serde(rename = "EmbedderOomInterventionTabHelper")]
        EmbedderOomInterventionTabHelper,
        #[serde(rename = "EmbedderOfflinePage")]
        EmbedderOfflinePage,
        #[serde(rename = "EmbedderChromePasswordManagerClientBindCredentialManager")]
        EmbedderChromePasswordManagerClientBindCredentialManager,
        #[serde(rename = "EmbedderPermissionRequestManager")]
        EmbedderPermissionRequestManager,
        #[serde(rename = "EmbedderModalDialog")]
        EmbedderModalDialog,
        #[serde(rename = "EmbedderExtensions")]
        EmbedderExtensions,
        #[serde(rename = "EmbedderExtensionMessaging")]
        EmbedderExtensionMessaging,
        #[serde(rename = "EmbedderExtensionMessagingForOpenPort")]
        EmbedderExtensionMessagingForOpenPort,
        #[serde(rename = "EmbedderExtensionSentMessageToCachedFrame")]
        EmbedderExtensionSentMessageToCachedFrame,
        #[serde(rename = "RequestedByWebViewClient")]
        RequestedByWebViewClient,
        #[serde(rename = "PostMessageByWebViewClient")]
        PostMessageByWebViewClient,
        #[serde(rename = "CacheControlNoStoreDeviceBoundSessionTerminated")]
        CacheControlNoStoreDeviceBoundSessionTerminated,
        #[serde(rename = "CacheLimitPrunedOnModerateMemoryPressure")]
        CacheLimitPrunedOnModerateMemoryPressure,
        #[serde(rename = "CacheLimitPrunedOnCriticalMemoryPressure")]
        CacheLimitPrunedOnCriticalMemoryPressure,
    }
    impl From<&str> for BackForwardCacheNotRestoredReason {
        fn from(s: &str) -> Self {
            match s {
                "NotPrimaryMainFrame" => Self::NotPrimaryMainFrame,
                "BackForwardCacheDisabled" => Self::BackForwardCacheDisabled,
                "RelatedActiveContentsExist" => Self::RelatedActiveContentsExist,
                "HTTPStatusNotOK" => Self::HttpStatusNotOk,
                "SchemeNotHTTPOrHTTPS" => Self::SchemeNotHttpOrHttps,
                "Loading" => Self::Loading,
                "WasGrantedMediaAccess" => Self::WasGrantedMediaAccess,
                "DisableForRenderFrameHostCalled" => Self::DisableForRenderFrameHostCalled,
                "DomainNotAllowed" => Self::DomainNotAllowed,
                "HTTPMethodNotGET" => Self::HttpMethodNotGet,
                "SubframeIsNavigating" => Self::SubframeIsNavigating,
                "Timeout" => Self::Timeout,
                "CacheLimit" => Self::CacheLimit,
                "JavaScriptExecution" => Self::JavaScriptExecution,
                "RendererProcessKilled" => Self::RendererProcessKilled,
                "RendererProcessCrashed" => Self::RendererProcessCrashed,
                "SchedulerTrackedFeatureUsed" => Self::SchedulerTrackedFeatureUsed,
                "ConflictingBrowsingInstance" => Self::ConflictingBrowsingInstance,
                "CacheFlushed" => Self::CacheFlushed,
                "ServiceWorkerVersionActivation" => Self::ServiceWorkerVersionActivation,
                "SessionRestored" => Self::SessionRestored,
                "ServiceWorkerPostMessage" => Self::ServiceWorkerPostMessage,
                "EnteredBackForwardCacheBeforeServiceWorkerHostAdded" => {
                    Self::EnteredBackForwardCacheBeforeServiceWorkerHostAdded
                }
                "RenderFrameHostReused_SameSite" => Self::RenderFrameHostReusedSameSite,
                "RenderFrameHostReused_CrossSite" => Self::RenderFrameHostReusedCrossSite,
                "ServiceWorkerClaim" => Self::ServiceWorkerClaim,
                "IgnoreEventAndEvict" => Self::IgnoreEventAndEvict,
                "HaveInnerContents" => Self::HaveInnerContents,
                "TimeoutPuttingInCache" => Self::TimeoutPuttingInCache,
                "BackForwardCacheDisabledByLowMemory" => Self::BackForwardCacheDisabledByLowMemory,
                "BackForwardCacheDisabledByCommandLine" => {
                    Self::BackForwardCacheDisabledByCommandLine
                }
                "NetworkRequestDatapipeDrainedAsBytesConsumer" => {
                    Self::NetworkRequestDatapipeDrainedAsBytesConsumer
                }
                "NetworkRequestRedirected" => Self::NetworkRequestRedirected,
                "NetworkRequestTimeout" => Self::NetworkRequestTimeout,
                "NetworkExceedsBufferLimit" => Self::NetworkExceedsBufferLimit,
                "NavigationCancelledWhileRestoring" => Self::NavigationCancelledWhileRestoring,
                "NotMostRecentNavigationEntry" => Self::NotMostRecentNavigationEntry,
                "BackForwardCacheDisabledForPrerender" => {
                    Self::BackForwardCacheDisabledForPrerender
                }
                "UserAgentOverrideDiffers" => Self::UserAgentOverrideDiffers,
                "ForegroundCacheLimit" => Self::ForegroundCacheLimit,
                "BrowsingInstanceNotSwapped" => Self::BrowsingInstanceNotSwapped,
                "BackForwardCacheDisabledForDelegate" => Self::BackForwardCacheDisabledForDelegate,
                "UnloadHandlerExistsInMainFrame" => Self::UnloadHandlerExistsInMainFrame,
                "UnloadHandlerExistsInSubFrame" => Self::UnloadHandlerExistsInSubFrame,
                "ServiceWorkerUnregistration" => Self::ServiceWorkerUnregistration,
                "CacheControlNoStore" => Self::CacheControlNoStore,
                "CacheControlNoStoreCookieModified" => Self::CacheControlNoStoreCookieModified,
                "CacheControlNoStoreHTTPOnlyCookieModified" => {
                    Self::CacheControlNoStoreHttpOnlyCookieModified
                }
                "NoResponseHead" => Self::NoResponseHead,
                "Unknown" => Self::Unknown,
                "ActivationNavigationsDisallowedForBug1234857" => {
                    Self::ActivationNavigationsDisallowedForBug1234857
                }
                "ErrorDocument" => Self::ErrorDocument,
                "FencedFramesEmbedder" => Self::FencedFramesEmbedder,
                "CookieDisabled" => Self::CookieDisabled,
                "HTTPAuthRequired" => Self::HttpAuthRequired,
                "CookieFlushed" => Self::CookieFlushed,
                "BroadcastChannelOnMessage" => Self::BroadcastChannelOnMessage,
                "WebViewSettingsChanged" => Self::WebViewSettingsChanged,
                "WebViewJavaScriptObjectChanged" => Self::WebViewJavaScriptObjectChanged,
                "WebViewMessageListenerInjected" => Self::WebViewMessageListenerInjected,
                "WebViewSafeBrowsingAllowlistChanged" => Self::WebViewSafeBrowsingAllowlistChanged,
                "WebViewDocumentStartJavascriptChanged" => {
                    Self::WebViewDocumentStartJavascriptChanged
                }
                "WebSocket" => Self::WebSocket,
                "WebTransport" => Self::WebTransport,
                "WebRTC" => Self::WebRtc,
                "MainResourceHasCacheControlNoStore" => Self::MainResourceHasCacheControlNoStore,
                "MainResourceHasCacheControlNoCache" => Self::MainResourceHasCacheControlNoCache,
                "SubresourceHasCacheControlNoStore" => Self::SubresourceHasCacheControlNoStore,
                "SubresourceHasCacheControlNoCache" => Self::SubresourceHasCacheControlNoCache,
                "ContainsPlugins" => Self::ContainsPlugins,
                "DocumentLoaded" => Self::DocumentLoaded,
                "OutstandingNetworkRequestOthers" => Self::OutstandingNetworkRequestOthers,
                "RequestedMIDIPermission" => Self::RequestedMidiPermission,
                "RequestedAudioCapturePermission" => Self::RequestedAudioCapturePermission,
                "RequestedVideoCapturePermission" => Self::RequestedVideoCapturePermission,
                "RequestedBackForwardCacheBlockedSensors" => {
                    Self::RequestedBackForwardCacheBlockedSensors
                }
                "RequestedBackgroundWorkPermission" => Self::RequestedBackgroundWorkPermission,
                "BroadcastChannel" => Self::BroadcastChannel,
                "WebXR" => Self::WebXr,
                "SharedWorker" => Self::SharedWorker,
                "SharedWorkerMessage" => Self::SharedWorkerMessage,
                "SharedWorkerWithNoActiveClient" => Self::SharedWorkerWithNoActiveClient,
                "WebLocks" => Self::WebLocks,
                "WebHID" => Self::WebHid,
                "WebBluetooth" => Self::WebBluetooth,
                "WebShare" => Self::WebShare,
                "RequestedStorageAccessGrant" => Self::RequestedStorageAccessGrant,
                "WebNfc" => Self::WebNfc,
                "OutstandingNetworkRequestFetch" => Self::OutstandingNetworkRequestFetch,
                "OutstandingNetworkRequestXHR" => Self::OutstandingNetworkRequestXhr,
                "AppBanner" => Self::AppBanner,
                "Printing" => Self::Printing,
                "WebDatabase" => Self::WebDatabase,
                "PictureInPicture" => Self::PictureInPicture,
                "SpeechRecognizer" => Self::SpeechRecognizer,
                "IdleManager" => Self::IdleManager,
                "PaymentManager" => Self::PaymentManager,
                "SpeechSynthesis" => Self::SpeechSynthesis,
                "KeyboardLock" => Self::KeyboardLock,
                "WebOTPService" => Self::WebOtpService,
                "OutstandingNetworkRequestDirectSocket" => {
                    Self::OutstandingNetworkRequestDirectSocket
                }
                "InjectedJavascript" => Self::InjectedJavascript,
                "InjectedStyleSheet" => Self::InjectedStyleSheet,
                "KeepaliveRequest" => Self::KeepaliveRequest,
                "IndexedDBEvent" => Self::IndexedDbEvent,
                "Dummy" => Self::Dummy,
                "JsNetworkRequestReceivedCacheControlNoStoreResource" => {
                    Self::JsNetworkRequestReceivedCacheControlNoStoreResource
                }
                "WebRTCUsedWithCCNS" => Self::WebRtcUsedWithCcns,
                "WebTransportUsedWithCCNS" => Self::WebTransportUsedWithCcns,
                "WebSocketUsedWithCCNS" => Self::WebSocketUsedWithCcns,
                "SmartCard" => Self::SmartCard,
                "LiveMediaStreamTrack" => Self::LiveMediaStreamTrack,
                "UnloadHandler" => Self::UnloadHandler,
                "ParserAborted" => Self::ParserAborted,
                "ContentSecurityHandler" => Self::ContentSecurityHandler,
                "ContentWebAuthenticationAPI" => Self::ContentWebAuthenticationApi,
                "ContentFileChooser" => Self::ContentFileChooser,
                "ContentSerial" => Self::ContentSerial,
                "ContentFileSystemAccess" => Self::ContentFileSystemAccess,
                "ContentMediaDevicesDispatcherHost" => Self::ContentMediaDevicesDispatcherHost,
                "ContentWebBluetooth" => Self::ContentWebBluetooth,
                "ContentWebUSB" => Self::ContentWebUsb,
                "ContentMediaSessionService" => Self::ContentMediaSessionService,
                "ContentScreenReader" => Self::ContentScreenReader,
                "ContentDiscarded" => Self::ContentDiscarded,
                "EmbedderPopupBlockerTabHelper" => Self::EmbedderPopupBlockerTabHelper,
                "EmbedderSafeBrowsingTriggeredPopupBlocker" => {
                    Self::EmbedderSafeBrowsingTriggeredPopupBlocker
                }
                "EmbedderSafeBrowsingThreatDetails" => Self::EmbedderSafeBrowsingThreatDetails,
                "EmbedderAppBannerManager" => Self::EmbedderAppBannerManager,
                "EmbedderDomDistillerViewerSource" => Self::EmbedderDomDistillerViewerSource,
                "EmbedderDomDistillerSelfDeletingRequestDelegate" => {
                    Self::EmbedderDomDistillerSelfDeletingRequestDelegate
                }
                "EmbedderOomInterventionTabHelper" => Self::EmbedderOomInterventionTabHelper,
                "EmbedderOfflinePage" => Self::EmbedderOfflinePage,
                "EmbedderChromePasswordManagerClientBindCredentialManager" => {
                    Self::EmbedderChromePasswordManagerClientBindCredentialManager
                }
                "EmbedderPermissionRequestManager" => Self::EmbedderPermissionRequestManager,
                "EmbedderModalDialog" => Self::EmbedderModalDialog,
                "EmbedderExtensions" => Self::EmbedderExtensions,
                "EmbedderExtensionMessaging" => Self::EmbedderExtensionMessaging,
                "EmbedderExtensionMessagingForOpenPort" => {
                    Self::EmbedderExtensionMessagingForOpenPort
                }
                "EmbedderExtensionSentMessageToCachedFrame" => {
                    Self::EmbedderExtensionSentMessageToCachedFrame
                }
                "RequestedByWebViewClient" => Self::RequestedByWebViewClient,
                "PostMessageByWebViewClient" => Self::PostMessageByWebViewClient,
                "CacheControlNoStoreDeviceBoundSessionTerminated" => {
                    Self::CacheControlNoStoreDeviceBoundSessionTerminated
                }
                "CacheLimitPrunedOnModerateMemoryPressure" => {
                    Self::CacheLimitPrunedOnModerateMemoryPressure
                }
                "CacheLimitPrunedOnCriticalMemoryPressure" => {
                    Self::CacheLimitPrunedOnCriticalMemoryPressure
                }
                _ => Self::NotPrimaryMainFrame,
            }
        }
    }
    impl From<String> for BackForwardCacheNotRestoredReason {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Types of not restored reasons for back-forward cache.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum BackForwardCacheNotRestoredReasonType {
        #[serde(rename = "SupportPending")]
        SupportPending,
        #[serde(rename = "PageSupportNeeded")]
        PageSupportNeeded,
        #[serde(rename = "Circumstantial")]
        Circumstantial,
    }
    impl From<&str> for BackForwardCacheNotRestoredReasonType {
        fn from(s: &str) -> Self {
            match s {
                "SupportPending" => Self::SupportPending,
                "PageSupportNeeded" => Self::PageSupportNeeded,
                "Circumstantial" => Self::Circumstantial,
                _ => Self::SupportPending,
            }
        }
    }
    impl From<String> for BackForwardCacheNotRestoredReasonType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackForwardCacheBlockingDetails {
        /// Url of the file where blockage happened. Optional because of tests.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// Function name where blockage happened. Optional because of anonymous functions and tests.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub function: Option<String>,
        /// Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// Column number in the script (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackForwardCacheNotRestoredExplanation {
        /// Type of the reason
        #[serde(rename = "type")]
        pub type_: BackForwardCacheNotRestoredReasonType,
        /// Not restored reason
        pub reason: BackForwardCacheNotRestoredReason,
        /// Context associated with the reason. The meaning of this context is dependent on the reason: - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub context: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub details: Option<Vec<BackForwardCacheBlockingDetails>>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackForwardCacheNotRestoredExplanationTree {
        /// URL of each frame
        pub url: String,
        /// Not restored reasons of each frame
        pub explanations: Vec<BackForwardCacheNotRestoredExplanation>,
        /// Array of children frame
        pub children: Vec<BackForwardCacheNotRestoredExplanationTree>,
    }

    /// Deprecated, please use addScriptToEvaluateOnNewDocument instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScriptToEvaluateOnLoad {
        #[serde(rename = "scriptSource")]
        script_source: String,
    }

    impl AddScriptToEvaluateOnLoad {
        pub fn new(script_source: impl Into<String>) -> Self {
            Self {
                script_source: script_source.into(),
            }
        }
    }

    impl Command for AddScriptToEvaluateOnLoad {
        type Response = AddScriptToEvaluateOnLoadResult;
        const METHOD: &'static str = "Page.addScriptToEvaluateOnLoad";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScriptToEvaluateOnLoadResult {
        /// Identifier of the added script.
        pub identifier: ScriptIdentifier,
    }

    /// Evaluates given script in every frame upon creation (before loading frame's scripts).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScriptToEvaluateOnNewDocument {
        source: String,
        /// If specified, creates an isolated world with the given name and evaluates given script in it. This world name will be used as the ExecutionContextDescription::name when the corresponding event is emitted.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "worldName")]
        world_name: Option<String>,
        /// Specifies whether command line API should be available to the script, defaults to false.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeCommandLineAPI")]
        include_command_line_api: Option<bool>,
        /// If true, runs the script immediately on existing execution contexts or worlds. Default: false.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "runImmediately")]
        run_immediately: Option<bool>,
    }

    impl AddScriptToEvaluateOnNewDocument {
        pub fn new(source: impl Into<String>) -> Self {
            Self {
                source: source.into(),
                world_name: None,
                include_command_line_api: None,
                run_immediately: None,
            }
        }

        pub fn with_world_name(mut self, world_name: impl Into<String>) -> Self {
            self.world_name = Some(world_name.into());
            self
        }

        pub fn with_include_command_line_api(
            mut self,
            include_command_line_api: impl Into<bool>,
        ) -> Self {
            self.include_command_line_api = Some(include_command_line_api.into());
            self
        }

        pub fn with_run_immediately(mut self, run_immediately: impl Into<bool>) -> Self {
            self.run_immediately = Some(run_immediately.into());
            self
        }
    }

    impl Command for AddScriptToEvaluateOnNewDocument {
        type Response = AddScriptToEvaluateOnNewDocumentResult;
        const METHOD: &'static str = "Page.addScriptToEvaluateOnNewDocument";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddScriptToEvaluateOnNewDocumentResult {
        /// Identifier of the added script.
        pub identifier: ScriptIdentifier,
    }

    /// Brings page to front (activates tab).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BringToFront {}

    impl BringToFront {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for BringToFront {
        type Response = ();
        const METHOD: &'static str = "Page.bringToFront";
    }

    /// Capture page screenshot.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureScreenshot {
        /// Image compression format (defaults to png).
        #[serde(skip_serializing_if = "Option::is_none")]
        format: Option<String>,
        /// Compression quality from range [0..100] (jpeg only).
        #[serde(skip_serializing_if = "Option::is_none")]
        quality: Option<i64>,
        /// Capture the screenshot of a given region only.
        #[serde(skip_serializing_if = "Option::is_none")]
        clip: Option<Viewport>,
        /// Capture the screenshot from the surface, rather than the view. Defaults to true.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "fromSurface")]
        from_surface: Option<bool>,
        /// Capture the screenshot beyond the viewport. Defaults to false.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "captureBeyondViewport")]
        capture_beyond_viewport: Option<bool>,
        /// Optimize image encoding for speed, not for resulting size (defaults to false)
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "optimizeForSpeed")]
        optimize_for_speed: Option<bool>,
    }

    impl CaptureScreenshot {
        pub fn new() -> Self {
            Self {
                format: None,
                quality: None,
                clip: None,
                from_surface: None,
                capture_beyond_viewport: None,
                optimize_for_speed: None,
            }
        }

        pub fn with_format(mut self, format: impl Into<String>) -> Self {
            self.format = Some(format.into());
            self
        }

        pub fn with_quality(mut self, quality: impl Into<i64>) -> Self {
            self.quality = Some(quality.into());
            self
        }

        pub fn with_clip(mut self, clip: impl Into<Viewport>) -> Self {
            self.clip = Some(clip.into());
            self
        }

        pub fn with_from_surface(mut self, from_surface: impl Into<bool>) -> Self {
            self.from_surface = Some(from_surface.into());
            self
        }

        pub fn with_capture_beyond_viewport(
            mut self,
            capture_beyond_viewport: impl Into<bool>,
        ) -> Self {
            self.capture_beyond_viewport = Some(capture_beyond_viewport.into());
            self
        }

        pub fn with_optimize_for_speed(mut self, optimize_for_speed: impl Into<bool>) -> Self {
            self.optimize_for_speed = Some(optimize_for_speed.into());
            self
        }
    }

    impl Command for CaptureScreenshot {
        type Response = CaptureScreenshotResult;
        const METHOD: &'static str = "Page.captureScreenshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureScreenshotResult {
        /// Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
        pub data: String,
    }

    /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes iframes, shadow DOM, external resources, and element-inline styles.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureSnapshot {
        /// Format (defaults to mhtml).
        #[serde(skip_serializing_if = "Option::is_none")]
        format: Option<String>,
    }

    impl CaptureSnapshot {
        pub fn new() -> Self {
            Self { format: None }
        }

        pub fn with_format(mut self, format: impl Into<String>) -> Self {
            self.format = Some(format.into());
            self
        }
    }

    impl Command for CaptureSnapshot {
        type Response = CaptureSnapshotResult;
        const METHOD: &'static str = "Page.captureSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CaptureSnapshotResult {
        /// Serialized page data.
        pub data: String,
    }

    /// Clears the overridden device metrics.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDeviceMetricsOverride {}

    impl ClearDeviceMetricsOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDeviceMetricsOverride {
        type Response = ();
        const METHOD: &'static str = "Page.clearDeviceMetricsOverride";
    }

    /// Clears the overridden Device Orientation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDeviceOrientationOverride {}

    impl ClearDeviceOrientationOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearDeviceOrientationOverride {
        type Response = ();
        const METHOD: &'static str = "Page.clearDeviceOrientationOverride";
    }

    /// Clears the overridden Geolocation Position and Error.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearGeolocationOverride {}

    impl ClearGeolocationOverride {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearGeolocationOverride {
        type Response = ();
        const METHOD: &'static str = "Page.clearGeolocationOverride";
    }

    /// Creates an isolated world for the given frame.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateIsolatedWorld {
        /// Id of the frame in which the isolated world should be created.
        #[serde(rename = "frameId")]
        frame_id: FrameId,
        /// An optional name which is reported in the Execution Context.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "worldName")]
        world_name: Option<String>,
        /// Whether or not universal access should be granted to the isolated world. This is a powerful option, use with caution.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "grantUniveralAccess")]
        grant_univeral_access: Option<bool>,
    }

    impl CreateIsolatedWorld {
        pub fn new(frame_id: impl Into<FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
                world_name: None,
                grant_univeral_access: None,
            }
        }

        pub fn with_world_name(mut self, world_name: impl Into<String>) -> Self {
            self.world_name = Some(world_name.into());
            self
        }

        pub fn with_grant_univeral_access(
            mut self,
            grant_univeral_access: impl Into<bool>,
        ) -> Self {
            self.grant_univeral_access = Some(grant_univeral_access.into());
            self
        }
    }

    impl Command for CreateIsolatedWorld {
        type Response = CreateIsolatedWorldResult;
        const METHOD: &'static str = "Page.createIsolatedWorld";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateIsolatedWorldResult {
        /// Execution context of the isolated world.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: runtime::ExecutionContextId,
    }

    /// Deletes browser cookie with given name, domain and path.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteCookie {
        /// Name of the cookie to remove.
        #[serde(rename = "cookieName")]
        cookie_name: String,
        /// URL to match cooke domain and path.
        url: String,
    }

    impl DeleteCookie {
        pub fn new(cookie_name: impl Into<String>, url: impl Into<String>) -> Self {
            Self {
                cookie_name: cookie_name.into(),
                url: url.into(),
            }
        }
    }

    impl Command for DeleteCookie {
        type Response = ();
        const METHOD: &'static str = "Page.deleteCookie";
    }

    /// Disables page domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Page.disable";
    }

    /// Enables page domain notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// If true, the `Page.fileChooserOpened` event will be emitted regardless of the state set by `Page.setInterceptFileChooserDialog` command (default: false).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableFileChooserOpenedEvent")]
        enable_file_chooser_opened_event: Option<bool>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                enable_file_chooser_opened_event: None,
            }
        }

        pub fn with_enable_file_chooser_opened_event(
            mut self,
            enable_file_chooser_opened_event: impl Into<bool>,
        ) -> Self {
            self.enable_file_chooser_opened_event = Some(enable_file_chooser_opened_event.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Page.enable";
    }

    /// Gets the processed manifest for this current document.  This API always waits for the manifest to be loaded.  If manifestId is provided, and it does not match the manifest of the   current document, this API errors out.  If there is not a loaded page, this API errors out immediately.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAppManifest {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "manifestId")]
        manifest_id: Option<String>,
    }

    impl GetAppManifest {
        pub fn new() -> Self {
            Self { manifest_id: None }
        }

        pub fn with_manifest_id(mut self, manifest_id: impl Into<String>) -> Self {
            self.manifest_id = Some(manifest_id.into());
            self
        }
    }

    impl Command for GetAppManifest {
        type Response = GetAppManifestResult;
        const METHOD: &'static str = "Page.getAppManifest";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAppManifestResult {
        /// Manifest location.
        pub url: String,
        pub errors: Vec<AppManifestError>,
        /// Manifest content.
        pub data: Option<String>,
        /// Parsed manifest properties. Deprecated, use manifest instead.
        /// **EXPERIMENTAL**
        #[deprecated]
        pub parsed: Option<AppManifestParsedProperties>,
        /// **EXPERIMENTAL**
        pub manifest: Option<WebAppManifest>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInstallabilityErrors {}

    impl GetInstallabilityErrors {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetInstallabilityErrors {
        type Response = GetInstallabilityErrorsResult;
        const METHOD: &'static str = "Page.getInstallabilityErrors";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInstallabilityErrorsResult {
        #[serde(rename = "installabilityErrors")]
        pub installability_errors: Vec<InstallabilityError>,
    }

    /// Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetManifestIcons {}

    impl GetManifestIcons {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetManifestIcons {
        type Response = GetManifestIconsResult;
        const METHOD: &'static str = "Page.getManifestIcons";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetManifestIconsResult {
        #[serde(rename = "primaryIcon")]
        pub primary_icon: Option<String>,
    }

    /// Returns the unique (PWA) app id. Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAppId {}

    impl GetAppId {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetAppId {
        type Response = GetAppIdResult;
        const METHOD: &'static str = "Page.getAppId";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAppIdResult {
        /// App id, either from manifest's id attribute or computed from start_url
        #[serde(rename = "appId")]
        pub app_id: Option<String>,
        /// Recommendation for manifest's id attribute to match current id computed from start_url
        #[serde(rename = "recommendedId")]
        pub recommended_id: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAdScriptAncestry {
        #[serde(rename = "frameId")]
        frame_id: FrameId,
    }

    impl GetAdScriptAncestry {
        pub fn new(frame_id: impl Into<FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
            }
        }
    }

    impl Command for GetAdScriptAncestry {
        type Response = GetAdScriptAncestryResult;
        const METHOD: &'static str = "Page.getAdScriptAncestry";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAdScriptAncestryResult {
        /// The ancestry chain of ad script identifiers leading to this frame's creation, along with the root script's filterlist rule. The ancestry chain is ordered from the most immediate script (in the frame creation stack) to more distant ancestors (that created the immediately preceding script). Only sent if frame is labelled as an ad and ids are available.
        #[serde(rename = "adScriptAncestry")]
        pub ad_script_ancestry: Option<AdScriptAncestry>,
    }

    /// Returns present frame tree structure.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFrameTree {}

    impl GetFrameTree {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetFrameTree {
        type Response = GetFrameTreeResult;
        const METHOD: &'static str = "Page.getFrameTree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFrameTreeResult {
        /// Present frame tree structure.
        #[serde(rename = "frameTree")]
        pub frame_tree: FrameTree,
    }

    /// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLayoutMetrics {}

    impl GetLayoutMetrics {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetLayoutMetrics {
        type Response = GetLayoutMetricsResult;
        const METHOD: &'static str = "Page.getLayoutMetrics";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetLayoutMetricsResult {
        /// Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
        #[deprecated]
        #[serde(rename = "layoutViewport")]
        pub layout_viewport: LayoutViewport,
        /// Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
        #[deprecated]
        #[serde(rename = "visualViewport")]
        pub visual_viewport: VisualViewport,
        /// Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
        #[deprecated]
        #[serde(rename = "contentSize")]
        pub content_size: dom::Rect,
        /// Metrics relating to the layout viewport in CSS pixels.
        #[serde(rename = "cssLayoutViewport")]
        pub css_layout_viewport: LayoutViewport,
        /// Metrics relating to the visual viewport in CSS pixels.
        #[serde(rename = "cssVisualViewport")]
        pub css_visual_viewport: VisualViewport,
        /// Size of scrollable area in CSS pixels.
        #[serde(rename = "cssContentSize")]
        pub css_content_size: dom::Rect,
    }

    /// Returns navigation history for the current page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNavigationHistory {}

    impl GetNavigationHistory {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetNavigationHistory {
        type Response = GetNavigationHistoryResult;
        const METHOD: &'static str = "Page.getNavigationHistory";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetNavigationHistoryResult {
        /// Index of the current navigation history entry.
        #[serde(rename = "currentIndex")]
        pub current_index: i64,
        /// Array of navigation history entries.
        pub entries: Vec<NavigationEntry>,
    }

    /// Resets navigation history for the current page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetNavigationHistory {}

    impl ResetNavigationHistory {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ResetNavigationHistory {
        type Response = ();
        const METHOD: &'static str = "Page.resetNavigationHistory";
    }

    /// Returns content of the given resource.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResourceContent {
        /// Frame id to get resource for.
        #[serde(rename = "frameId")]
        frame_id: FrameId,
        /// URL of the resource to get content for.
        url: String,
    }

    impl GetResourceContent {
        pub fn new(frame_id: impl Into<FrameId>, url: impl Into<String>) -> Self {
            Self {
                frame_id: frame_id.into(),
                url: url.into(),
            }
        }
    }

    impl Command for GetResourceContent {
        type Response = GetResourceContentResult;
        const METHOD: &'static str = "Page.getResourceContent";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResourceContentResult {
        /// Resource content.
        pub content: String,
        /// True, if content was served as base64.
        #[serde(rename = "base64Encoded")]
        pub base64_encoded: bool,
    }

    /// Returns present frame / resource tree structure.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResourceTree {}

    impl GetResourceTree {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetResourceTree {
        type Response = GetResourceTreeResult;
        const METHOD: &'static str = "Page.getResourceTree";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetResourceTreeResult {
        /// Present frame / resource tree structure.
        #[serde(rename = "frameTree")]
        pub frame_tree: FrameResourceTree,
    }

    /// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HandleJavaScriptDialog {
        /// Whether to accept or dismiss the dialog.
        accept: bool,
        /// The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "promptText")]
        prompt_text: Option<String>,
    }

    impl HandleJavaScriptDialog {
        pub fn new(accept: impl Into<bool>) -> Self {
            Self {
                accept: accept.into(),
                prompt_text: None,
            }
        }

        pub fn with_prompt_text(mut self, prompt_text: impl Into<String>) -> Self {
            self.prompt_text = Some(prompt_text.into());
            self
        }
    }

    impl Command for HandleJavaScriptDialog {
        type Response = ();
        const METHOD: &'static str = "Page.handleJavaScriptDialog";
    }

    /// Navigates current page to the given URL.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Navigate {
        /// URL to navigate the page to.
        url: String,
        /// Referrer URL.
        #[serde(skip_serializing_if = "Option::is_none")]
        referrer: Option<String>,
        /// Intended transition type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "transitionType")]
        transition_type: Option<TransitionType>,
        /// Frame id to navigate, if not specified navigates the top frame.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<FrameId>,
        /// Referrer-policy used for the navigation.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "referrerPolicy")]
        referrer_policy: Option<ReferrerPolicy>,
    }

    impl Navigate {
        pub fn new(url: impl Into<String>) -> Self {
            Self {
                url: url.into(),
                referrer: None,
                transition_type: None,
                frame_id: None,
                referrer_policy: None,
            }
        }

        pub fn with_referrer(mut self, referrer: impl Into<String>) -> Self {
            self.referrer = Some(referrer.into());
            self
        }

        pub fn with_transition_type(mut self, transition_type: impl Into<TransitionType>) -> Self {
            self.transition_type = Some(transition_type.into());
            self
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }

        pub fn with_referrer_policy(mut self, referrer_policy: impl Into<ReferrerPolicy>) -> Self {
            self.referrer_policy = Some(referrer_policy.into());
            self
        }
    }

    impl Command for Navigate {
        type Response = NavigateResult;
        const METHOD: &'static str = "Page.navigate";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NavigateResult {
        /// Frame id that has navigated (or failed to navigate)
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Loader identifier. This is omitted in case of same-document navigation, as the previously committed loaderId would not change.
        #[serde(rename = "loaderId")]
        pub loader_id: Option<network::LoaderId>,
        /// User friendly error message, present if and only if navigation has failed.
        #[serde(rename = "errorText")]
        pub error_text: Option<String>,
        /// Whether the navigation resulted in a download.
        /// **EXPERIMENTAL**
        #[serde(rename = "isDownload")]
        pub is_download: Option<bool>,
    }

    /// Navigates current page to the given history entry.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NavigateToHistoryEntry {
        /// Unique id of the entry to navigate to.
        #[serde(rename = "entryId")]
        entry_id: i64,
    }

    impl NavigateToHistoryEntry {
        pub fn new(entry_id: impl Into<i64>) -> Self {
            Self {
                entry_id: entry_id.into(),
            }
        }
    }

    impl Command for NavigateToHistoryEntry {
        type Response = ();
        const METHOD: &'static str = "Page.navigateToHistoryEntry";
    }

    /// Print page as PDF.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrintToPdf {
        /// Paper orientation. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        landscape: Option<bool>,
        /// Display header and footer. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "displayHeaderFooter")]
        display_header_footer: Option<bool>,
        /// Print background graphics. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "printBackground")]
        print_background: Option<bool>,
        /// Scale of the webpage rendering. Defaults to 1.
        #[serde(skip_serializing_if = "Option::is_none")]
        scale: Option<f64>,
        /// Paper width in inches. Defaults to 8.5 inches.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "paperWidth")]
        paper_width: Option<f64>,
        /// Paper height in inches. Defaults to 11 inches.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "paperHeight")]
        paper_height: Option<f64>,
        /// Top margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "marginTop")]
        margin_top: Option<f64>,
        /// Bottom margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "marginBottom")]
        margin_bottom: Option<f64>,
        /// Left margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "marginLeft")]
        margin_left: Option<f64>,
        /// Right margin in inches. Defaults to 1cm (~0.4 inches).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "marginRight")]
        margin_right: Option<f64>,
        /// Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are printed in the document order, not in the order specified, and no more than once. Defaults to empty string, which implies the entire document is printed. The page numbers are quietly capped to actual page count of the document, and ranges beyond the end of the document are ignored. If this results in no pages to print, an error is reported. It is an error to specify a range with start greater than end.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "pageRanges")]
        page_ranges: Option<String>,
        /// HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: - `date`: formatted print date - `title`: document title - `url`: document location - `pageNumber`: current page number - `totalPages`: total pages in the document For example, `<span class=title></span>` would generate span containing the title.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "headerTemplate")]
        header_template: Option<String>,
        /// HTML template for the print footer. Should use the same format as the `headerTemplate`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "footerTemplate")]
        footer_template: Option<String>,
        /// Whether or not to prefer page size as defined by css. Defaults to false, in which case the content will be scaled to fit the paper size.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "preferCSSPageSize")]
        prefer_css_page_size: Option<bool>,
        /// return as stream
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "transferMode")]
        transfer_mode: Option<String>,
        /// Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generateTaggedPDF")]
        generate_tagged_pdf: Option<bool>,
        /// Whether or not to embed the document outline into the PDF.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generateDocumentOutline")]
        generate_document_outline: Option<bool>,
    }

    impl PrintToPdf {
        pub fn new() -> Self {
            Self {
                landscape: None,
                display_header_footer: None,
                print_background: None,
                scale: None,
                paper_width: None,
                paper_height: None,
                margin_top: None,
                margin_bottom: None,
                margin_left: None,
                margin_right: None,
                page_ranges: None,
                header_template: None,
                footer_template: None,
                prefer_css_page_size: None,
                transfer_mode: None,
                generate_tagged_pdf: None,
                generate_document_outline: None,
            }
        }

        pub fn with_landscape(mut self, landscape: impl Into<bool>) -> Self {
            self.landscape = Some(landscape.into());
            self
        }

        pub fn with_display_header_footer(
            mut self,
            display_header_footer: impl Into<bool>,
        ) -> Self {
            self.display_header_footer = Some(display_header_footer.into());
            self
        }

        pub fn with_print_background(mut self, print_background: impl Into<bool>) -> Self {
            self.print_background = Some(print_background.into());
            self
        }

        pub fn with_scale(mut self, scale: impl Into<f64>) -> Self {
            self.scale = Some(scale.into());
            self
        }

        pub fn with_paper_width(mut self, paper_width: impl Into<f64>) -> Self {
            self.paper_width = Some(paper_width.into());
            self
        }

        pub fn with_paper_height(mut self, paper_height: impl Into<f64>) -> Self {
            self.paper_height = Some(paper_height.into());
            self
        }

        pub fn with_margin_top(mut self, margin_top: impl Into<f64>) -> Self {
            self.margin_top = Some(margin_top.into());
            self
        }

        pub fn with_margin_bottom(mut self, margin_bottom: impl Into<f64>) -> Self {
            self.margin_bottom = Some(margin_bottom.into());
            self
        }

        pub fn with_margin_left(mut self, margin_left: impl Into<f64>) -> Self {
            self.margin_left = Some(margin_left.into());
            self
        }

        pub fn with_margin_right(mut self, margin_right: impl Into<f64>) -> Self {
            self.margin_right = Some(margin_right.into());
            self
        }

        pub fn with_page_ranges(mut self, page_ranges: impl Into<String>) -> Self {
            self.page_ranges = Some(page_ranges.into());
            self
        }

        pub fn with_header_template(mut self, header_template: impl Into<String>) -> Self {
            self.header_template = Some(header_template.into());
            self
        }

        pub fn with_footer_template(mut self, footer_template: impl Into<String>) -> Self {
            self.footer_template = Some(footer_template.into());
            self
        }

        pub fn with_prefer_css_page_size(mut self, prefer_css_page_size: impl Into<bool>) -> Self {
            self.prefer_css_page_size = Some(prefer_css_page_size.into());
            self
        }

        pub fn with_transfer_mode(mut self, transfer_mode: impl Into<String>) -> Self {
            self.transfer_mode = Some(transfer_mode.into());
            self
        }

        pub fn with_generate_tagged_pdf(mut self, generate_tagged_pdf: impl Into<bool>) -> Self {
            self.generate_tagged_pdf = Some(generate_tagged_pdf.into());
            self
        }

        pub fn with_generate_document_outline(
            mut self,
            generate_document_outline: impl Into<bool>,
        ) -> Self {
            self.generate_document_outline = Some(generate_document_outline.into());
            self
        }
    }

    impl Command for PrintToPdf {
        type Response = PrintToPdfResult;
        const METHOD: &'static str = "Page.printToPDF";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrintToPdfResult {
        /// Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
        pub data: String,
        /// A handle of the stream that holds resulting PDF data.
        /// **EXPERIMENTAL**
        pub stream: Option<io::StreamHandle>,
    }

    /// Reloads given page optionally ignoring the cache.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Reload {
        /// If true, browser cache is ignored (as if the user pressed Shift+refresh).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ignoreCache")]
        ignore_cache: Option<bool>,
        /// If set, the script will be injected into all frames of the inspected page after reload. Argument will be ignored if reloading dataURL origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptToEvaluateOnLoad")]
        script_to_evaluate_on_load: Option<String>,
        /// If set, an error will be thrown if the target page's main frame's loader id does not match the provided id. This prevents accidentally reloading an unintended target in case there's a racing navigation.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "loaderId")]
        loader_id: Option<network::LoaderId>,
    }

    impl Reload {
        pub fn new() -> Self {
            Self {
                ignore_cache: None,
                script_to_evaluate_on_load: None,
                loader_id: None,
            }
        }

        pub fn with_ignore_cache(mut self, ignore_cache: impl Into<bool>) -> Self {
            self.ignore_cache = Some(ignore_cache.into());
            self
        }

        pub fn with_script_to_evaluate_on_load(
            mut self,
            script_to_evaluate_on_load: impl Into<String>,
        ) -> Self {
            self.script_to_evaluate_on_load = Some(script_to_evaluate_on_load.into());
            self
        }

        pub fn with_loader_id(mut self, loader_id: impl Into<network::LoaderId>) -> Self {
            self.loader_id = Some(loader_id.into());
            self
        }
    }

    impl Command for Reload {
        type Response = ();
        const METHOD: &'static str = "Page.reload";
    }

    /// Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveScriptToEvaluateOnLoad {
        identifier: ScriptIdentifier,
    }

    impl RemoveScriptToEvaluateOnLoad {
        pub fn new(identifier: impl Into<ScriptIdentifier>) -> Self {
            Self {
                identifier: identifier.into(),
            }
        }
    }

    impl Command for RemoveScriptToEvaluateOnLoad {
        type Response = ();
        const METHOD: &'static str = "Page.removeScriptToEvaluateOnLoad";
    }

    /// Removes given script from the list.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveScriptToEvaluateOnNewDocument {
        identifier: ScriptIdentifier,
    }

    impl RemoveScriptToEvaluateOnNewDocument {
        pub fn new(identifier: impl Into<ScriptIdentifier>) -> Self {
            Self {
                identifier: identifier.into(),
            }
        }
    }

    impl Command for RemoveScriptToEvaluateOnNewDocument {
        type Response = ();
        const METHOD: &'static str = "Page.removeScriptToEvaluateOnNewDocument";
    }

    /// Acknowledges that a screencast frame has been received by the frontend.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreencastFrameAck {
        /// Frame number.
        #[serde(rename = "sessionId")]
        session_id: i64,
    }

    impl ScreencastFrameAck {
        pub fn new(session_id: impl Into<i64>) -> Self {
            Self {
                session_id: session_id.into(),
            }
        }
    }

    impl Command for ScreencastFrameAck {
        type Response = ();
        const METHOD: &'static str = "Page.screencastFrameAck";
    }

    /// Searches for given string in resource content.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInResource {
        /// Frame id for resource to search in.
        #[serde(rename = "frameId")]
        frame_id: FrameId,
        /// URL of the resource to search in.
        url: String,
        /// String to search for.
        query: String,
        /// If true, search is case sensitive.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "caseSensitive")]
        case_sensitive: Option<bool>,
        /// If true, treats string parameter as regex.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isRegex")]
        is_regex: Option<bool>,
    }

    impl SearchInResource {
        pub fn new(
            frame_id: impl Into<FrameId>,
            url: impl Into<String>,
            query: impl Into<String>,
        ) -> Self {
            Self {
                frame_id: frame_id.into(),
                url: url.into(),
                query: query.into(),
                case_sensitive: None,
                is_regex: None,
            }
        }

        pub fn with_case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
            self.case_sensitive = Some(case_sensitive.into());
            self
        }

        pub fn with_is_regex(mut self, is_regex: impl Into<bool>) -> Self {
            self.is_regex = Some(is_regex.into());
            self
        }
    }

    impl Command for SearchInResource {
        type Response = SearchInResourceResult;
        const METHOD: &'static str = "Page.searchInResource";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInResourceResult {
        /// List of search matches.
        pub result: Vec<debugger::SearchMatch>,
    }

    /// Enable Chrome's experimental ad filter on all sites.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAdBlockingEnabled {
        /// Whether to block ads.
        enabled: bool,
    }

    impl SetAdBlockingEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetAdBlockingEnabled {
        type Response = ();
        const METHOD: &'static str = "Page.setAdBlockingEnabled";
    }

    /// Enable page Content Security Policy by-passing.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBypassCsp {
        /// Whether to bypass page CSP.
        enabled: bool,
    }

    impl SetBypassCsp {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetBypassCsp {
        type Response = ();
        const METHOD: &'static str = "Page.setBypassCSP";
    }

    /// Get Permissions Policy state on given frame.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPermissionsPolicyState {
        #[serde(rename = "frameId")]
        frame_id: FrameId,
    }

    impl GetPermissionsPolicyState {
        pub fn new(frame_id: impl Into<FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
            }
        }
    }

    impl Command for GetPermissionsPolicyState {
        type Response = GetPermissionsPolicyStateResult;
        const METHOD: &'static str = "Page.getPermissionsPolicyState";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPermissionsPolicyStateResult {
        pub states: Vec<PermissionsPolicyFeatureState>,
    }

    /// Get Origin Trials on given frame.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOriginTrials {
        #[serde(rename = "frameId")]
        frame_id: FrameId,
    }

    impl GetOriginTrials {
        pub fn new(frame_id: impl Into<FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
            }
        }
    }

    impl Command for GetOriginTrials {
        type Response = GetOriginTrialsResult;
        const METHOD: &'static str = "Page.getOriginTrials";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetOriginTrialsResult {
        #[serde(rename = "originTrials")]
        pub origin_trials: Vec<OriginTrial>,
    }

    /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDeviceMetricsOverride {
        /// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        width: i64,
        /// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
        height: i64,
        /// Overriding device scale factor value. 0 disables the override.
        #[serde(rename = "deviceScaleFactor")]
        device_scale_factor: f64,
        /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more.
        mobile: bool,
        /// Scale to apply to resulting view image.
        #[serde(skip_serializing_if = "Option::is_none")]
        scale: Option<f64>,
        /// Overriding screen width value in pixels (minimum 0, maximum 10000000).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenWidth")]
        screen_width: Option<i64>,
        /// Overriding screen height value in pixels (minimum 0, maximum 10000000).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenHeight")]
        screen_height: Option<i64>,
        /// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "positionX")]
        position_x: Option<i64>,
        /// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "positionY")]
        position_y: Option<i64>,
        /// Do not set visible view size, rely upon explicit setVisibleSize call.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dontSetVisibleSize")]
        dont_set_visible_size: Option<bool>,
        /// Screen orientation override.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "screenOrientation")]
        screen_orientation: Option<emulation::ScreenOrientation>,
        /// The viewport dimensions and scale. If not set, the override is cleared.
        #[serde(skip_serializing_if = "Option::is_none")]
        viewport: Option<Viewport>,
    }

    impl SetDeviceMetricsOverride {
        pub fn new(
            width: impl Into<i64>,
            height: impl Into<i64>,
            device_scale_factor: impl Into<f64>,
            mobile: impl Into<bool>,
        ) -> Self {
            Self {
                width: width.into(),
                height: height.into(),
                device_scale_factor: device_scale_factor.into(),
                mobile: mobile.into(),
                scale: None,
                screen_width: None,
                screen_height: None,
                position_x: None,
                position_y: None,
                dont_set_visible_size: None,
                screen_orientation: None,
                viewport: None,
            }
        }

        pub fn with_scale(mut self, scale: impl Into<f64>) -> Self {
            self.scale = Some(scale.into());
            self
        }

        pub fn with_screen_width(mut self, screen_width: impl Into<i64>) -> Self {
            self.screen_width = Some(screen_width.into());
            self
        }

        pub fn with_screen_height(mut self, screen_height: impl Into<i64>) -> Self {
            self.screen_height = Some(screen_height.into());
            self
        }

        pub fn with_position_x(mut self, position_x: impl Into<i64>) -> Self {
            self.position_x = Some(position_x.into());
            self
        }

        pub fn with_position_y(mut self, position_y: impl Into<i64>) -> Self {
            self.position_y = Some(position_y.into());
            self
        }

        pub fn with_dont_set_visible_size(
            mut self,
            dont_set_visible_size: impl Into<bool>,
        ) -> Self {
            self.dont_set_visible_size = Some(dont_set_visible_size.into());
            self
        }

        pub fn with_screen_orientation(
            mut self,
            screen_orientation: impl Into<emulation::ScreenOrientation>,
        ) -> Self {
            self.screen_orientation = Some(screen_orientation.into());
            self
        }

        pub fn with_viewport(mut self, viewport: impl Into<Viewport>) -> Self {
            self.viewport = Some(viewport.into());
            self
        }
    }

    impl Command for SetDeviceMetricsOverride {
        type Response = ();
        const METHOD: &'static str = "Page.setDeviceMetricsOverride";
    }

    /// Overrides the Device Orientation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDeviceOrientationOverride {
        /// Mock alpha
        alpha: f64,
        /// Mock beta
        beta: f64,
        /// Mock gamma
        gamma: f64,
    }

    impl SetDeviceOrientationOverride {
        pub fn new(alpha: impl Into<f64>, beta: impl Into<f64>, gamma: impl Into<f64>) -> Self {
            Self {
                alpha: alpha.into(),
                beta: beta.into(),
                gamma: gamma.into(),
            }
        }
    }

    impl Command for SetDeviceOrientationOverride {
        type Response = ();
        const METHOD: &'static str = "Page.setDeviceOrientationOverride";
    }

    /// Set generic font families.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetFontFamilies {
        /// Specifies font families to set. If a font family is not specified, it won't be changed.
        #[serde(rename = "fontFamilies")]
        font_families: FontFamilies,
        /// Specifies font families to set for individual scripts.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "forScripts")]
        for_scripts: Option<Vec<ScriptFontFamilies>>,
    }

    impl SetFontFamilies {
        pub fn new(font_families: impl Into<FontFamilies>) -> Self {
            Self {
                font_families: font_families.into(),
                for_scripts: None,
            }
        }

        pub fn with_for_scripts(mut self, for_scripts: impl Into<Vec<ScriptFontFamilies>>) -> Self {
            self.for_scripts = Some(for_scripts.into());
            self
        }
    }

    impl Command for SetFontFamilies {
        type Response = ();
        const METHOD: &'static str = "Page.setFontFamilies";
    }

    /// Set default font sizes.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetFontSizes {
        /// Specifies font sizes to set. If a font size is not specified, it won't be changed.
        #[serde(rename = "fontSizes")]
        font_sizes: FontSizes,
    }

    impl SetFontSizes {
        pub fn new(font_sizes: impl Into<FontSizes>) -> Self {
            Self {
                font_sizes: font_sizes.into(),
            }
        }
    }

    impl Command for SetFontSizes {
        type Response = ();
        const METHOD: &'static str = "Page.setFontSizes";
    }

    /// Sets given markup as the document's HTML.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDocumentContent {
        /// Frame id to set HTML for.
        #[serde(rename = "frameId")]
        frame_id: FrameId,
        /// HTML content to set.
        html: String,
    }

    impl SetDocumentContent {
        pub fn new(frame_id: impl Into<FrameId>, html: impl Into<String>) -> Self {
            Self {
                frame_id: frame_id.into(),
                html: html.into(),
            }
        }
    }

    impl Command for SetDocumentContent {
        type Response = ();
        const METHOD: &'static str = "Page.setDocumentContent";
    }

    /// Set the behavior when downloading a file.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDownloadBehavior {
        /// Whether to allow all or deny all download requests, or use default Chrome behavior if available (otherwise deny).
        behavior: String,
        /// The default path to save downloaded files to. This is required if behavior is set to 'allow'
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "downloadPath")]
        download_path: Option<String>,
    }

    impl SetDownloadBehavior {
        pub fn new(behavior: impl Into<String>) -> Self {
            Self {
                behavior: behavior.into(),
                download_path: None,
            }
        }

        pub fn with_download_path(mut self, download_path: impl Into<String>) -> Self {
            self.download_path = Some(download_path.into());
            self
        }
    }

    impl Command for SetDownloadBehavior {
        type Response = ();
        const METHOD: &'static str = "Page.setDownloadBehavior";
    }

    /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetGeolocationOverride {
        /// Mock latitude
        #[serde(skip_serializing_if = "Option::is_none")]
        latitude: Option<f64>,
        /// Mock longitude
        #[serde(skip_serializing_if = "Option::is_none")]
        longitude: Option<f64>,
        /// Mock accuracy
        #[serde(skip_serializing_if = "Option::is_none")]
        accuracy: Option<f64>,
    }

    impl SetGeolocationOverride {
        pub fn new() -> Self {
            Self {
                latitude: None,
                longitude: None,
                accuracy: None,
            }
        }

        pub fn with_latitude(mut self, latitude: impl Into<f64>) -> Self {
            self.latitude = Some(latitude.into());
            self
        }

        pub fn with_longitude(mut self, longitude: impl Into<f64>) -> Self {
            self.longitude = Some(longitude.into());
            self
        }

        pub fn with_accuracy(mut self, accuracy: impl Into<f64>) -> Self {
            self.accuracy = Some(accuracy.into());
            self
        }
    }

    impl Command for SetGeolocationOverride {
        type Response = ();
        const METHOD: &'static str = "Page.setGeolocationOverride";
    }

    /// Controls whether page will emit lifecycle events.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetLifecycleEventsEnabled {
        /// If true, starts emitting lifecycle events.
        enabled: bool,
    }

    impl SetLifecycleEventsEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetLifecycleEventsEnabled {
        type Response = ();
        const METHOD: &'static str = "Page.setLifecycleEventsEnabled";
    }

    /// Toggles mouse event-based touch event emulation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetTouchEmulationEnabled {
        /// Whether the touch event emulation should be enabled.
        enabled: bool,
        /// Touch/gesture events configuration. Default: current platform.
        #[serde(skip_serializing_if = "Option::is_none")]
        configuration: Option<String>,
    }

    impl SetTouchEmulationEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
                configuration: None,
            }
        }

        pub fn with_configuration(mut self, configuration: impl Into<String>) -> Self {
            self.configuration = Some(configuration.into());
            self
        }
    }

    impl Command for SetTouchEmulationEnabled {
        type Response = ();
        const METHOD: &'static str = "Page.setTouchEmulationEnabled";
    }

    /// Starts sending each frame using the `screencastFrame` event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartScreencast {
        /// Image compression format.
        #[serde(skip_serializing_if = "Option::is_none")]
        format: Option<String>,
        /// Compression quality from range [0..100].
        #[serde(skip_serializing_if = "Option::is_none")]
        quality: Option<i64>,
        /// Maximum screenshot width.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxWidth")]
        max_width: Option<i64>,
        /// Maximum screenshot height.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxHeight")]
        max_height: Option<i64>,
        /// Send every n-th frame.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "everyNthFrame")]
        every_nth_frame: Option<i64>,
    }

    impl StartScreencast {
        pub fn new() -> Self {
            Self {
                format: None,
                quality: None,
                max_width: None,
                max_height: None,
                every_nth_frame: None,
            }
        }

        pub fn with_format(mut self, format: impl Into<String>) -> Self {
            self.format = Some(format.into());
            self
        }

        pub fn with_quality(mut self, quality: impl Into<i64>) -> Self {
            self.quality = Some(quality.into());
            self
        }

        pub fn with_max_width(mut self, max_width: impl Into<i64>) -> Self {
            self.max_width = Some(max_width.into());
            self
        }

        pub fn with_max_height(mut self, max_height: impl Into<i64>) -> Self {
            self.max_height = Some(max_height.into());
            self
        }

        pub fn with_every_nth_frame(mut self, every_nth_frame: impl Into<i64>) -> Self {
            self.every_nth_frame = Some(every_nth_frame.into());
            self
        }
    }

    impl Command for StartScreencast {
        type Response = ();
        const METHOD: &'static str = "Page.startScreencast";
    }

    /// Force the page stop all navigations and pending resource fetches.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopLoading {}

    impl StopLoading {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopLoading {
        type Response = ();
        const METHOD: &'static str = "Page.stopLoading";
    }

    /// Crashes renderer on the IO thread, generates minidumps.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Crash {}

    impl Crash {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Crash {
        type Response = ();
        const METHOD: &'static str = "Page.crash";
    }

    /// Tries to close page, running its beforeunload hooks, if any.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Close {}

    impl Close {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Close {
        type Response = ();
        const METHOD: &'static str = "Page.close";
    }

    /// Tries to update the web lifecycle state of the page. It will transition the page to the given state according to: https://github.com/WICG/web-lifecycle/
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetWebLifecycleState {
        /// Target lifecycle state
        state: String,
    }

    impl SetWebLifecycleState {
        pub fn new(state: impl Into<String>) -> Self {
            Self {
                state: state.into(),
            }
        }
    }

    impl Command for SetWebLifecycleState {
        type Response = ();
        const METHOD: &'static str = "Page.setWebLifecycleState";
    }

    /// Stops sending each frame in the `screencastFrame`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopScreencast {}

    impl StopScreencast {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopScreencast {
        type Response = ();
        const METHOD: &'static str = "Page.stopScreencast";
    }

    /// Requests backend to produce compilation cache for the specified scripts. `scripts` are appended to the list of scripts for which the cache would be produced. The list may be reset during page navigation. When script with a matching URL is encountered, the cache is optionally produced upon backend discretion, based on internal heuristics. See also: `Page.compilationCacheProduced`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProduceCompilationCache {
        scripts: Vec<CompilationCacheParams>,
    }

    impl ProduceCompilationCache {
        pub fn new(scripts: impl Into<Vec<CompilationCacheParams>>) -> Self {
            Self {
                scripts: scripts.into(),
            }
        }
    }

    impl Command for ProduceCompilationCache {
        type Response = ();
        const METHOD: &'static str = "Page.produceCompilationCache";
    }

    /// Seeds compilation cache for given url. Compilation cache does not survive cross-process navigation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddCompilationCache {
        url: String,
        /// Base64-encoded data (Encoded as a base64 string when passed over JSON)
        data: String,
    }

    impl AddCompilationCache {
        pub fn new(url: impl Into<String>, data: impl Into<String>) -> Self {
            Self {
                url: url.into(),
                data: data.into(),
            }
        }
    }

    impl Command for AddCompilationCache {
        type Response = ();
        const METHOD: &'static str = "Page.addCompilationCache";
    }

    /// Clears seeded compilation cache.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearCompilationCache {}

    impl ClearCompilationCache {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearCompilationCache {
        type Response = ();
        const METHOD: &'static str = "Page.clearCompilationCache";
    }

    /// Sets the Secure Payment Confirmation transaction mode. https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSpcTransactionMode {
        mode: String,
    }

    impl SetSpcTransactionMode {
        pub fn new(mode: impl Into<String>) -> Self {
            Self { mode: mode.into() }
        }
    }

    impl Command for SetSpcTransactionMode {
        type Response = ();
        const METHOD: &'static str = "Page.setSPCTransactionMode";
    }

    /// Extensions for Custom Handlers API: https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRphRegistrationMode {
        mode: String,
    }

    impl SetRphRegistrationMode {
        pub fn new(mode: impl Into<String>) -> Self {
            Self { mode: mode.into() }
        }
    }

    impl Command for SetRphRegistrationMode {
        type Response = ();
        const METHOD: &'static str = "Page.setRPHRegistrationMode";
    }

    /// Generates a report for testing.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GenerateTestReport {
        /// Message to be displayed in the report.
        message: String,
        /// Specifies the endpoint group to deliver the report to.
        #[serde(skip_serializing_if = "Option::is_none")]
        group: Option<String>,
    }

    impl GenerateTestReport {
        pub fn new(message: impl Into<String>) -> Self {
            Self {
                message: message.into(),
                group: None,
            }
        }

        pub fn with_group(mut self, group: impl Into<String>) -> Self {
            self.group = Some(group.into());
            self
        }
    }

    impl Command for GenerateTestReport {
        type Response = ();
        const METHOD: &'static str = "Page.generateTestReport";
    }

    /// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WaitForDebugger {}

    impl WaitForDebugger {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for WaitForDebugger {
        type Response = ();
        const METHOD: &'static str = "Page.waitForDebugger";
    }

    /// Intercept file chooser requests and transfer control to protocol clients. When file chooser interception is enabled, native file chooser dialog is not shown. Instead, a protocol event `Page.fileChooserOpened` is emitted.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInterceptFileChooserDialog {
        enabled: bool,
        /// If true, cancels the dialog by emitting relevant events (if any) in addition to not showing it if the interception is enabled (default: false).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        cancel: Option<bool>,
    }

    impl SetInterceptFileChooserDialog {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
                cancel: None,
            }
        }

        pub fn with_cancel(mut self, cancel: impl Into<bool>) -> Self {
            self.cancel = Some(cancel.into());
            self
        }
    }

    impl Command for SetInterceptFileChooserDialog {
        type Response = ();
        const METHOD: &'static str = "Page.setInterceptFileChooserDialog";
    }

    /// Enable/disable prerendering manually. This command is a short-term solution for https://crbug.com/1440085. See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA for more details. TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPrerenderingAllowed {
        #[serde(rename = "isAllowed")]
        is_allowed: bool,
    }

    impl SetPrerenderingAllowed {
        pub fn new(is_allowed: impl Into<bool>) -> Self {
            Self {
                is_allowed: is_allowed.into(),
            }
        }
    }

    impl Command for SetPrerenderingAllowed {
        type Response = ();
        const METHOD: &'static str = "Page.setPrerenderingAllowed";
    }

    /// Get the annotated page content for the main frame. This is an experimental command that is subject to change.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnnotatedPageContent {
        /// Whether to include actionable information. Defaults to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeActionableInformation")]
        include_actionable_information: Option<bool>,
    }

    impl GetAnnotatedPageContent {
        pub fn new() -> Self {
            Self {
                include_actionable_information: None,
            }
        }

        pub fn with_include_actionable_information(
            mut self,
            include_actionable_information: impl Into<bool>,
        ) -> Self {
            self.include_actionable_information = Some(include_actionable_information.into());
            self
        }
    }

    impl Command for GetAnnotatedPageContent {
        type Response = GetAnnotatedPageContentResult;
        const METHOD: &'static str = "Page.getAnnotatedPageContent";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAnnotatedPageContentResult {
        /// The annotated page content as a base64 encoded protobuf. The format is defined by the `AnnotatedPageContent` message in components/optimization_guide/proto/features/common_quality_data.proto (Encoded as a base64 string when passed over JSON)
        pub content: String,
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DomContentEventFired {
        pub timestamp: network::MonotonicTime,
    }

    impl DomContentEventFired {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.domContentEventFired")
        }
    }

    /// Emitted only when `page.interceptFileChooser` is enabled.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FileChooserOpened {
        /// Id of the frame containing input node.
        /// **EXPERIMENTAL**
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Input mode.
        pub mode: String,
        /// Input node id. Only present for file choosers opened via an `<input type="file">` element.
        /// **EXPERIMENTAL**
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<dom::BackendNodeId>,
    }

    impl FileChooserOpened {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.fileChooserOpened")
        }
    }

    /// Fired when frame has been attached to its parent.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameAttached {
        /// Id of the frame that has been attached.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Parent frame identifier.
        #[serde(rename = "parentFrameId")]
        pub parent_frame_id: FrameId,
        /// JavaScript stack trace of when frame was attached, only set if frame initiated from script.
        pub stack: Option<runtime::StackTrace>,
    }

    impl FrameAttached {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameAttached")
        }
    }

    /// Fired when frame no longer has a scheduled navigation.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameClearedScheduledNavigation {
        /// Id of the frame that has cleared its scheduled navigation.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }

    impl FrameClearedScheduledNavigation {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Page.frameClearedScheduledNavigation")
        }
    }

    /// Fired when frame has been detached from its parent.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameDetached {
        /// Id of the frame that has been detached.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// **EXPERIMENTAL**
        pub reason: String,
    }

    impl FrameDetached {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameDetached")
        }
    }

    /// Fired before frame subtree is detached. Emitted before any frame of the subtree is actually detached.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameSubtreeWillBeDetached {
        /// Id of the frame that is the root of the subtree that will be detached.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }

    impl FrameSubtreeWillBeDetached {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameSubtreeWillBeDetached")
        }
    }

    /// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameNavigated {
        /// Frame object.
        pub frame: Frame,
        /// **EXPERIMENTAL**
        #[serde(rename = "type")]
        pub type_: NavigationType,
    }

    impl FrameNavigated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameNavigated")
        }
    }

    /// Fired when opening document to write to.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DocumentOpened {
        /// Frame object.
        pub frame: Frame,
    }

    impl DocumentOpened {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.documentOpened")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameResized {}

    impl FrameResized {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameResized")
        }
    }

    /// Fired when a navigation starts. This event is fired for both renderer-initiated and browser-initiated navigations. For renderer-initiated navigations, the event is fired after `frameRequestedNavigation`. Navigation may still be cancelled after the event is issued. Multiple events can be fired for a single navigation, for example, when a same-document navigation becomes a cross-document navigation (such as in the case of a frameset).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameStartedNavigating {
        /// ID of the frame that is being navigated.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// The URL the navigation started with. The final URL can be different.
        pub url: String,
        /// Loader identifier. Even though it is present in case of same-document navigation, the previously committed loaderId would not change unless the navigation changes from a same-document to a cross-document navigation.
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        #[serde(rename = "navigationType")]
        pub navigation_type: String,
    }

    impl FrameStartedNavigating {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameStartedNavigating")
        }
    }

    /// Fired when a renderer-initiated navigation is requested. Navigation may still be cancelled after the event is issued.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameRequestedNavigation {
        /// Id of the frame that is being navigated.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// The reason for the navigation.
        pub reason: ClientNavigationReason,
        /// The destination URL for the requested navigation.
        pub url: String,
        /// The disposition for the navigation.
        pub disposition: ClientNavigationDisposition,
    }

    impl FrameRequestedNavigation {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameRequestedNavigation")
        }
    }

    /// Fired when frame schedules a potential navigation.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameScheduledNavigation {
        /// Id of the frame that has scheduled a navigation.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not guaranteed to start.
        pub delay: f64,
        /// The reason for the navigation.
        pub reason: ClientNavigationReason,
        /// The destination URL for the scheduled navigation.
        pub url: String,
    }

    impl FrameScheduledNavigation {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameScheduledNavigation")
        }
    }

    /// Fired when frame has started loading.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameStartedLoading {
        /// Id of the frame that has started loading.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }

    impl FrameStartedLoading {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameStartedLoading")
        }
    }

    /// Fired when frame has stopped loading.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FrameStoppedLoading {
        /// Id of the frame that has stopped loading.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
    }

    impl FrameStoppedLoading {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.frameStoppedLoading")
        }
    }

    /// Fired when page is about to start a download. Deprecated. Use Browser.downloadWillBegin instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DownloadWillBegin {
        /// Id of the frame that caused download to begin.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Global unique identifier of the download.
        pub guid: String,
        /// URL of the resource being downloaded.
        pub url: String,
        /// Suggested file name of the resource (the actual name of the file saved on disk may differ).
        #[serde(rename = "suggestedFilename")]
        pub suggested_filename: String,
    }

    impl DownloadWillBegin {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.downloadWillBegin")
        }
    }

    /// Fired when download makes progress. Last call has |done| == true. Deprecated. Use Browser.downloadProgress instead.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DownloadProgress {
        /// Global unique identifier of the download.
        pub guid: String,
        /// Total expected bytes to download.
        #[serde(rename = "totalBytes")]
        pub total_bytes: f64,
        /// Total bytes received.
        #[serde(rename = "receivedBytes")]
        pub received_bytes: f64,
        /// Download status.
        pub state: String,
    }

    impl DownloadProgress {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.downloadProgress")
        }
    }

    /// Fired when interstitial page was hidden
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InterstitialHidden {}

    impl InterstitialHidden {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.interstitialHidden")
        }
    }

    /// Fired when interstitial page was shown
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InterstitialShown {}

    impl InterstitialShown {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.interstitialShown")
        }
    }

    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct JavascriptDialogClosed {
        /// Frame id.
        /// **EXPERIMENTAL**
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Whether dialog was confirmed.
        pub result: bool,
        /// User input in case of prompt.
        #[serde(rename = "userInput")]
        pub user_input: String,
    }

    impl JavascriptDialogClosed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.javascriptDialogClosed")
        }
    }

    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct JavascriptDialogOpening {
        /// Frame url.
        pub url: String,
        /// Frame id.
        /// **EXPERIMENTAL**
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Message that will be displayed by the dialog.
        pub message: String,
        /// Dialog type.
        #[serde(rename = "type")]
        pub type_: DialogType,
        /// True iff browser is capable showing or acting on the given dialog. When browser has no dialog handler for given target, calling alert while Page domain is engaged will stall the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
        #[serde(rename = "hasBrowserHandler")]
        pub has_browser_handler: bool,
        /// Default dialog prompt.
        #[serde(rename = "defaultPrompt")]
        pub default_prompt: Option<String>,
    }

    impl JavascriptDialogOpening {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.javascriptDialogOpening")
        }
    }

    /// Fired for lifecycle events (navigation, load, paint, etc) in the current target (including local frames).
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LifecycleEvent {
        /// Id of the frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Loader identifier. Empty string if the request is fetched from worker.
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        pub name: String,
        pub timestamp: network::MonotonicTime,
    }

    impl LifecycleEvent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.lifecycleEvent")
        }
    }

    /// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do not assume any ordering with the Page.frameNavigated event. This event is fired only for main-frame history navigation where the document changes (non-same-document navigations), when bfcache navigation fails.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BackForwardCacheNotUsed {
        /// The loader id for the associated navigation.
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        /// The frame id of the associated frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Array of reasons why the page could not be cached. This must not be empty.
        #[serde(rename = "notRestoredExplanations")]
        pub not_restored_explanations: Vec<BackForwardCacheNotRestoredExplanation>,
        /// Tree structure of reasons why the page could not be cached for each frame.
        #[serde(rename = "notRestoredExplanationsTree")]
        pub not_restored_explanations_tree: Option<BackForwardCacheNotRestoredExplanationTree>,
    }

    impl BackForwardCacheNotUsed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.backForwardCacheNotUsed")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LoadEventFired {
        pub timestamp: network::MonotonicTime,
    }

    impl LoadEventFired {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.loadEventFired")
        }
    }

    /// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NavigatedWithinDocument {
        /// Id of the frame.
        #[serde(rename = "frameId")]
        pub frame_id: FrameId,
        /// Frame's new url.
        pub url: String,
        /// Navigation type
        #[serde(rename = "navigationType")]
        pub navigation_type: String,
    }

    impl NavigatedWithinDocument {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.navigatedWithinDocument")
        }
    }

    /// Compressed image data requested by the `startScreencast`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreencastFrame {
        /// Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)
        pub data: String,
        /// Screencast frame metadata.
        pub metadata: ScreencastFrameMetadata,
        /// Frame number.
        #[serde(rename = "sessionId")]
        pub session_id: i64,
    }

    impl ScreencastFrame {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.screencastFrame")
        }
    }

    /// Fired when the page with currently enabled screencast was shown or hidden `.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScreencastVisibilityChanged {
        /// True if the page is visible.
        pub visible: bool,
    }

    impl ScreencastVisibilityChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.screencastVisibilityChanged")
        }
    }

    /// Fired when a new window is going to be opened, via window.open(), link click, form submission, etc.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WindowOpen {
        /// The URL for the new window.
        pub url: String,
        /// Window name.
        #[serde(rename = "windowName")]
        pub window_name: String,
        /// An array of enabled window features.
        #[serde(rename = "windowFeatures")]
        pub window_features: Vec<String>,
        /// Whether or not it was triggered by user gesture.
        #[serde(rename = "userGesture")]
        pub user_gesture: bool,
    }

    impl WindowOpen {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.windowOpen")
        }
    }

    /// Issued for every compilation cache generated.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompilationCacheProduced {
        pub url: String,
        /// Base64-encoded data (Encoded as a base64 string when passed over JSON)
        pub data: String,
    }

    impl CompilationCacheProduced {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Page.compilationCacheProduced")
        }
    }
}

pub mod performance {
    use super::*;

    /// Run-time execution metric.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Metric {
        /// Metric name.
        pub name: String,
        /// Metric value.
        pub value: f64,
    }

    /// Disable collecting and reporting metrics.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Performance.disable";
    }

    /// Enable collecting and reporting metrics.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// Time domain to use for collecting and reporting duration metrics.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "timeDomain")]
        time_domain: Option<String>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self { time_domain: None }
        }

        pub fn with_time_domain(mut self, time_domain: impl Into<String>) -> Self {
            self.time_domain = Some(time_domain.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Performance.enable";
    }

    /// Sets time domain to use for collecting and reporting duration metrics. Note that this must be called before enabling metrics collection. Calling this method while metrics collection is enabled returns an error.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetTimeDomain {
        /// Time domain
        #[serde(rename = "timeDomain")]
        time_domain: String,
    }

    impl SetTimeDomain {
        pub fn new(time_domain: impl Into<String>) -> Self {
            Self {
                time_domain: time_domain.into(),
            }
        }
    }

    impl Command for SetTimeDomain {
        type Response = ();
        const METHOD: &'static str = "Performance.setTimeDomain";
    }

    /// Retrieve current values of run-time metrics.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMetrics {}

    impl GetMetrics {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetMetrics {
        type Response = GetMetricsResult;
        const METHOD: &'static str = "Performance.getMetrics";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetMetricsResult {
        /// Current values for run-time metrics.
        pub metrics: Vec<Metric>,
    }

    /// Current values of the metrics.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Metrics {
        /// Current values of the metrics.
        pub metrics: Vec<Metric>,
        /// Timestamp title.
        pub title: String,
    }

    impl Metrics {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Performance.metrics")
        }
    }
}

pub mod performance_timeline {
    use super::*;

    /// See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LargestContentfulPaint {
        #[serde(rename = "renderTime")]
        pub render_time: network::TimeSinceEpoch,
        #[serde(rename = "loadTime")]
        pub load_time: network::TimeSinceEpoch,
        /// The number of pixels being painted.
        pub size: f64,
        /// The id attribute of the element, if available.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "elementId")]
        pub element_id: Option<String>,
        /// The URL of the image (may be trimmed).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        pub node_id: Option<dom::BackendNodeId>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayoutShiftAttribution {
        #[serde(rename = "previousRect")]
        pub previous_rect: dom::Rect,
        #[serde(rename = "currentRect")]
        pub current_rect: dom::Rect,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nodeId")]
        pub node_id: Option<dom::BackendNodeId>,
    }

    /// See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LayoutShift {
        /// Score increment produced by this event.
        pub value: f64,
        #[serde(rename = "hadRecentInput")]
        pub had_recent_input: bool,
        #[serde(rename = "lastInputTime")]
        pub last_input_time: network::TimeSinceEpoch,
        pub sources: Vec<LayoutShiftAttribution>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TimelineEvent {
        /// Identifies the frame that this event is related to. Empty for non-frame targets.
        #[serde(rename = "frameId")]
        pub frame_id: page::FrameId,
        /// The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype This determines which of the optional "details" fields is present.
        #[serde(rename = "type")]
        pub type_: String,
        /// Name may be empty depending on the type.
        pub name: String,
        /// Time in seconds since Epoch, monotonically increasing within document lifetime.
        pub time: network::TimeSinceEpoch,
        /// Event duration, if applicable.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub duration: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lcpDetails")]
        pub lcp_details: Option<LargestContentfulPaint>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "layoutShiftDetails")]
        pub layout_shift_details: Option<LayoutShift>,
    }

    /// Previously buffered events would be reported before method returns. See also: timelineEventAdded
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// The types of event to report, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype The specified filter overrides any previous filters, passing empty filter disables recording. Note that not all types exposed to the web platform are currently supported.
        #[serde(rename = "eventTypes")]
        event_types: Vec<String>,
    }

    impl Enable {
        pub fn new(event_types: impl Into<Vec<String>>) -> Self {
            Self {
                event_types: event_types.into(),
            }
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "PerformanceTimeline.enable";
    }

    /// Sent when a performance timeline event is added. See reportPerformanceTimeline method.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TimelineEventAdded {
        pub event: TimelineEvent,
    }

    impl TimelineEventAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("PerformanceTimeline.timelineEventAdded")
        }
    }
}

pub mod preload {
    use super::*;

    /// Unique id
    pub type RuleSetId = String;

    /// Corresponds to SpeculationRuleSet
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RuleSet {
        pub id: RuleSetId,
        /// Identifies a document which the rule set is associated with.
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        /// Source text of JSON representing the rule set. If it comes from `<script>` tag, it is the textContent of the node. Note that it is a JSON for valid case. See also: - https://wicg.github.io/nav-speculation/speculation-rules.html - https://github.com/WICG/nav-speculation/blob/main/triggers.md
        #[serde(rename = "sourceText")]
        pub source_text: String,
        /// A speculation rule set is either added through an inline `<script>` tag or through an external resource via the 'Speculation-Rules' HTTP header. For the first case, we include the BackendNodeId of the relevant `<script>` tag. For the second case, we include the external URL where the rule set was loaded from, and also RequestId if Network domain is enabled. See also: - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: Option<dom::BackendNodeId>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "requestId")]
        pub request_id: Option<network::RequestId>,
        /// Error information `errorMessage` is null iff `errorType` is null.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "errorType")]
        pub error_type: Option<RuleSetErrorType>,
        /// TODO(https://crbug.com/1425354): Replace this property with structured error.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "errorMessage")]
        pub error_message: Option<String>,
        /// For more details, see: https://github.com/WICG/nav-speculation/blob/main/speculation-rules-tags.md
        #[serde(skip_serializing_if = "Option::is_none")]
        pub tag: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum RuleSetErrorType {
        #[serde(rename = "SourceIsNotJsonObject")]
        SourceIsNotJsonObject,
        #[serde(rename = "InvalidRulesSkipped")]
        InvalidRulesSkipped,
        #[serde(rename = "InvalidRulesetLevelTag")]
        InvalidRulesetLevelTag,
    }
    impl From<&str> for RuleSetErrorType {
        fn from(s: &str) -> Self {
            match s {
                "SourceIsNotJsonObject" => Self::SourceIsNotJsonObject,
                "InvalidRulesSkipped" => Self::InvalidRulesSkipped,
                "InvalidRulesetLevelTag" => Self::InvalidRulesetLevelTag,
                _ => Self::SourceIsNotJsonObject,
            }
        }
    }
    impl From<String> for RuleSetErrorType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The type of preloading attempted. It corresponds to mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it isn't being used by clients).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SpeculationAction {
        #[serde(rename = "Prefetch")]
        Prefetch,
        #[serde(rename = "Prerender")]
        Prerender,
        #[serde(rename = "PrerenderUntilScript")]
        PrerenderUntilScript,
    }
    impl From<&str> for SpeculationAction {
        fn from(s: &str) -> Self {
            match s {
                "Prefetch" => Self::Prefetch,
                "Prerender" => Self::Prerender,
                "PrerenderUntilScript" => Self::PrerenderUntilScript,
                _ => Self::Prefetch,
            }
        }
    }
    impl From<String> for SpeculationAction {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Corresponds to mojom::SpeculationTargetHint. See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SpeculationTargetHint {
        #[serde(rename = "Blank")]
        Blank,
        #[serde(rename = "Self")]
        Self_,
    }
    impl From<&str> for SpeculationTargetHint {
        fn from(s: &str) -> Self {
            match s {
                "Blank" => Self::Blank,
                "Self" => Self::Self_,
                _ => Self::Blank,
            }
        }
    }
    impl From<String> for SpeculationTargetHint {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A key that identifies a preloading attempt. The url used is the url specified by the trigger (i.e. the initial URL), and not the final url that is navigated to. For example, prerendering allows same-origin main frame navigations during the attempt, but the attempt is still keyed with the initial URL.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PreloadingAttemptKey {
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        pub action: SpeculationAction,
        pub url: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetHint")]
        pub target_hint: Option<SpeculationTargetHint>,
    }

    /// Lists sources for a preloading attempt, specifically the ids of rule sets that had a speculation rule that triggered the attempt, and the BackendNodeIds of <a href> or <area href> elements that triggered the attempt (in the case of attempts triggered by a document rule). It is possible for multiple rule sets and links to trigger a single attempt.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PreloadingAttemptSource {
        pub key: PreloadingAttemptKey,
        #[serde(rename = "ruleSetIds")]
        pub rule_set_ids: Vec<RuleSetId>,
        #[serde(rename = "nodeIds")]
        pub node_ids: Vec<dom::BackendNodeId>,
    }

    /// Chrome manages different types of preloads together using a concept of preloading pipeline. For example, if a site uses a SpeculationRules for prerender, Chrome first starts a prefetch and then upgrades it to prerender. CDP events for them are emitted separately but they share `PreloadPipelineId`.
    pub type PreloadPipelineId = String;

    /// List of FinalStatus reasons for Prerender2.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PrerenderFinalStatus {
        #[serde(rename = "Activated")]
        Activated,
        #[serde(rename = "Destroyed")]
        Destroyed,
        #[serde(rename = "LowEndDevice")]
        LowEndDevice,
        #[serde(rename = "InvalidSchemeRedirect")]
        InvalidSchemeRedirect,
        #[serde(rename = "InvalidSchemeNavigation")]
        InvalidSchemeNavigation,
        #[serde(rename = "NavigationRequestBlockedByCsp")]
        NavigationRequestBlockedByCsp,
        #[serde(rename = "MojoBinderPolicy")]
        MojoBinderPolicy,
        #[serde(rename = "RendererProcessCrashed")]
        RendererProcessCrashed,
        #[serde(rename = "RendererProcessKilled")]
        RendererProcessKilled,
        #[serde(rename = "Download")]
        Download,
        #[serde(rename = "TriggerDestroyed")]
        TriggerDestroyed,
        #[serde(rename = "NavigationNotCommitted")]
        NavigationNotCommitted,
        #[serde(rename = "NavigationBadHttpStatus")]
        NavigationBadHttpStatus,
        #[serde(rename = "ClientCertRequested")]
        ClientCertRequested,
        #[serde(rename = "NavigationRequestNetworkError")]
        NavigationRequestNetworkError,
        #[serde(rename = "CancelAllHostsForTesting")]
        CancelAllHostsForTesting,
        #[serde(rename = "DidFailLoad")]
        DidFailLoad,
        #[serde(rename = "Stop")]
        Stop,
        #[serde(rename = "SslCertificateError")]
        SslCertificateError,
        #[serde(rename = "LoginAuthRequested")]
        LoginAuthRequested,
        #[serde(rename = "UaChangeRequiresReload")]
        UaChangeRequiresReload,
        #[serde(rename = "BlockedByClient")]
        BlockedByClient,
        #[serde(rename = "AudioOutputDeviceRequested")]
        AudioOutputDeviceRequested,
        #[serde(rename = "MixedContent")]
        MixedContent,
        #[serde(rename = "TriggerBackgrounded")]
        TriggerBackgrounded,
        #[serde(rename = "MemoryLimitExceeded")]
        MemoryLimitExceeded,
        #[serde(rename = "DataSaverEnabled")]
        DataSaverEnabled,
        #[serde(rename = "TriggerUrlHasEffectiveUrl")]
        TriggerUrlHasEffectiveUrl,
        #[serde(rename = "ActivatedBeforeStarted")]
        ActivatedBeforeStarted,
        #[serde(rename = "InactivePageRestriction")]
        InactivePageRestriction,
        #[serde(rename = "StartFailed")]
        StartFailed,
        #[serde(rename = "TimeoutBackgrounded")]
        TimeoutBackgrounded,
        #[serde(rename = "CrossSiteRedirectInInitialNavigation")]
        CrossSiteRedirectInInitialNavigation,
        #[serde(rename = "CrossSiteNavigationInInitialNavigation")]
        CrossSiteNavigationInInitialNavigation,
        #[serde(rename = "SameSiteCrossOriginRedirectNotOptInInInitialNavigation")]
        SameSiteCrossOriginRedirectNotOptInInInitialNavigation,
        #[serde(rename = "SameSiteCrossOriginNavigationNotOptInInInitialNavigation")]
        SameSiteCrossOriginNavigationNotOptInInInitialNavigation,
        #[serde(rename = "ActivationNavigationParameterMismatch")]
        ActivationNavigationParameterMismatch,
        #[serde(rename = "ActivatedInBackground")]
        ActivatedInBackground,
        #[serde(rename = "EmbedderHostDisallowed")]
        EmbedderHostDisallowed,
        #[serde(rename = "ActivationNavigationDestroyedBeforeSuccess")]
        ActivationNavigationDestroyedBeforeSuccess,
        #[serde(rename = "TabClosedByUserGesture")]
        TabClosedByUserGesture,
        #[serde(rename = "TabClosedWithoutUserGesture")]
        TabClosedWithoutUserGesture,
        #[serde(rename = "PrimaryMainFrameRendererProcessCrashed")]
        PrimaryMainFrameRendererProcessCrashed,
        #[serde(rename = "PrimaryMainFrameRendererProcessKilled")]
        PrimaryMainFrameRendererProcessKilled,
        #[serde(rename = "ActivationFramePolicyNotCompatible")]
        ActivationFramePolicyNotCompatible,
        #[serde(rename = "PreloadingDisabled")]
        PreloadingDisabled,
        #[serde(rename = "BatterySaverEnabled")]
        BatterySaverEnabled,
        #[serde(rename = "ActivatedDuringMainFrameNavigation")]
        ActivatedDuringMainFrameNavigation,
        #[serde(rename = "PreloadingUnsupportedByWebContents")]
        PreloadingUnsupportedByWebContents,
        #[serde(rename = "CrossSiteRedirectInMainFrameNavigation")]
        CrossSiteRedirectInMainFrameNavigation,
        #[serde(rename = "CrossSiteNavigationInMainFrameNavigation")]
        CrossSiteNavigationInMainFrameNavigation,
        #[serde(rename = "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation,
        #[serde(rename = "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation")]
        SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation,
        #[serde(rename = "MemoryPressureOnTrigger")]
        MemoryPressureOnTrigger,
        #[serde(rename = "MemoryPressureAfterTriggered")]
        MemoryPressureAfterTriggered,
        #[serde(rename = "PrerenderingDisabledByDevTools")]
        PrerenderingDisabledByDevTools,
        #[serde(rename = "SpeculationRuleRemoved")]
        SpeculationRuleRemoved,
        #[serde(rename = "ActivatedWithAuxiliaryBrowsingContexts")]
        ActivatedWithAuxiliaryBrowsingContexts,
        #[serde(rename = "MaxNumOfRunningEagerPrerendersExceeded")]
        MaxNumOfRunningEagerPrerendersExceeded,
        #[serde(rename = "MaxNumOfRunningNonEagerPrerendersExceeded")]
        MaxNumOfRunningNonEagerPrerendersExceeded,
        #[serde(rename = "MaxNumOfRunningEmbedderPrerendersExceeded")]
        MaxNumOfRunningEmbedderPrerendersExceeded,
        #[serde(rename = "PrerenderingUrlHasEffectiveUrl")]
        PrerenderingUrlHasEffectiveUrl,
        #[serde(rename = "RedirectedPrerenderingUrlHasEffectiveUrl")]
        RedirectedPrerenderingUrlHasEffectiveUrl,
        #[serde(rename = "ActivationUrlHasEffectiveUrl")]
        ActivationUrlHasEffectiveUrl,
        #[serde(rename = "JavaScriptInterfaceAdded")]
        JavaScriptInterfaceAdded,
        #[serde(rename = "JavaScriptInterfaceRemoved")]
        JavaScriptInterfaceRemoved,
        #[serde(rename = "AllPrerenderingCanceled")]
        AllPrerenderingCanceled,
        #[serde(rename = "WindowClosed")]
        WindowClosed,
        #[serde(rename = "SlowNetwork")]
        SlowNetwork,
        #[serde(rename = "OtherPrerenderedPageActivated")]
        OtherPrerenderedPageActivated,
        #[serde(rename = "V8OptimizerDisabled")]
        V8OptimizerDisabled,
        #[serde(rename = "PrerenderFailedDuringPrefetch")]
        PrerenderFailedDuringPrefetch,
        #[serde(rename = "BrowsingDataRemoved")]
        BrowsingDataRemoved,
        #[serde(rename = "PrerenderHostReused")]
        PrerenderHostReused,
    }
    impl From<&str> for PrerenderFinalStatus {
        fn from(s: &str) -> Self {
            match s {
                "Activated" => Self::Activated,
                "Destroyed" => Self::Destroyed,
                "LowEndDevice" => Self::LowEndDevice,
                "InvalidSchemeRedirect" => Self::InvalidSchemeRedirect,
                "InvalidSchemeNavigation" => Self::InvalidSchemeNavigation,
                "NavigationRequestBlockedByCsp" => Self::NavigationRequestBlockedByCsp,
                "MojoBinderPolicy" => Self::MojoBinderPolicy,
                "RendererProcessCrashed" => Self::RendererProcessCrashed,
                "RendererProcessKilled" => Self::RendererProcessKilled,
                "Download" => Self::Download,
                "TriggerDestroyed" => Self::TriggerDestroyed,
                "NavigationNotCommitted" => Self::NavigationNotCommitted,
                "NavigationBadHttpStatus" => Self::NavigationBadHttpStatus,
                "ClientCertRequested" => Self::ClientCertRequested,
                "NavigationRequestNetworkError" => Self::NavigationRequestNetworkError,
                "CancelAllHostsForTesting" => Self::CancelAllHostsForTesting,
                "DidFailLoad" => Self::DidFailLoad,
                "Stop" => Self::Stop,
                "SslCertificateError" => Self::SslCertificateError,
                "LoginAuthRequested" => Self::LoginAuthRequested,
                "UaChangeRequiresReload" => Self::UaChangeRequiresReload,
                "BlockedByClient" => Self::BlockedByClient,
                "AudioOutputDeviceRequested" => Self::AudioOutputDeviceRequested,
                "MixedContent" => Self::MixedContent,
                "TriggerBackgrounded" => Self::TriggerBackgrounded,
                "MemoryLimitExceeded" => Self::MemoryLimitExceeded,
                "DataSaverEnabled" => Self::DataSaverEnabled,
                "TriggerUrlHasEffectiveUrl" => Self::TriggerUrlHasEffectiveUrl,
                "ActivatedBeforeStarted" => Self::ActivatedBeforeStarted,
                "InactivePageRestriction" => Self::InactivePageRestriction,
                "StartFailed" => Self::StartFailed,
                "TimeoutBackgrounded" => Self::TimeoutBackgrounded,
                "CrossSiteRedirectInInitialNavigation" => {
                    Self::CrossSiteRedirectInInitialNavigation
                }
                "CrossSiteNavigationInInitialNavigation" => {
                    Self::CrossSiteNavigationInInitialNavigation
                }
                "SameSiteCrossOriginRedirectNotOptInInInitialNavigation" => {
                    Self::SameSiteCrossOriginRedirectNotOptInInInitialNavigation
                }
                "SameSiteCrossOriginNavigationNotOptInInInitialNavigation" => {
                    Self::SameSiteCrossOriginNavigationNotOptInInInitialNavigation
                }
                "ActivationNavigationParameterMismatch" => {
                    Self::ActivationNavigationParameterMismatch
                }
                "ActivatedInBackground" => Self::ActivatedInBackground,
                "EmbedderHostDisallowed" => Self::EmbedderHostDisallowed,
                "ActivationNavigationDestroyedBeforeSuccess" => {
                    Self::ActivationNavigationDestroyedBeforeSuccess
                }
                "TabClosedByUserGesture" => Self::TabClosedByUserGesture,
                "TabClosedWithoutUserGesture" => Self::TabClosedWithoutUserGesture,
                "PrimaryMainFrameRendererProcessCrashed" => {
                    Self::PrimaryMainFrameRendererProcessCrashed
                }
                "PrimaryMainFrameRendererProcessKilled" => {
                    Self::PrimaryMainFrameRendererProcessKilled
                }
                "ActivationFramePolicyNotCompatible" => Self::ActivationFramePolicyNotCompatible,
                "PreloadingDisabled" => Self::PreloadingDisabled,
                "BatterySaverEnabled" => Self::BatterySaverEnabled,
                "ActivatedDuringMainFrameNavigation" => Self::ActivatedDuringMainFrameNavigation,
                "PreloadingUnsupportedByWebContents" => Self::PreloadingUnsupportedByWebContents,
                "CrossSiteRedirectInMainFrameNavigation" => {
                    Self::CrossSiteRedirectInMainFrameNavigation
                }
                "CrossSiteNavigationInMainFrameNavigation" => {
                    Self::CrossSiteNavigationInMainFrameNavigation
                }
                "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation" => {
                    Self::SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation
                }
                "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation" => {
                    Self::SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation
                }
                "MemoryPressureOnTrigger" => Self::MemoryPressureOnTrigger,
                "MemoryPressureAfterTriggered" => Self::MemoryPressureAfterTriggered,
                "PrerenderingDisabledByDevTools" => Self::PrerenderingDisabledByDevTools,
                "SpeculationRuleRemoved" => Self::SpeculationRuleRemoved,
                "ActivatedWithAuxiliaryBrowsingContexts" => {
                    Self::ActivatedWithAuxiliaryBrowsingContexts
                }
                "MaxNumOfRunningEagerPrerendersExceeded" => {
                    Self::MaxNumOfRunningEagerPrerendersExceeded
                }
                "MaxNumOfRunningNonEagerPrerendersExceeded" => {
                    Self::MaxNumOfRunningNonEagerPrerendersExceeded
                }
                "MaxNumOfRunningEmbedderPrerendersExceeded" => {
                    Self::MaxNumOfRunningEmbedderPrerendersExceeded
                }
                "PrerenderingUrlHasEffectiveUrl" => Self::PrerenderingUrlHasEffectiveUrl,
                "RedirectedPrerenderingUrlHasEffectiveUrl" => {
                    Self::RedirectedPrerenderingUrlHasEffectiveUrl
                }
                "ActivationUrlHasEffectiveUrl" => Self::ActivationUrlHasEffectiveUrl,
                "JavaScriptInterfaceAdded" => Self::JavaScriptInterfaceAdded,
                "JavaScriptInterfaceRemoved" => Self::JavaScriptInterfaceRemoved,
                "AllPrerenderingCanceled" => Self::AllPrerenderingCanceled,
                "WindowClosed" => Self::WindowClosed,
                "SlowNetwork" => Self::SlowNetwork,
                "OtherPrerenderedPageActivated" => Self::OtherPrerenderedPageActivated,
                "V8OptimizerDisabled" => Self::V8OptimizerDisabled,
                "PrerenderFailedDuringPrefetch" => Self::PrerenderFailedDuringPrefetch,
                "BrowsingDataRemoved" => Self::BrowsingDataRemoved,
                "PrerenderHostReused" => Self::PrerenderHostReused,
                _ => Self::Activated,
            }
        }
    }
    impl From<String> for PrerenderFinalStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Preloading status values, see also PreloadingTriggeringOutcome. This status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PreloadingStatus {
        #[serde(rename = "Pending")]
        Pending,
        #[serde(rename = "Running")]
        Running,
        #[serde(rename = "Ready")]
        Ready,
        #[serde(rename = "Success")]
        Success,
        #[serde(rename = "Failure")]
        Failure,
        #[serde(rename = "NotSupported")]
        NotSupported,
    }
    impl From<&str> for PreloadingStatus {
        fn from(s: &str) -> Self {
            match s {
                "Pending" => Self::Pending,
                "Running" => Self::Running,
                "Ready" => Self::Ready,
                "Success" => Self::Success,
                "Failure" => Self::Failure,
                "NotSupported" => Self::NotSupported,
                _ => Self::Pending,
            }
        }
    }
    impl From<String> for PreloadingStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and filter out the ones that aren't necessary to the developers.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum PrefetchStatus {
        #[serde(rename = "PrefetchAllowed")]
        PrefetchAllowed,
        #[serde(rename = "PrefetchFailedIneligibleRedirect")]
        PrefetchFailedIneligibleRedirect,
        #[serde(rename = "PrefetchFailedInvalidRedirect")]
        PrefetchFailedInvalidRedirect,
        #[serde(rename = "PrefetchFailedMIMENotSupported")]
        PrefetchFailedMimeNotSupported,
        #[serde(rename = "PrefetchFailedNetError")]
        PrefetchFailedNetError,
        #[serde(rename = "PrefetchFailedNon2XX")]
        PrefetchFailedNon2Xx,
        #[serde(rename = "PrefetchEvictedAfterBrowsingDataRemoved")]
        PrefetchEvictedAfterBrowsingDataRemoved,
        #[serde(rename = "PrefetchEvictedAfterCandidateRemoved")]
        PrefetchEvictedAfterCandidateRemoved,
        #[serde(rename = "PrefetchEvictedForNewerPrefetch")]
        PrefetchEvictedForNewerPrefetch,
        #[serde(rename = "PrefetchHeldback")]
        PrefetchHeldback,
        #[serde(rename = "PrefetchIneligibleRetryAfter")]
        PrefetchIneligibleRetryAfter,
        #[serde(rename = "PrefetchIsPrivacyDecoy")]
        PrefetchIsPrivacyDecoy,
        #[serde(rename = "PrefetchIsStale")]
        PrefetchIsStale,
        #[serde(rename = "PrefetchNotEligibleBrowserContextOffTheRecord")]
        PrefetchNotEligibleBrowserContextOffTheRecord,
        #[serde(rename = "PrefetchNotEligibleDataSaverEnabled")]
        PrefetchNotEligibleDataSaverEnabled,
        #[serde(rename = "PrefetchNotEligibleExistingProxy")]
        PrefetchNotEligibleExistingProxy,
        #[serde(rename = "PrefetchNotEligibleHostIsNonUnique")]
        PrefetchNotEligibleHostIsNonUnique,
        #[serde(rename = "PrefetchNotEligibleNonDefaultStoragePartition")]
        PrefetchNotEligibleNonDefaultStoragePartition,
        #[serde(rename = "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy")]
        PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy,
        #[serde(rename = "PrefetchNotEligibleSchemeIsNotHttps")]
        PrefetchNotEligibleSchemeIsNotHttps,
        #[serde(rename = "PrefetchNotEligibleUserHasCookies")]
        PrefetchNotEligibleUserHasCookies,
        #[serde(rename = "PrefetchNotEligibleUserHasServiceWorker")]
        PrefetchNotEligibleUserHasServiceWorker,
        #[serde(rename = "PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler")]
        PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler,
        #[serde(rename = "PrefetchNotEligibleRedirectFromServiceWorker")]
        PrefetchNotEligibleRedirectFromServiceWorker,
        #[serde(rename = "PrefetchNotEligibleRedirectToServiceWorker")]
        PrefetchNotEligibleRedirectToServiceWorker,
        #[serde(rename = "PrefetchNotEligibleBatterySaverEnabled")]
        PrefetchNotEligibleBatterySaverEnabled,
        #[serde(rename = "PrefetchNotEligiblePreloadingDisabled")]
        PrefetchNotEligiblePreloadingDisabled,
        #[serde(rename = "PrefetchNotFinishedInTime")]
        PrefetchNotFinishedInTime,
        #[serde(rename = "PrefetchNotStarted")]
        PrefetchNotStarted,
        #[serde(rename = "PrefetchNotUsedCookiesChanged")]
        PrefetchNotUsedCookiesChanged,
        #[serde(rename = "PrefetchProxyNotAvailable")]
        PrefetchProxyNotAvailable,
        #[serde(rename = "PrefetchResponseUsed")]
        PrefetchResponseUsed,
        #[serde(rename = "PrefetchSuccessfulButNotUsed")]
        PrefetchSuccessfulButNotUsed,
        #[serde(rename = "PrefetchNotUsedProbeFailed")]
        PrefetchNotUsedProbeFailed,
    }
    impl From<&str> for PrefetchStatus {
        fn from(s: &str) -> Self {
            match s {
                "PrefetchAllowed" => Self::PrefetchAllowed,
                "PrefetchFailedIneligibleRedirect" => Self::PrefetchFailedIneligibleRedirect,
                "PrefetchFailedInvalidRedirect" => Self::PrefetchFailedInvalidRedirect,
                "PrefetchFailedMIMENotSupported" => Self::PrefetchFailedMimeNotSupported,
                "PrefetchFailedNetError" => Self::PrefetchFailedNetError,
                "PrefetchFailedNon2XX" => Self::PrefetchFailedNon2Xx,
                "PrefetchEvictedAfterBrowsingDataRemoved" => {
                    Self::PrefetchEvictedAfterBrowsingDataRemoved
                }
                "PrefetchEvictedAfterCandidateRemoved" => {
                    Self::PrefetchEvictedAfterCandidateRemoved
                }
                "PrefetchEvictedForNewerPrefetch" => Self::PrefetchEvictedForNewerPrefetch,
                "PrefetchHeldback" => Self::PrefetchHeldback,
                "PrefetchIneligibleRetryAfter" => Self::PrefetchIneligibleRetryAfter,
                "PrefetchIsPrivacyDecoy" => Self::PrefetchIsPrivacyDecoy,
                "PrefetchIsStale" => Self::PrefetchIsStale,
                "PrefetchNotEligibleBrowserContextOffTheRecord" => {
                    Self::PrefetchNotEligibleBrowserContextOffTheRecord
                }
                "PrefetchNotEligibleDataSaverEnabled" => Self::PrefetchNotEligibleDataSaverEnabled,
                "PrefetchNotEligibleExistingProxy" => Self::PrefetchNotEligibleExistingProxy,
                "PrefetchNotEligibleHostIsNonUnique" => Self::PrefetchNotEligibleHostIsNonUnique,
                "PrefetchNotEligibleNonDefaultStoragePartition" => {
                    Self::PrefetchNotEligibleNonDefaultStoragePartition
                }
                "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy" => {
                    Self::PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy
                }
                "PrefetchNotEligibleSchemeIsNotHttps" => Self::PrefetchNotEligibleSchemeIsNotHttps,
                "PrefetchNotEligibleUserHasCookies" => Self::PrefetchNotEligibleUserHasCookies,
                "PrefetchNotEligibleUserHasServiceWorker" => {
                    Self::PrefetchNotEligibleUserHasServiceWorker
                }
                "PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler" => {
                    Self::PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler
                }
                "PrefetchNotEligibleRedirectFromServiceWorker" => {
                    Self::PrefetchNotEligibleRedirectFromServiceWorker
                }
                "PrefetchNotEligibleRedirectToServiceWorker" => {
                    Self::PrefetchNotEligibleRedirectToServiceWorker
                }
                "PrefetchNotEligibleBatterySaverEnabled" => {
                    Self::PrefetchNotEligibleBatterySaverEnabled
                }
                "PrefetchNotEligiblePreloadingDisabled" => {
                    Self::PrefetchNotEligiblePreloadingDisabled
                }
                "PrefetchNotFinishedInTime" => Self::PrefetchNotFinishedInTime,
                "PrefetchNotStarted" => Self::PrefetchNotStarted,
                "PrefetchNotUsedCookiesChanged" => Self::PrefetchNotUsedCookiesChanged,
                "PrefetchProxyNotAvailable" => Self::PrefetchProxyNotAvailable,
                "PrefetchResponseUsed" => Self::PrefetchResponseUsed,
                "PrefetchSuccessfulButNotUsed" => Self::PrefetchSuccessfulButNotUsed,
                "PrefetchNotUsedProbeFailed" => Self::PrefetchNotUsedProbeFailed,
                _ => Self::PrefetchAllowed,
            }
        }
    }
    impl From<String> for PrefetchStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Information of headers to be displayed when the header mismatch occurred.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrerenderMismatchedHeaders {
        #[serde(rename = "headerName")]
        pub header_name: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "initialValue")]
        pub initial_value: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "activationValue")]
        pub activation_value: Option<String>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Preload.enable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Preload.disable";
    }

    /// Upsert. Currently, it is only emitted when a rule set added.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RuleSetUpdated {
        #[serde(rename = "ruleSet")]
        pub rule_set: RuleSet,
    }

    impl RuleSetUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Preload.ruleSetUpdated")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RuleSetRemoved {
        pub id: RuleSetId,
    }

    impl RuleSetRemoved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Preload.ruleSetRemoved")
        }
    }

    /// Fired when a preload enabled state is updated.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PreloadEnabledStateUpdated {
        #[serde(rename = "disabledByPreference")]
        pub disabled_by_preference: bool,
        #[serde(rename = "disabledByDataSaver")]
        pub disabled_by_data_saver: bool,
        #[serde(rename = "disabledByBatterySaver")]
        pub disabled_by_battery_saver: bool,
        #[serde(rename = "disabledByHoldbackPrefetchSpeculationRules")]
        pub disabled_by_holdback_prefetch_speculation_rules: bool,
        #[serde(rename = "disabledByHoldbackPrerenderSpeculationRules")]
        pub disabled_by_holdback_prerender_speculation_rules: bool,
    }

    impl PreloadEnabledStateUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Preload.preloadEnabledStateUpdated")
        }
    }

    /// Fired when a prefetch attempt is updated.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrefetchStatusUpdated {
        pub key: PreloadingAttemptKey,
        #[serde(rename = "pipelineId")]
        pub pipeline_id: PreloadPipelineId,
        /// The frame id of the frame initiating prefetch.
        #[serde(rename = "initiatingFrameId")]
        pub initiating_frame_id: page::FrameId,
        #[serde(rename = "prefetchUrl")]
        pub prefetch_url: String,
        pub status: PreloadingStatus,
        #[serde(rename = "prefetchStatus")]
        pub prefetch_status: PrefetchStatus,
        #[serde(rename = "requestId")]
        pub request_id: network::RequestId,
    }

    impl PrefetchStatusUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Preload.prefetchStatusUpdated")
        }
    }

    /// Fired when a prerender attempt is updated.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrerenderStatusUpdated {
        pub key: PreloadingAttemptKey,
        #[serde(rename = "pipelineId")]
        pub pipeline_id: PreloadPipelineId,
        pub status: PreloadingStatus,
        #[serde(rename = "prerenderStatus")]
        pub prerender_status: Option<PrerenderFinalStatus>,
        /// This is used to give users more information about the name of Mojo interface that is incompatible with prerender and has caused the cancellation of the attempt.
        #[serde(rename = "disallowedMojoInterface")]
        pub disallowed_mojo_interface: Option<String>,
        #[serde(rename = "mismatchedHeaders")]
        pub mismatched_headers: Option<Vec<PrerenderMismatchedHeaders>>,
    }

    impl PrerenderStatusUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Preload.prerenderStatusUpdated")
        }
    }

    /// Send a list of sources for all preloading attempts in a document.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PreloadingAttemptSourcesUpdated {
        #[serde(rename = "loaderId")]
        pub loader_id: network::LoaderId,
        #[serde(rename = "preloadingAttemptSources")]
        pub preloading_attempt_sources: Vec<PreloadingAttemptSource>,
    }

    impl PreloadingAttemptSourcesUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Preload.preloadingAttemptSourcesUpdated")
        }
    }
}

pub mod security {
    use super::*;

    /// An internal certificate ID value.
    pub type CertificateId = i64;

    /// A description of mixed content (HTTP resources on HTTPS pages), as defined by https://www.w3.org/TR/mixed-content/#categories
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MixedContentType {
        #[serde(rename = "blockable")]
        Blockable,
        #[serde(rename = "optionally-blockable")]
        OptionallyBlockable,
        #[serde(rename = "none")]
        None,
    }
    impl From<&str> for MixedContentType {
        fn from(s: &str) -> Self {
            match s {
                "blockable" => Self::Blockable,
                "optionally-blockable" => Self::OptionallyBlockable,
                "none" => Self::None,
                _ => Self::Blockable,
            }
        }
    }
    impl From<String> for MixedContentType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// The security level of a page or resource.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SecurityState {
        #[serde(rename = "unknown")]
        Unknown,
        #[serde(rename = "neutral")]
        Neutral,
        #[serde(rename = "insecure")]
        Insecure,
        #[serde(rename = "secure")]
        Secure,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "insecure-broken")]
        InsecureBroken,
    }
    impl From<&str> for SecurityState {
        fn from(s: &str) -> Self {
            match s {
                "unknown" => Self::Unknown,
                "neutral" => Self::Neutral,
                "insecure" => Self::Insecure,
                "secure" => Self::Secure,
                "info" => Self::Info,
                "insecure-broken" => Self::InsecureBroken,
                _ => Self::Unknown,
            }
        }
    }
    impl From<String> for SecurityState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Details about the security state of the page certificate.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CertificateSecurityState {
        /// Protocol name (e.g. "TLS 1.2" or "QUIC").
        pub protocol: String,
        /// Key Exchange used by the connection, or the empty string if not applicable.
        #[serde(rename = "keyExchange")]
        pub key_exchange: String,
        /// (EC)DH group used by the connection, if applicable.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keyExchangeGroup")]
        pub key_exchange_group: Option<String>,
        /// Cipher name.
        pub cipher: String,
        /// TLS MAC. Note that AEAD ciphers do not have separate MACs.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub mac: Option<String>,
        /// Page certificate.
        pub certificate: Vec<String>,
        /// Certificate subject name.
        #[serde(rename = "subjectName")]
        pub subject_name: String,
        /// Name of the issuing CA.
        pub issuer: String,
        /// Certificate valid from date.
        #[serde(rename = "validFrom")]
        pub valid_from: network::TimeSinceEpoch,
        /// Certificate valid to (expiration) date
        #[serde(rename = "validTo")]
        pub valid_to: network::TimeSinceEpoch,
        /// The highest priority network error code, if the certificate has an error.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "certificateNetworkError")]
        pub certificate_network_error: Option<String>,
        /// True if the certificate uses a weak signature algorithm.
        #[serde(rename = "certificateHasWeakSignature")]
        pub certificate_has_weak_signature: bool,
        /// True if the certificate has a SHA1 signature in the chain.
        #[serde(rename = "certificateHasSha1Signature")]
        pub certificate_has_sha1_signature: bool,
        /// True if modern SSL
        #[serde(rename = "modernSSL")]
        pub modern_ssl: bool,
        /// True if the connection is using an obsolete SSL protocol.
        #[serde(rename = "obsoleteSslProtocol")]
        pub obsolete_ssl_protocol: bool,
        /// True if the connection is using an obsolete SSL key exchange.
        #[serde(rename = "obsoleteSslKeyExchange")]
        pub obsolete_ssl_key_exchange: bool,
        /// True if the connection is using an obsolete SSL cipher.
        #[serde(rename = "obsoleteSslCipher")]
        pub obsolete_ssl_cipher: bool,
        /// True if the connection is using an obsolete SSL signature.
        #[serde(rename = "obsoleteSslSignature")]
        pub obsolete_ssl_signature: bool,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SafetyTipStatus {
        #[serde(rename = "badReputation")]
        BadReputation,
        #[serde(rename = "lookalike")]
        Lookalike,
    }
    impl From<&str> for SafetyTipStatus {
        fn from(s: &str) -> Self {
            match s {
                "badReputation" => Self::BadReputation,
                "lookalike" => Self::Lookalike,
                _ => Self::BadReputation,
            }
        }
    }
    impl From<String> for SafetyTipStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SafetyTipInfo {
        /// Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
        #[serde(rename = "safetyTipStatus")]
        pub safety_tip_status: SafetyTipStatus,
        /// The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "safeUrl")]
        pub safe_url: Option<String>,
    }

    /// Security state information about the page.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VisibleSecurityState {
        /// The security level of the page.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        /// Security state details about the page certificate.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "certificateSecurityState")]
        pub certificate_security_state: Option<CertificateSecurityState>,
        /// The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "safetyTipInfo")]
        pub safety_tip_info: Option<SafetyTipInfo>,
        /// Array of security state issues ids.
        #[serde(rename = "securityStateIssueIds")]
        pub security_state_issue_ids: Vec<String>,
    }

    /// An explanation of an factor contributing to the security state.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SecurityStateExplanation {
        /// Security state representing the severity of the factor being explained.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        /// Title describing the type of factor.
        pub title: String,
        /// Short phrase describing the type of factor.
        pub summary: String,
        /// Full text explanation of the factor.
        pub description: String,
        /// The type of mixed content described by the explanation.
        #[serde(rename = "mixedContentType")]
        pub mixed_content_type: MixedContentType,
        /// Page certificate.
        pub certificate: Vec<String>,
        /// Recommendations to fix any issues.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub recommendations: Option<Vec<String>>,
    }

    /// Information about insecure content on the page.
    #[deprecated]
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InsecureContentStatus {
        /// Always false.
        #[serde(rename = "ranMixedContent")]
        pub ran_mixed_content: bool,
        /// Always false.
        #[serde(rename = "displayedMixedContent")]
        pub displayed_mixed_content: bool,
        /// Always false.
        #[serde(rename = "containedMixedForm")]
        pub contained_mixed_form: bool,
        /// Always false.
        #[serde(rename = "ranContentWithCertErrors")]
        pub ran_content_with_cert_errors: bool,
        /// Always false.
        #[serde(rename = "displayedContentWithCertErrors")]
        pub displayed_content_with_cert_errors: bool,
        /// Always set to unknown.
        #[serde(rename = "ranInsecureContentStyle")]
        pub ran_insecure_content_style: SecurityState,
        /// Always set to unknown.
        #[serde(rename = "displayedInsecureContentStyle")]
        pub displayed_insecure_content_style: SecurityState,
    }

    /// The action to take when a certificate error occurs. continue will continue processing the request and cancel will cancel the request.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum CertificateErrorAction {
        #[serde(rename = "continue")]
        Continue,
        #[serde(rename = "cancel")]
        Cancel,
    }
    impl From<&str> for CertificateErrorAction {
        fn from(s: &str) -> Self {
            match s {
                "continue" => Self::Continue,
                "cancel" => Self::Cancel,
                _ => Self::Continue,
            }
        }
    }
    impl From<String> for CertificateErrorAction {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Disables tracking security state changes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Security.disable";
    }

    /// Enables tracking security state changes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Security.enable";
    }

    /// Enable/disable whether all certificate errors should be ignored.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetIgnoreCertificateErrors {
        /// If true, all certificate errors will be ignored.
        ignore: bool,
    }

    impl SetIgnoreCertificateErrors {
        pub fn new(ignore: impl Into<bool>) -> Self {
            Self {
                ignore: ignore.into(),
            }
        }
    }

    impl Command for SetIgnoreCertificateErrors {
        type Response = ();
        const METHOD: &'static str = "Security.setIgnoreCertificateErrors";
    }

    /// Handles a certificate error that fired a certificateError event.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HandleCertificateError {
        /// The ID of the event.
        #[serde(rename = "eventId")]
        event_id: i64,
        /// The action to take on the certificate error.
        action: CertificateErrorAction,
    }

    impl HandleCertificateError {
        pub fn new(event_id: impl Into<i64>, action: impl Into<CertificateErrorAction>) -> Self {
            Self {
                event_id: event_id.into(),
                action: action.into(),
            }
        }
    }

    impl Command for HandleCertificateError {
        type Response = ();
        const METHOD: &'static str = "Security.handleCertificateError";
    }

    /// Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with `handleCertificateError` commands.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetOverrideCertificateErrors {
        /// If true, certificate errors will be overridden.
        #[serde(rename = "override")]
        override_: bool,
    }

    impl SetOverrideCertificateErrors {
        pub fn new(override_: impl Into<bool>) -> Self {
            Self {
                override_: override_.into(),
            }
        }
    }

    impl Command for SetOverrideCertificateErrors {
        type Response = ();
        const METHOD: &'static str = "Security.setOverrideCertificateErrors";
    }

    /// There is a certificate error. If overriding certificate errors is enabled, then it should be handled with the `handleCertificateError` command. Note: this event does not fire if the certificate error has been allowed internally. Only one client per target should override certificate errors at the same time.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CertificateError {
        /// The ID of the event.
        #[serde(rename = "eventId")]
        pub event_id: i64,
        /// The type of the error.
        #[serde(rename = "errorType")]
        pub error_type: String,
        /// The url that was requested.
        #[serde(rename = "requestURL")]
        pub request_url: String,
    }

    impl CertificateError {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Security.certificateError")
        }
    }

    /// The security state of the page changed.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VisibleSecurityStateChanged {
        /// Security state information about the page.
        #[serde(rename = "visibleSecurityState")]
        pub visible_security_state: VisibleSecurityState,
    }

    impl VisibleSecurityStateChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Security.visibleSecurityStateChanged")
        }
    }

    /// The security state of the page changed. No longer being sent.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SecurityStateChanged {
        /// Security state.
        #[serde(rename = "securityState")]
        pub security_state: SecurityState,
        /// True if the page was loaded over cryptographic transport such as HTTPS.
        #[deprecated]
        #[serde(rename = "schemeIsCryptographic")]
        pub scheme_is_cryptographic: bool,
        /// Previously a list of explanations for the security state. Now always empty.
        #[deprecated]
        pub explanations: Vec<SecurityStateExplanation>,
        /// Information about insecure content on the page.
        #[deprecated]
        #[serde(rename = "insecureContentStatus")]
        pub insecure_content_status: InsecureContentStatus,
        /// Overrides user-visible description of the state. Always omitted.
        #[deprecated]
        pub summary: Option<String>,
    }

    impl SecurityStateChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Security.securityStateChanged")
        }
    }
}

pub mod serviceworker {
    use super::*;

    pub type RegistrationID = String;

    /// ServiceWorker registration.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ServiceWorkerRegistration {
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationID,
        #[serde(rename = "scopeURL")]
        pub scope_url: String,
        #[serde(rename = "isDeleted")]
        pub is_deleted: bool,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ServiceWorkerVersionRunningStatus {
        #[serde(rename = "stopped")]
        Stopped,
        #[serde(rename = "starting")]
        Starting,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "stopping")]
        Stopping,
    }
    impl From<&str> for ServiceWorkerVersionRunningStatus {
        fn from(s: &str) -> Self {
            match s {
                "stopped" => Self::Stopped,
                "starting" => Self::Starting,
                "running" => Self::Running,
                "stopping" => Self::Stopping,
                _ => Self::Stopped,
            }
        }
    }
    impl From<String> for ServiceWorkerVersionRunningStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ServiceWorkerVersionStatus {
        #[serde(rename = "new")]
        New,
        #[serde(rename = "installing")]
        Installing,
        #[serde(rename = "installed")]
        Installed,
        #[serde(rename = "activating")]
        Activating,
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "redundant")]
        Redundant,
    }
    impl From<&str> for ServiceWorkerVersionStatus {
        fn from(s: &str) -> Self {
            match s {
                "new" => Self::New,
                "installing" => Self::Installing,
                "installed" => Self::Installed,
                "activating" => Self::Activating,
                "activated" => Self::Activated,
                "redundant" => Self::Redundant,
                _ => Self::New,
            }
        }
    }
    impl From<String> for ServiceWorkerVersionStatus {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// ServiceWorker version.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ServiceWorkerVersion {
        #[serde(rename = "versionId")]
        pub version_id: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationID,
        #[serde(rename = "scriptURL")]
        pub script_url: String,
        #[serde(rename = "runningStatus")]
        pub running_status: ServiceWorkerVersionRunningStatus,
        pub status: ServiceWorkerVersionStatus,
        /// The Last-Modified header value of the main script.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptLastModified")]
        pub script_last_modified: Option<f64>,
        /// The time at which the response headers of the main script were received from the server. For cached script it is the last time the cache entry was validated.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptResponseTime")]
        pub script_response_time: Option<f64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "controlledClients")]
        pub controlled_clients: Option<Vec<target::TargetID>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetId")]
        pub target_id: Option<target::TargetID>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "routerRules")]
        pub router_rules: Option<String>,
    }

    /// ServiceWorker error message.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ServiceWorkerErrorMessage {
        #[serde(rename = "errorMessage")]
        pub error_message: String,
        #[serde(rename = "registrationId")]
        pub registration_id: RegistrationID,
        #[serde(rename = "versionId")]
        pub version_id: String,
        #[serde(rename = "sourceURL")]
        pub source_url: String,
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeliverPushMessage {
        origin: String,
        #[serde(rename = "registrationId")]
        registration_id: RegistrationID,
        data: String,
    }

    impl DeliverPushMessage {
        pub fn new(
            origin: impl Into<String>,
            registration_id: impl Into<RegistrationID>,
            data: impl Into<String>,
        ) -> Self {
            Self {
                origin: origin.into(),
                registration_id: registration_id.into(),
                data: data.into(),
            }
        }
    }

    impl Command for DeliverPushMessage {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.deliverPushMessage";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.disable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchSyncEvent {
        origin: String,
        #[serde(rename = "registrationId")]
        registration_id: RegistrationID,
        tag: String,
        #[serde(rename = "lastChance")]
        last_chance: bool,
    }

    impl DispatchSyncEvent {
        pub fn new(
            origin: impl Into<String>,
            registration_id: impl Into<RegistrationID>,
            tag: impl Into<String>,
            last_chance: impl Into<bool>,
        ) -> Self {
            Self {
                origin: origin.into(),
                registration_id: registration_id.into(),
                tag: tag.into(),
                last_chance: last_chance.into(),
            }
        }
    }

    impl Command for DispatchSyncEvent {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.dispatchSyncEvent";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DispatchPeriodicSyncEvent {
        origin: String,
        #[serde(rename = "registrationId")]
        registration_id: RegistrationID,
        tag: String,
    }

    impl DispatchPeriodicSyncEvent {
        pub fn new(
            origin: impl Into<String>,
            registration_id: impl Into<RegistrationID>,
            tag: impl Into<String>,
        ) -> Self {
            Self {
                origin: origin.into(),
                registration_id: registration_id.into(),
                tag: tag.into(),
            }
        }
    }

    impl Command for DispatchPeriodicSyncEvent {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.dispatchPeriodicSyncEvent";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.enable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetForceUpdateOnPageLoad {
        #[serde(rename = "forceUpdateOnPageLoad")]
        force_update_on_page_load: bool,
    }

    impl SetForceUpdateOnPageLoad {
        pub fn new(force_update_on_page_load: impl Into<bool>) -> Self {
            Self {
                force_update_on_page_load: force_update_on_page_load.into(),
            }
        }
    }

    impl Command for SetForceUpdateOnPageLoad {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.setForceUpdateOnPageLoad";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SkipWaiting {
        #[serde(rename = "scopeURL")]
        scope_url: String,
    }

    impl SkipWaiting {
        pub fn new(scope_url: impl Into<String>) -> Self {
            Self {
                scope_url: scope_url.into(),
            }
        }
    }

    impl Command for SkipWaiting {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.skipWaiting";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartWorker {
        #[serde(rename = "scopeURL")]
        scope_url: String,
    }

    impl StartWorker {
        pub fn new(scope_url: impl Into<String>) -> Self {
            Self {
                scope_url: scope_url.into(),
            }
        }
    }

    impl Command for StartWorker {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.startWorker";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopAllWorkers {}

    impl StopAllWorkers {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopAllWorkers {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.stopAllWorkers";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopWorker {
        #[serde(rename = "versionId")]
        version_id: String,
    }

    impl StopWorker {
        pub fn new(version_id: impl Into<String>) -> Self {
            Self {
                version_id: version_id.into(),
            }
        }
    }

    impl Command for StopWorker {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.stopWorker";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Unregister {
        #[serde(rename = "scopeURL")]
        scope_url: String,
    }

    impl Unregister {
        pub fn new(scope_url: impl Into<String>) -> Self {
            Self {
                scope_url: scope_url.into(),
            }
        }
    }

    impl Command for Unregister {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.unregister";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UpdateRegistration {
        #[serde(rename = "scopeURL")]
        scope_url: String,
    }

    impl UpdateRegistration {
        pub fn new(scope_url: impl Into<String>) -> Self {
            Self {
                scope_url: scope_url.into(),
            }
        }
    }

    impl Command for UpdateRegistration {
        type Response = ();
        const METHOD: &'static str = "ServiceWorker.updateRegistration";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WorkerErrorReported {
        #[serde(rename = "errorMessage")]
        pub error_message: ServiceWorkerErrorMessage,
    }

    impl WorkerErrorReported {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("ServiceWorker.workerErrorReported")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WorkerRegistrationUpdated {
        pub registrations: Vec<ServiceWorkerRegistration>,
    }

    impl WorkerRegistrationUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("ServiceWorker.workerRegistrationUpdated")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WorkerVersionUpdated {
        pub versions: Vec<ServiceWorkerVersion>,
    }

    impl WorkerVersionUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("ServiceWorker.workerVersionUpdated")
        }
    }
}

pub mod smart_card_emulation {
    use super::*;

    /// Indicates the PC/SC error code. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__ErrorCodes.html Microsoft: https://learn.microsoft.com/en-us/windows/win32/secauthn/authentication-return-values
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ResultCode {
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "removed-card")]
        RemovedCard,
        #[serde(rename = "reset-card")]
        ResetCard,
        #[serde(rename = "unpowered-card")]
        UnpoweredCard,
        #[serde(rename = "unresponsive-card")]
        UnresponsiveCard,
        #[serde(rename = "unsupported-card")]
        UnsupportedCard,
        #[serde(rename = "reader-unavailable")]
        ReaderUnavailable,
        #[serde(rename = "sharing-violation")]
        SharingViolation,
        #[serde(rename = "not-transacted")]
        NotTransacted,
        #[serde(rename = "no-smartcard")]
        NoSmartcard,
        #[serde(rename = "proto-mismatch")]
        ProtoMismatch,
        #[serde(rename = "system-cancelled")]
        SystemCancelled,
        #[serde(rename = "not-ready")]
        NotReady,
        #[serde(rename = "cancelled")]
        Cancelled,
        #[serde(rename = "insufficient-buffer")]
        InsufficientBuffer,
        #[serde(rename = "invalid-handle")]
        InvalidHandle,
        #[serde(rename = "invalid-parameter")]
        InvalidParameter,
        #[serde(rename = "invalid-value")]
        InvalidValue,
        #[serde(rename = "no-memory")]
        NoMemory,
        #[serde(rename = "timeout")]
        Timeout,
        #[serde(rename = "unknown-reader")]
        UnknownReader,
        #[serde(rename = "unsupported-feature")]
        UnsupportedFeature,
        #[serde(rename = "no-readers-available")]
        NoReadersAvailable,
        #[serde(rename = "service-stopped")]
        ServiceStopped,
        #[serde(rename = "no-service")]
        NoService,
        #[serde(rename = "comm-error")]
        CommError,
        #[serde(rename = "internal-error")]
        InternalError,
        #[serde(rename = "server-too-busy")]
        ServerTooBusy,
        #[serde(rename = "unexpected")]
        Unexpected,
        #[serde(rename = "shutdown")]
        Shutdown,
        #[serde(rename = "unknown-card")]
        UnknownCard,
        #[serde(rename = "unknown")]
        Unknown,
    }
    impl From<&str> for ResultCode {
        fn from(s: &str) -> Self {
            match s {
                "success" => Self::Success,
                "removed-card" => Self::RemovedCard,
                "reset-card" => Self::ResetCard,
                "unpowered-card" => Self::UnpoweredCard,
                "unresponsive-card" => Self::UnresponsiveCard,
                "unsupported-card" => Self::UnsupportedCard,
                "reader-unavailable" => Self::ReaderUnavailable,
                "sharing-violation" => Self::SharingViolation,
                "not-transacted" => Self::NotTransacted,
                "no-smartcard" => Self::NoSmartcard,
                "proto-mismatch" => Self::ProtoMismatch,
                "system-cancelled" => Self::SystemCancelled,
                "not-ready" => Self::NotReady,
                "cancelled" => Self::Cancelled,
                "insufficient-buffer" => Self::InsufficientBuffer,
                "invalid-handle" => Self::InvalidHandle,
                "invalid-parameter" => Self::InvalidParameter,
                "invalid-value" => Self::InvalidValue,
                "no-memory" => Self::NoMemory,
                "timeout" => Self::Timeout,
                "unknown-reader" => Self::UnknownReader,
                "unsupported-feature" => Self::UnsupportedFeature,
                "no-readers-available" => Self::NoReadersAvailable,
                "service-stopped" => Self::ServiceStopped,
                "no-service" => Self::NoService,
                "comm-error" => Self::CommError,
                "internal-error" => Self::InternalError,
                "server-too-busy" => Self::ServerTooBusy,
                "unexpected" => Self::Unexpected,
                "shutdown" => Self::Shutdown,
                "unknown-card" => Self::UnknownCard,
                "unknown" => Self::Unknown,
                _ => Self::Success,
            }
        }
    }
    impl From<String> for ResultCode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Maps to the |SCARD_SHARE_*| values.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ShareMode {
        #[serde(rename = "shared")]
        Shared,
        #[serde(rename = "exclusive")]
        Exclusive,
        #[serde(rename = "direct")]
        Direct,
    }
    impl From<&str> for ShareMode {
        fn from(s: &str) -> Self {
            match s {
                "shared" => Self::Shared,
                "exclusive" => Self::Exclusive,
                "direct" => Self::Direct,
                _ => Self::Shared,
            }
        }
    }
    impl From<String> for ShareMode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Indicates what the reader should do with the card.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum Disposition {
        #[serde(rename = "leave-card")]
        LeaveCard,
        #[serde(rename = "reset-card")]
        ResetCard,
        #[serde(rename = "unpower-card")]
        UnpowerCard,
        #[serde(rename = "eject-card")]
        EjectCard,
    }
    impl From<&str> for Disposition {
        fn from(s: &str) -> Self {
            match s {
                "leave-card" => Self::LeaveCard,
                "reset-card" => Self::ResetCard,
                "unpower-card" => Self::UnpowerCard,
                "eject-card" => Self::EjectCard,
                _ => Self::LeaveCard,
            }
        }
    }
    impl From<String> for Disposition {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Maps to |SCARD_*| connection state values.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ConnectionState {
        #[serde(rename = "absent")]
        Absent,
        #[serde(rename = "present")]
        Present,
        #[serde(rename = "swallowed")]
        Swallowed,
        #[serde(rename = "powered")]
        Powered,
        #[serde(rename = "negotiable")]
        Negotiable,
        #[serde(rename = "specific")]
        Specific,
    }
    impl From<&str> for ConnectionState {
        fn from(s: &str) -> Self {
            match s {
                "absent" => Self::Absent,
                "present" => Self::Present,
                "swallowed" => Self::Swallowed,
                "powered" => Self::Powered,
                "negotiable" => Self::Negotiable,
                "specific" => Self::Specific,
                _ => Self::Absent,
            }
        }
    }
    impl From<String> for ConnectionState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Maps to the |SCARD_STATE_*| flags.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReaderStateFlags {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub unaware: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub ignore: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub changed: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub unknown: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub unavailable: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub empty: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub present: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub exclusive: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub inuse: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub mute: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub unpowered: Option<bool>,
    }

    /// Maps to the |SCARD_PROTOCOL_*| flags.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProtocolSet {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub t0: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub t1: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub raw: Option<bool>,
    }

    /// Maps to the |SCARD_PROTOCOL_*| values.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum Protocol {
        #[serde(rename = "t0")]
        T0,
        #[serde(rename = "t1")]
        T1,
        #[serde(rename = "raw")]
        Raw,
    }
    impl From<&str> for Protocol {
        fn from(s: &str) -> Self {
            match s {
                "t0" => Self::T0,
                "t1" => Self::T1,
                "raw" => Self::Raw,
                _ => Self::T0,
            }
        }
    }
    impl From<String> for Protocol {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReaderStateIn {
        pub reader: String,
        #[serde(rename = "currentState")]
        pub current_state: ReaderStateFlags,
        #[serde(rename = "currentInsertionCount")]
        pub current_insertion_count: i64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReaderStateOut {
        pub reader: String,
        #[serde(rename = "eventState")]
        pub event_state: ReaderStateFlags,
        #[serde(rename = "eventCount")]
        pub event_count: i64,
        pub atr: String,
    }

    /// Enables the |SmartCardEmulation| domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.enable";
    }

    /// Disables the |SmartCardEmulation| domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.disable";
    }

    /// Reports the successful result of a |SCardEstablishContext| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaa1b8970169fd4883a6dc4a8f43f19b67 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardestablishcontext
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportEstablishContextResult {
        #[serde(rename = "requestId")]
        request_id: String,
        #[serde(rename = "contextId")]
        context_id: i64,
    }

    impl ReportEstablishContextResult {
        pub fn new(request_id: impl Into<String>, context_id: impl Into<i64>) -> Self {
            Self {
                request_id: request_id.into(),
                context_id: context_id.into(),
            }
        }
    }

    impl Command for ReportEstablishContextResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportEstablishContextResult";
    }

    /// Reports the successful result of a |SCardReleaseContext| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga6aabcba7744c5c9419fdd6404f73a934 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreleasecontext
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportReleaseContextResult {
        #[serde(rename = "requestId")]
        request_id: String,
    }

    impl ReportReleaseContextResult {
        pub fn new(request_id: impl Into<String>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for ReportReleaseContextResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportReleaseContextResult";
    }

    /// Reports the successful result of a |SCardListReaders| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga93b07815789b3cf2629d439ecf20f0d9 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadersa
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportListReadersResult {
        #[serde(rename = "requestId")]
        request_id: String,
        readers: Vec<String>,
    }

    impl ReportListReadersResult {
        pub fn new(request_id: impl Into<String>, readers: impl Into<Vec<String>>) -> Self {
            Self {
                request_id: request_id.into(),
                readers: readers.into(),
            }
        }
    }

    impl Command for ReportListReadersResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportListReadersResult";
    }

    /// Reports the successful result of a |SCardGetStatusChange| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga33247d5d1257d59e55647c3bb717db24 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangea
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportGetStatusChangeResult {
        #[serde(rename = "requestId")]
        request_id: String,
        #[serde(rename = "readerStates")]
        reader_states: Vec<ReaderStateOut>,
    }

    impl ReportGetStatusChangeResult {
        pub fn new(
            request_id: impl Into<String>,
            reader_states: impl Into<Vec<ReaderStateOut>>,
        ) -> Self {
            Self {
                request_id: request_id.into(),
                reader_states: reader_states.into(),
            }
        }
    }

    impl Command for ReportGetStatusChangeResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportGetStatusChangeResult";
    }

    /// Reports the result of a |SCardBeginTransaction| call. On success, this creates a new transaction object. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaddb835dce01a0da1d6ca02d33ee7d861 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardbegintransaction
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportBeginTransactionResult {
        #[serde(rename = "requestId")]
        request_id: String,
        handle: i64,
    }

    impl ReportBeginTransactionResult {
        pub fn new(request_id: impl Into<String>, handle: impl Into<i64>) -> Self {
            Self {
                request_id: request_id.into(),
                handle: handle.into(),
            }
        }
    }

    impl Command for ReportBeginTransactionResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportBeginTransactionResult";
    }

    /// Reports the successful result of a call that returns only a result code. Used for: |SCardCancel|, |SCardDisconnect|, |SCardSetAttrib|, |SCardEndTransaction|. This maps to: 1. SCardCancel  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacbbc0c6d6c0cbbeb4f4debf6fbeeee6  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcancel 2. SCardDisconnect  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4be198045c73ec0deb79e66c0ca1738a  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scarddisconnect 3. SCardSetAttrib  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga060f0038a4ddfd5dd2b8fadf3c3a2e4f  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardsetattrib 4. SCardEndTransaction  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae8742473b404363e5c587f570d7e2f3b  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardendtransaction
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportPlainResult {
        #[serde(rename = "requestId")]
        request_id: String,
    }

    impl ReportPlainResult {
        pub fn new(request_id: impl Into<String>) -> Self {
            Self {
                request_id: request_id.into(),
            }
        }
    }

    impl Command for ReportPlainResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportPlainResult";
    }

    /// Reports the successful result of a |SCardConnect| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4e515829752e0a8dbc4d630696a8d6a5 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnecta
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportConnectResult {
        #[serde(rename = "requestId")]
        request_id: String,
        handle: i64,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "activeProtocol")]
        active_protocol: Option<Protocol>,
    }

    impl ReportConnectResult {
        pub fn new(request_id: impl Into<String>, handle: impl Into<i64>) -> Self {
            Self {
                request_id: request_id.into(),
                handle: handle.into(),
                active_protocol: None,
            }
        }

        pub fn with_active_protocol(mut self, active_protocol: impl Into<Protocol>) -> Self {
            self.active_protocol = Some(active_protocol.into());
            self
        }
    }

    impl Command for ReportConnectResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportConnectResult";
    }

    /// Reports the successful result of a call that sends back data on success. Used for |SCardTransmit|, |SCardControl|, and |SCardGetAttrib|. This maps to: 1. SCardTransmit  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga9a2d77242a271310269065e64633ab99  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardtransmit 2. SCardControl  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gac3454d4657110fd7f753b2d3d8f4e32f  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol 3. SCardGetAttrib  PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602  Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportDataResult {
        #[serde(rename = "requestId")]
        request_id: String,
        data: String,
    }

    impl ReportDataResult {
        pub fn new(request_id: impl Into<String>, data: impl Into<String>) -> Self {
            Self {
                request_id: request_id.into(),
                data: data.into(),
            }
        }
    }

    impl Command for ReportDataResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportDataResult";
    }

    /// Reports the successful result of a |SCardStatus| call. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusa
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportStatusResult {
        #[serde(rename = "requestId")]
        request_id: String,
        #[serde(rename = "readerName")]
        reader_name: String,
        state: ConnectionState,
        atr: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        protocol: Option<Protocol>,
    }

    impl ReportStatusResult {
        pub fn new(
            request_id: impl Into<String>,
            reader_name: impl Into<String>,
            state: impl Into<ConnectionState>,
            atr: impl Into<String>,
        ) -> Self {
            Self {
                request_id: request_id.into(),
                reader_name: reader_name.into(),
                state: state.into(),
                atr: atr.into(),
                protocol: None,
            }
        }

        pub fn with_protocol(mut self, protocol: impl Into<Protocol>) -> Self {
            self.protocol = Some(protocol.into());
            self
        }
    }

    impl Command for ReportStatusResult {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportStatusResult";
    }

    /// Reports an error result for the given request.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportError {
        #[serde(rename = "requestId")]
        request_id: String,
        #[serde(rename = "resultCode")]
        result_code: ResultCode,
    }

    impl ReportError {
        pub fn new(request_id: impl Into<String>, result_code: impl Into<ResultCode>) -> Self {
            Self {
                request_id: request_id.into(),
                result_code: result_code.into(),
            }
        }
    }

    impl Command for ReportError {
        type Response = ();
        const METHOD: &'static str = "SmartCardEmulation.reportError";
    }

    /// Fired when |SCardEstablishContext| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaa1b8970169fd4883a6dc4a8f43f19b67 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardestablishcontext
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EstablishContextRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
    }

    impl EstablishContextRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.establishContextRequested")
        }
    }

    /// Fired when |SCardReleaseContext| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga6aabcba7744c5c9419fdd6404f73a934 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardreleasecontext
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReleaseContextRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        #[serde(rename = "contextId")]
        pub context_id: i64,
    }

    impl ReleaseContextRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.releaseContextRequested")
        }
    }

    /// Fired when |SCardListReaders| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga93b07815789b3cf2629d439ecf20f0d9 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardlistreadersa
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ListReadersRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        #[serde(rename = "contextId")]
        pub context_id: i64,
    }

    impl ListReadersRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.listReadersRequested")
        }
    }

    /// Fired when |SCardGetStatusChange| is called. Timeout is specified in milliseconds. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga33247d5d1257d59e55647c3bb717db24 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetstatuschangea
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStatusChangeRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        #[serde(rename = "contextId")]
        pub context_id: i64,
        #[serde(rename = "readerStates")]
        pub reader_states: Vec<ReaderStateIn>,
        /// in milliseconds, if absent, it means "infinite"
        pub timeout: Option<i64>,
    }

    impl GetStatusChangeRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.getStatusChangeRequested")
        }
    }

    /// Fired when |SCardCancel| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacbbc0c6d6c0cbbeb4f4debf6fbeeee6 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcancel
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CancelRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        #[serde(rename = "contextId")]
        pub context_id: i64,
    }

    impl CancelRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("SmartCardEmulation.cancelRequested")
        }
    }

    /// Fired when |SCardConnect| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4e515829752e0a8dbc4d630696a8d6a5 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardconnecta
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConnectRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        #[serde(rename = "contextId")]
        pub context_id: i64,
        pub reader: String,
        #[serde(rename = "shareMode")]
        pub share_mode: ShareMode,
        #[serde(rename = "preferredProtocols")]
        pub preferred_protocols: ProtocolSet,
    }

    impl ConnectRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.connectRequested")
        }
    }

    /// Fired when |SCardDisconnect| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga4be198045c73ec0deb79e66c0ca1738a Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scarddisconnect
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DisconnectRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        pub disposition: Disposition,
    }

    impl DisconnectRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.disconnectRequested")
        }
    }

    /// Fired when |SCardTransmit| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga9a2d77242a271310269065e64633ab99 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardtransmit
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TransmitRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        pub data: String,
        pub protocol: Option<Protocol>,
    }

    impl TransmitRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.transmitRequested")
        }
    }

    /// Fired when |SCardControl| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gac3454d4657110fd7f753b2d3d8f4e32f Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardcontrol
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ControlRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        #[serde(rename = "controlCode")]
        pub control_code: i64,
        pub data: String,
    }

    impl ControlRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.controlRequested")
        }
    }

    /// Fired when |SCardGetAttrib| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaacfec51917255b7a25b94c5104961602 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardgetattrib
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAttribRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        #[serde(rename = "attribId")]
        pub attrib_id: i64,
    }

    impl GetAttribRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.getAttribRequested")
        }
    }

    /// Fired when |SCardSetAttrib| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#ga060f0038a4ddfd5dd2b8fadf3c3a2e4f Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardsetattrib
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttribRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        #[serde(rename = "attribId")]
        pub attrib_id: i64,
        pub data: String,
    }

    impl SetAttribRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.setAttribRequested")
        }
    }

    /// Fired when |SCardStatus| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae49c3c894ad7ac12a5b896bde70d0382 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardstatusa
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StatusRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
    }

    impl StatusRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("SmartCardEmulation.statusRequested")
        }
    }

    /// Fired when |SCardBeginTransaction| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gaddb835dce01a0da1d6ca02d33ee7d861 Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardbegintransaction
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BeginTransactionRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
    }

    impl BeginTransactionRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.beginTransactionRequested")
        }
    }

    /// Fired when |SCardEndTransaction| is called. This maps to: PC/SC Lite: https://pcsclite.apdu.fr/api/group__API.html#gae8742473b404363e5c587f570d7e2f3b Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/winscard/nf-winscard-scardendtransaction
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EndTransactionRequested {
        #[serde(rename = "requestId")]
        pub request_id: String,
        pub handle: i64,
        pub disposition: Disposition,
    }

    impl EndTransactionRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("SmartCardEmulation.endTransactionRequested")
        }
    }
}

pub mod storage {
    use super::*;

    pub type SerializedStorageKey = String;

    /// Enum of possible storage types.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StorageType {
        #[serde(rename = "cookies")]
        Cookies,
        #[serde(rename = "file_systems")]
        FileSystems,
        #[serde(rename = "indexeddb")]
        Indexeddb,
        #[serde(rename = "local_storage")]
        LocalStorage,
        #[serde(rename = "shader_cache")]
        ShaderCache,
        #[serde(rename = "websql")]
        Websql,
        #[serde(rename = "service_workers")]
        ServiceWorkers,
        #[serde(rename = "cache_storage")]
        CacheStorage,
        #[serde(rename = "interest_groups")]
        InterestGroups,
        #[serde(rename = "shared_storage")]
        SharedStorage,
        #[serde(rename = "storage_buckets")]
        StorageBuckets,
        #[serde(rename = "all")]
        All,
        #[serde(rename = "other")]
        Other,
    }
    impl From<&str> for StorageType {
        fn from(s: &str) -> Self {
            match s {
                "cookies" => Self::Cookies,
                "file_systems" => Self::FileSystems,
                "indexeddb" => Self::Indexeddb,
                "local_storage" => Self::LocalStorage,
                "shader_cache" => Self::ShaderCache,
                "websql" => Self::Websql,
                "service_workers" => Self::ServiceWorkers,
                "cache_storage" => Self::CacheStorage,
                "interest_groups" => Self::InterestGroups,
                "shared_storage" => Self::SharedStorage,
                "storage_buckets" => Self::StorageBuckets,
                "all" => Self::All,
                "other" => Self::Other,
                _ => Self::Cookies,
            }
        }
    }
    impl From<String> for StorageType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Usage for a storage type.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UsageForType {
        /// Name of storage type.
        #[serde(rename = "storageType")]
        pub storage_type: StorageType,
        /// Storage usage (bytes).
        pub usage: f64,
    }

    /// Pair of issuer origin and number of available (signed, but not used) Trust Tokens from that issuer.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrustTokens {
        #[serde(rename = "issuerOrigin")]
        pub issuer_origin: String,
        pub count: f64,
    }

    /// Protected audience interest group auction identifier.
    pub type InterestGroupAuctionId = String;

    /// Enum of interest group access types.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InterestGroupAccessType {
        #[serde(rename = "join")]
        Join,
        #[serde(rename = "leave")]
        Leave,
        #[serde(rename = "update")]
        Update,
        #[serde(rename = "loaded")]
        Loaded,
        #[serde(rename = "bid")]
        Bid,
        #[serde(rename = "win")]
        Win,
        #[serde(rename = "additionalBid")]
        AdditionalBid,
        #[serde(rename = "additionalBidWin")]
        AdditionalBidWin,
        #[serde(rename = "topLevelBid")]
        TopLevelBid,
        #[serde(rename = "topLevelAdditionalBid")]
        TopLevelAdditionalBid,
        #[serde(rename = "clear")]
        Clear,
    }
    impl From<&str> for InterestGroupAccessType {
        fn from(s: &str) -> Self {
            match s {
                "join" => Self::Join,
                "leave" => Self::Leave,
                "update" => Self::Update,
                "loaded" => Self::Loaded,
                "bid" => Self::Bid,
                "win" => Self::Win,
                "additionalBid" => Self::AdditionalBid,
                "additionalBidWin" => Self::AdditionalBidWin,
                "topLevelBid" => Self::TopLevelBid,
                "topLevelAdditionalBid" => Self::TopLevelAdditionalBid,
                "clear" => Self::Clear,
                _ => Self::Join,
            }
        }
    }
    impl From<String> for InterestGroupAccessType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of auction events.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InterestGroupAuctionEventType {
        #[serde(rename = "started")]
        Started,
        #[serde(rename = "configResolved")]
        ConfigResolved,
    }
    impl From<&str> for InterestGroupAuctionEventType {
        fn from(s: &str) -> Self {
            match s {
                "started" => Self::Started,
                "configResolved" => Self::ConfigResolved,
                _ => Self::Started,
            }
        }
    }
    impl From<String> for InterestGroupAuctionEventType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of network fetches auctions can do.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum InterestGroupAuctionFetchType {
        #[serde(rename = "bidderJs")]
        BidderJs,
        #[serde(rename = "bidderWasm")]
        BidderWasm,
        #[serde(rename = "sellerJs")]
        SellerJs,
        #[serde(rename = "bidderTrustedSignals")]
        BidderTrustedSignals,
        #[serde(rename = "sellerTrustedSignals")]
        SellerTrustedSignals,
    }
    impl From<&str> for InterestGroupAuctionFetchType {
        fn from(s: &str) -> Self {
            match s {
                "bidderJs" => Self::BidderJs,
                "bidderWasm" => Self::BidderWasm,
                "sellerJs" => Self::SellerJs,
                "bidderTrustedSignals" => Self::BidderTrustedSignals,
                "sellerTrustedSignals" => Self::SellerTrustedSignals,
                _ => Self::BidderJs,
            }
        }
    }
    impl From<String> for InterestGroupAuctionFetchType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of shared storage access scopes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SharedStorageAccessScope {
        #[serde(rename = "window")]
        Window,
        #[serde(rename = "sharedStorageWorklet")]
        SharedStorageWorklet,
        #[serde(rename = "protectedAudienceWorklet")]
        ProtectedAudienceWorklet,
        #[serde(rename = "header")]
        Header,
    }
    impl From<&str> for SharedStorageAccessScope {
        fn from(s: &str) -> Self {
            match s {
                "window" => Self::Window,
                "sharedStorageWorklet" => Self::SharedStorageWorklet,
                "protectedAudienceWorklet" => Self::ProtectedAudienceWorklet,
                "header" => Self::Header,
                _ => Self::Window,
            }
        }
    }
    impl From<String> for SharedStorageAccessScope {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of shared storage access methods.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SharedStorageAccessMethod {
        #[serde(rename = "addModule")]
        AddModule,
        #[serde(rename = "createWorklet")]
        CreateWorklet,
        #[serde(rename = "selectURL")]
        SelectUrl,
        #[serde(rename = "run")]
        Run,
        #[serde(rename = "batchUpdate")]
        BatchUpdate,
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "append")]
        Append,
        #[serde(rename = "delete")]
        Delete,
        #[serde(rename = "clear")]
        Clear,
        #[serde(rename = "get")]
        Get,
        #[serde(rename = "keys")]
        Keys,
        #[serde(rename = "values")]
        Values,
        #[serde(rename = "entries")]
        Entries,
        #[serde(rename = "length")]
        Length,
        #[serde(rename = "remainingBudget")]
        RemainingBudget,
    }
    impl From<&str> for SharedStorageAccessMethod {
        fn from(s: &str) -> Self {
            match s {
                "addModule" => Self::AddModule,
                "createWorklet" => Self::CreateWorklet,
                "selectURL" => Self::SelectUrl,
                "run" => Self::Run,
                "batchUpdate" => Self::BatchUpdate,
                "set" => Self::Set,
                "append" => Self::Append,
                "delete" => Self::Delete,
                "clear" => Self::Clear,
                "get" => Self::Get,
                "keys" => Self::Keys,
                "values" => Self::Values,
                "entries" => Self::Entries,
                "length" => Self::Length,
                "remainingBudget" => Self::RemainingBudget,
                _ => Self::AddModule,
            }
        }
    }
    impl From<String> for SharedStorageAccessMethod {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Struct for a single key-value pair in an origin's shared storage.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageEntry {
        pub key: String,
        pub value: String,
    }

    /// Details for an origin's shared storage.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageMetadata {
        /// Time when the origin's shared storage was last created.
        #[serde(rename = "creationTime")]
        pub creation_time: network::TimeSinceEpoch,
        /// Number of key-value pairs stored in origin's shared storage.
        pub length: i64,
        /// Current amount of bits of entropy remaining in the navigation budget.
        #[serde(rename = "remainingBudget")]
        pub remaining_budget: f64,
        /// Total number of bytes stored as key-value pairs in origin's shared storage.
        #[serde(rename = "bytesUsed")]
        pub bytes_used: i64,
    }

    /// Represents a dictionary object passed in as privateAggregationConfig to run or selectURL.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStoragePrivateAggregationConfig {
        /// The chosen aggregation service deployment.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "aggregationCoordinatorOrigin")]
        pub aggregation_coordinator_origin: Option<String>,
        /// The context ID provided.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contextId")]
        pub context_id: Option<String>,
        /// Configures the maximum size allowed for filtering IDs.
        #[serde(rename = "filteringIdMaxBytes")]
        pub filtering_id_max_bytes: i64,
        /// The limit on the number of contributions in the final report.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxContributions")]
        pub max_contributions: Option<i64>,
    }

    /// Pair of reporting metadata details for a candidate URL for `selectURL()`.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageReportingMetadata {
        #[serde(rename = "eventType")]
        pub event_type: String,
        #[serde(rename = "reportingUrl")]
        pub reporting_url: String,
    }

    /// Bundles a candidate URL with its reporting metadata.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageUrlWithMetadata {
        /// Spec of candidate URL.
        pub url: String,
        /// Any associated reporting metadata.
        #[serde(rename = "reportingMetadata")]
        pub reporting_metadata: Vec<SharedStorageReportingMetadata>,
    }

    /// Bundles the parameters for shared storage access events whose presence/absence can vary according to SharedStorageAccessType.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageAccessParams {
        /// Spec of the module script URL. Present only for SharedStorageAccessMethods: addModule and createWorklet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptSourceUrl")]
        pub script_source_url: Option<String>,
        /// String denoting "context-origin", "script-origin", or a custom origin to be used as the worklet's data origin. Present only for SharedStorageAccessMethod: createWorklet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dataOrigin")]
        pub data_origin: Option<String>,
        /// Name of the registered operation to be run. Present only for SharedStorageAccessMethods: run and selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "operationName")]
        pub operation_name: Option<String>,
        /// ID of the operation call. Present only for SharedStorageAccessMethods: run and selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "operationId")]
        pub operation_id: Option<String>,
        /// Whether or not to keep the worket alive for future run or selectURL calls. Present only for SharedStorageAccessMethods: run and selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "keepAlive")]
        pub keep_alive: Option<bool>,
        /// Configures the private aggregation options. Present only for SharedStorageAccessMethods: run and selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "privateAggregationConfig")]
        pub private_aggregation_config: Option<SharedStoragePrivateAggregationConfig>,
        /// The operation's serialized data in bytes (converted to a string). Present only for SharedStorageAccessMethods: run and selectURL. TODO(crbug.com/401011862): Consider updating this parameter to binary.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serializedData")]
        pub serialized_data: Option<String>,
        /// Array of candidate URLs' specs, along with any associated metadata. Present only for SharedStorageAccessMethod: selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlsWithMetadata")]
        pub urls_with_metadata: Option<Vec<SharedStorageUrlWithMetadata>>,
        /// Spec of the URN:UUID generated for a selectURL call. Present only for SharedStorageAccessMethod: selectURL.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urnUuid")]
        pub urn_uuid: Option<String>,
        /// Key for a specific entry in an origin's shared storage. Present only for SharedStorageAccessMethods: set, append, delete, and get.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub key: Option<String>,
        /// Value for a specific entry in an origin's shared storage. Present only for SharedStorageAccessMethods: set and append.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
        /// Whether or not to set an entry for a key if that key is already present. Present only for SharedStorageAccessMethod: set.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ignoreIfPresent")]
        pub ignore_if_present: Option<bool>,
        /// A number denoting the (0-based) order of the worklet's creation relative to all other shared storage worklets created by documents using the current storage partition. Present only for SharedStorageAccessMethods: addModule, createWorklet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workletOrdinal")]
        pub worklet_ordinal: Option<i64>,
        /// Hex representation of the DevTools token used as the TargetID for the associated shared storage worklet. Present only for SharedStorageAccessMethods: addModule, createWorklet, run, selectURL, and any other SharedStorageAccessMethod when the SharedStorageAccessScope is sharedStorageWorklet.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "workletTargetId")]
        pub worklet_target_id: Option<target::TargetID>,
        /// Name of the lock to be acquired, if present. Optionally present only for SharedStorageAccessMethods: batchUpdate, set, append, delete, and clear.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "withLock")]
        pub with_lock: Option<String>,
        /// If the method has been called as part of a batchUpdate, then this number identifies the batch to which it belongs. Optionally present only for SharedStorageAccessMethods: batchUpdate (required), set, append, delete, and clear.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "batchUpdateId")]
        pub batch_update_id: Option<String>,
        /// Number of modifier methods sent in batch. Present only for SharedStorageAccessMethod: batchUpdate.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "batchSize")]
        pub batch_size: Option<i64>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StorageBucketsDurability {
        #[serde(rename = "relaxed")]
        Relaxed,
        #[serde(rename = "strict")]
        Strict,
    }
    impl From<&str> for StorageBucketsDurability {
        fn from(s: &str) -> Self {
            match s {
                "relaxed" => Self::Relaxed,
                "strict" => Self::Strict,
                _ => Self::Relaxed,
            }
        }
    }
    impl From<String> for StorageBucketsDurability {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StorageBucket {
        #[serde(rename = "storageKey")]
        pub storage_key: SerializedStorageKey,
        /// If not specified, it is the default bucket of the storageKey.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StorageBucketInfo {
        pub bucket: StorageBucket,
        pub id: String,
        pub expiration: network::TimeSinceEpoch,
        /// Storage quota (bytes).
        pub quota: f64,
        pub persistent: bool,
        pub durability: StorageBucketsDurability,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingSourceType {
        #[serde(rename = "navigation")]
        Navigation,
        #[serde(rename = "event")]
        Event,
    }
    impl From<&str> for AttributionReportingSourceType {
        fn from(s: &str) -> Self {
            match s {
                "navigation" => Self::Navigation,
                "event" => Self::Event,
                _ => Self::Navigation,
            }
        }
    }
    impl From<String> for AttributionReportingSourceType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type UnsignedInt64AsBase10 = String;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type UnsignedInt128AsBase16 = String;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type SignedInt64AsBase10 = String;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingFilterDataEntry {
        pub key: String,
        pub values: Vec<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingFilterConfig {
        #[serde(rename = "filterValues")]
        pub filter_values: Vec<AttributionReportingFilterDataEntry>,
        /// duration in seconds
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "lookbackWindow")]
        pub lookback_window: Option<i64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingFilterPair {
        pub filters: Vec<AttributionReportingFilterConfig>,
        #[serde(rename = "notFilters")]
        pub not_filters: Vec<AttributionReportingFilterConfig>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregationKeysEntry {
        pub key: String,
        pub value: UnsignedInt128AsBase16,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingEventReportWindows {
        /// duration in seconds
        pub start: i64,
        /// duration in seconds
        pub ends: Vec<i64>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingTriggerDataMatching {
        #[serde(rename = "exact")]
        Exact,
        #[serde(rename = "modulus")]
        Modulus,
    }
    impl From<&str> for AttributionReportingTriggerDataMatching {
        fn from(s: &str) -> Self {
            match s {
                "exact" => Self::Exact,
                "modulus" => Self::Modulus,
                _ => Self::Exact,
            }
        }
    }
    impl From<String> for AttributionReportingTriggerDataMatching {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableDebugReportingData {
        #[serde(rename = "keyPiece")]
        pub key_piece: UnsignedInt128AsBase16,
        /// number instead of integer because not all uint32 can be represented by int
        pub value: f64,
        pub types: Vec<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableDebugReportingConfig {
        /// number instead of integer because not all uint32 can be represented by int, only present for source registrations
        #[serde(skip_serializing_if = "Option::is_none")]
        pub budget: Option<f64>,
        #[serde(rename = "keyPiece")]
        pub key_piece: UnsignedInt128AsBase16,
        #[serde(rename = "debugData")]
        pub debug_data: Vec<AttributionReportingAggregatableDebugReportingData>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "aggregationCoordinatorOrigin")]
        pub aggregation_coordinator_origin: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionScopesData {
        pub values: Vec<String>,
        /// number instead of integer because not all uint32 can be represented by int
        pub limit: f64,
        #[serde(rename = "maxEventStates")]
        pub max_event_states: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingNamedBudgetDef {
        pub name: String,
        pub budget: i64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingSourceRegistration {
        pub time: network::TimeSinceEpoch,
        /// duration in seconds
        pub expiry: i64,
        /// number instead of integer because not all uint32 can be represented by int
        #[serde(rename = "triggerData")]
        pub trigger_data: Vec<f64>,
        #[serde(rename = "eventReportWindows")]
        pub event_report_windows: AttributionReportingEventReportWindows,
        /// duration in seconds
        #[serde(rename = "aggregatableReportWindow")]
        pub aggregatable_report_window: i64,
        #[serde(rename = "type")]
        pub type_: AttributionReportingSourceType,
        #[serde(rename = "sourceOrigin")]
        pub source_origin: String,
        #[serde(rename = "reportingOrigin")]
        pub reporting_origin: String,
        #[serde(rename = "destinationSites")]
        pub destination_sites: Vec<String>,
        #[serde(rename = "eventId")]
        pub event_id: UnsignedInt64AsBase10,
        pub priority: SignedInt64AsBase10,
        #[serde(rename = "filterData")]
        pub filter_data: Vec<AttributionReportingFilterDataEntry>,
        #[serde(rename = "aggregationKeys")]
        pub aggregation_keys: Vec<AttributionReportingAggregationKeysEntry>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "debugKey")]
        pub debug_key: Option<UnsignedInt64AsBase10>,
        #[serde(rename = "triggerDataMatching")]
        pub trigger_data_matching: AttributionReportingTriggerDataMatching,
        #[serde(rename = "destinationLimitPriority")]
        pub destination_limit_priority: SignedInt64AsBase10,
        #[serde(rename = "aggregatableDebugReportingConfig")]
        pub aggregatable_debug_reporting_config:
            AttributionReportingAggregatableDebugReportingConfig,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scopesData")]
        pub scopes_data: Option<AttributionScopesData>,
        #[serde(rename = "maxEventLevelReports")]
        pub max_event_level_reports: i64,
        #[serde(rename = "namedBudgets")]
        pub named_budgets: Vec<AttributionReportingNamedBudgetDef>,
        #[serde(rename = "debugReporting")]
        pub debug_reporting: bool,
        #[serde(rename = "eventLevelEpsilon")]
        pub event_level_epsilon: f64,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingSourceRegistrationResult {
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "internalError")]
        InternalError,
        #[serde(rename = "insufficientSourceCapacity")]
        InsufficientSourceCapacity,
        #[serde(rename = "insufficientUniqueDestinationCapacity")]
        InsufficientUniqueDestinationCapacity,
        #[serde(rename = "excessiveReportingOrigins")]
        ExcessiveReportingOrigins,
        #[serde(rename = "prohibitedByBrowserPolicy")]
        ProhibitedByBrowserPolicy,
        #[serde(rename = "successNoised")]
        SuccessNoised,
        #[serde(rename = "destinationReportingLimitReached")]
        DestinationReportingLimitReached,
        #[serde(rename = "destinationGlobalLimitReached")]
        DestinationGlobalLimitReached,
        #[serde(rename = "destinationBothLimitsReached")]
        DestinationBothLimitsReached,
        #[serde(rename = "reportingOriginsPerSiteLimitReached")]
        ReportingOriginsPerSiteLimitReached,
        #[serde(rename = "exceedsMaxChannelCapacity")]
        ExceedsMaxChannelCapacity,
        #[serde(rename = "exceedsMaxScopesChannelCapacity")]
        ExceedsMaxScopesChannelCapacity,
        #[serde(rename = "exceedsMaxTriggerStateCardinality")]
        ExceedsMaxTriggerStateCardinality,
        #[serde(rename = "exceedsMaxEventStatesLimit")]
        ExceedsMaxEventStatesLimit,
        #[serde(rename = "destinationPerDayReportingLimitReached")]
        DestinationPerDayReportingLimitReached,
    }
    impl From<&str> for AttributionReportingSourceRegistrationResult {
        fn from(s: &str) -> Self {
            match s {
                "success" => Self::Success,
                "internalError" => Self::InternalError,
                "insufficientSourceCapacity" => Self::InsufficientSourceCapacity,
                "insufficientUniqueDestinationCapacity" => {
                    Self::InsufficientUniqueDestinationCapacity
                }
                "excessiveReportingOrigins" => Self::ExcessiveReportingOrigins,
                "prohibitedByBrowserPolicy" => Self::ProhibitedByBrowserPolicy,
                "successNoised" => Self::SuccessNoised,
                "destinationReportingLimitReached" => Self::DestinationReportingLimitReached,
                "destinationGlobalLimitReached" => Self::DestinationGlobalLimitReached,
                "destinationBothLimitsReached" => Self::DestinationBothLimitsReached,
                "reportingOriginsPerSiteLimitReached" => Self::ReportingOriginsPerSiteLimitReached,
                "exceedsMaxChannelCapacity" => Self::ExceedsMaxChannelCapacity,
                "exceedsMaxScopesChannelCapacity" => Self::ExceedsMaxScopesChannelCapacity,
                "exceedsMaxTriggerStateCardinality" => Self::ExceedsMaxTriggerStateCardinality,
                "exceedsMaxEventStatesLimit" => Self::ExceedsMaxEventStatesLimit,
                "destinationPerDayReportingLimitReached" => {
                    Self::DestinationPerDayReportingLimitReached
                }
                _ => Self::Success,
            }
        }
    }
    impl From<String> for AttributionReportingSourceRegistrationResult {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingSourceRegistrationTimeConfig {
        #[serde(rename = "include")]
        Include,
        #[serde(rename = "exclude")]
        Exclude,
    }
    impl From<&str> for AttributionReportingSourceRegistrationTimeConfig {
        fn from(s: &str) -> Self {
            match s {
                "include" => Self::Include,
                "exclude" => Self::Exclude,
                _ => Self::Include,
            }
        }
    }
    impl From<String> for AttributionReportingSourceRegistrationTimeConfig {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableValueDictEntry {
        pub key: String,
        /// number instead of integer because not all uint32 can be represented by int
        pub value: f64,
        #[serde(rename = "filteringId")]
        pub filtering_id: UnsignedInt64AsBase10,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableValueEntry {
        pub values: Vec<AttributionReportingAggregatableValueDictEntry>,
        pub filters: AttributionReportingFilterPair,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingEventTriggerData {
        pub data: UnsignedInt64AsBase10,
        pub priority: SignedInt64AsBase10,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dedupKey")]
        pub dedup_key: Option<UnsignedInt64AsBase10>,
        pub filters: AttributionReportingFilterPair,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableTriggerData {
        #[serde(rename = "keyPiece")]
        pub key_piece: UnsignedInt128AsBase16,
        #[serde(rename = "sourceKeys")]
        pub source_keys: Vec<String>,
        pub filters: AttributionReportingFilterPair,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingAggregatableDedupKey {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dedupKey")]
        pub dedup_key: Option<UnsignedInt64AsBase10>,
        pub filters: AttributionReportingFilterPair,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingNamedBudgetCandidate {
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        pub filters: AttributionReportingFilterPair,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingTriggerRegistration {
        pub filters: AttributionReportingFilterPair,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "debugKey")]
        pub debug_key: Option<UnsignedInt64AsBase10>,
        #[serde(rename = "aggregatableDedupKeys")]
        pub aggregatable_dedup_keys: Vec<AttributionReportingAggregatableDedupKey>,
        #[serde(rename = "eventTriggerData")]
        pub event_trigger_data: Vec<AttributionReportingEventTriggerData>,
        #[serde(rename = "aggregatableTriggerData")]
        pub aggregatable_trigger_data: Vec<AttributionReportingAggregatableTriggerData>,
        #[serde(rename = "aggregatableValues")]
        pub aggregatable_values: Vec<AttributionReportingAggregatableValueEntry>,
        #[serde(rename = "aggregatableFilteringIdMaxBytes")]
        pub aggregatable_filtering_id_max_bytes: i64,
        #[serde(rename = "debugReporting")]
        pub debug_reporting: bool,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "aggregationCoordinatorOrigin")]
        pub aggregation_coordinator_origin: Option<String>,
        #[serde(rename = "sourceRegistrationTimeConfig")]
        pub source_registration_time_config: AttributionReportingSourceRegistrationTimeConfig,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "triggerContextId")]
        pub trigger_context_id: Option<String>,
        #[serde(rename = "aggregatableDebugReportingConfig")]
        pub aggregatable_debug_reporting_config:
            AttributionReportingAggregatableDebugReportingConfig,
        pub scopes: Vec<String>,
        #[serde(rename = "namedBudgets")]
        pub named_budgets: Vec<AttributionReportingNamedBudgetCandidate>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingEventLevelResult {
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "successDroppedLowerPriority")]
        SuccessDroppedLowerPriority,
        #[serde(rename = "internalError")]
        InternalError,
        #[serde(rename = "noCapacityForAttributionDestination")]
        NoCapacityForAttributionDestination,
        #[serde(rename = "noMatchingSources")]
        NoMatchingSources,
        #[serde(rename = "deduplicated")]
        Deduplicated,
        #[serde(rename = "excessiveAttributions")]
        ExcessiveAttributions,
        #[serde(rename = "priorityTooLow")]
        PriorityTooLow,
        #[serde(rename = "neverAttributedSource")]
        NeverAttributedSource,
        #[serde(rename = "excessiveReportingOrigins")]
        ExcessiveReportingOrigins,
        #[serde(rename = "noMatchingSourceFilterData")]
        NoMatchingSourceFilterData,
        #[serde(rename = "prohibitedByBrowserPolicy")]
        ProhibitedByBrowserPolicy,
        #[serde(rename = "noMatchingConfigurations")]
        NoMatchingConfigurations,
        #[serde(rename = "excessiveReports")]
        ExcessiveReports,
        #[serde(rename = "falselyAttributedSource")]
        FalselyAttributedSource,
        #[serde(rename = "reportWindowPassed")]
        ReportWindowPassed,
        #[serde(rename = "notRegistered")]
        NotRegistered,
        #[serde(rename = "reportWindowNotStarted")]
        ReportWindowNotStarted,
        #[serde(rename = "noMatchingTriggerData")]
        NoMatchingTriggerData,
    }
    impl From<&str> for AttributionReportingEventLevelResult {
        fn from(s: &str) -> Self {
            match s {
                "success" => Self::Success,
                "successDroppedLowerPriority" => Self::SuccessDroppedLowerPriority,
                "internalError" => Self::InternalError,
                "noCapacityForAttributionDestination" => Self::NoCapacityForAttributionDestination,
                "noMatchingSources" => Self::NoMatchingSources,
                "deduplicated" => Self::Deduplicated,
                "excessiveAttributions" => Self::ExcessiveAttributions,
                "priorityTooLow" => Self::PriorityTooLow,
                "neverAttributedSource" => Self::NeverAttributedSource,
                "excessiveReportingOrigins" => Self::ExcessiveReportingOrigins,
                "noMatchingSourceFilterData" => Self::NoMatchingSourceFilterData,
                "prohibitedByBrowserPolicy" => Self::ProhibitedByBrowserPolicy,
                "noMatchingConfigurations" => Self::NoMatchingConfigurations,
                "excessiveReports" => Self::ExcessiveReports,
                "falselyAttributedSource" => Self::FalselyAttributedSource,
                "reportWindowPassed" => Self::ReportWindowPassed,
                "notRegistered" => Self::NotRegistered,
                "reportWindowNotStarted" => Self::ReportWindowNotStarted,
                "noMatchingTriggerData" => Self::NoMatchingTriggerData,
                _ => Self::Success,
            }
        }
    }
    impl From<String> for AttributionReportingEventLevelResult {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingAggregatableResult {
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "internalError")]
        InternalError,
        #[serde(rename = "noCapacityForAttributionDestination")]
        NoCapacityForAttributionDestination,
        #[serde(rename = "noMatchingSources")]
        NoMatchingSources,
        #[serde(rename = "excessiveAttributions")]
        ExcessiveAttributions,
        #[serde(rename = "excessiveReportingOrigins")]
        ExcessiveReportingOrigins,
        #[serde(rename = "noHistograms")]
        NoHistograms,
        #[serde(rename = "insufficientBudget")]
        InsufficientBudget,
        #[serde(rename = "insufficientNamedBudget")]
        InsufficientNamedBudget,
        #[serde(rename = "noMatchingSourceFilterData")]
        NoMatchingSourceFilterData,
        #[serde(rename = "notRegistered")]
        NotRegistered,
        #[serde(rename = "prohibitedByBrowserPolicy")]
        ProhibitedByBrowserPolicy,
        #[serde(rename = "deduplicated")]
        Deduplicated,
        #[serde(rename = "reportWindowPassed")]
        ReportWindowPassed,
        #[serde(rename = "excessiveReports")]
        ExcessiveReports,
    }
    impl From<&str> for AttributionReportingAggregatableResult {
        fn from(s: &str) -> Self {
            match s {
                "success" => Self::Success,
                "internalError" => Self::InternalError,
                "noCapacityForAttributionDestination" => Self::NoCapacityForAttributionDestination,
                "noMatchingSources" => Self::NoMatchingSources,
                "excessiveAttributions" => Self::ExcessiveAttributions,
                "excessiveReportingOrigins" => Self::ExcessiveReportingOrigins,
                "noHistograms" => Self::NoHistograms,
                "insufficientBudget" => Self::InsufficientBudget,
                "insufficientNamedBudget" => Self::InsufficientNamedBudget,
                "noMatchingSourceFilterData" => Self::NoMatchingSourceFilterData,
                "notRegistered" => Self::NotRegistered,
                "prohibitedByBrowserPolicy" => Self::ProhibitedByBrowserPolicy,
                "deduplicated" => Self::Deduplicated,
                "reportWindowPassed" => Self::ReportWindowPassed,
                "excessiveReports" => Self::ExcessiveReports,
                _ => Self::Success,
            }
        }
    }
    impl From<String> for AttributionReportingAggregatableResult {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AttributionReportingReportResult {
        #[serde(rename = "sent")]
        Sent,
        #[serde(rename = "prohibited")]
        Prohibited,
        #[serde(rename = "failedToAssemble")]
        FailedToAssemble,
        #[serde(rename = "expired")]
        Expired,
    }
    impl From<&str> for AttributionReportingReportResult {
        fn from(s: &str) -> Self {
            match s {
                "sent" => Self::Sent,
                "prohibited" => Self::Prohibited,
                "failedToAssemble" => Self::FailedToAssemble,
                "expired" => Self::Expired,
                _ => Self::Sent,
            }
        }
    }
    impl From<String> for AttributionReportingReportResult {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// A single Related Website Set object.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RelatedWebsiteSet {
        /// The primary site of this set, along with the ccTLDs if there is any.
        #[serde(rename = "primarySites")]
        pub primary_sites: Vec<String>,
        /// The associated sites of this set, along with the ccTLDs if there is any.
        #[serde(rename = "associatedSites")]
        pub associated_sites: Vec<String>,
        /// The service sites of this set, along with the ccTLDs if there is any.
        #[serde(rename = "serviceSites")]
        pub service_sites: Vec<String>,
    }

    /// Returns a storage key given a frame id. Deprecated. Please use Storage.getStorageKey instead.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageKeyForFrame {
        #[serde(rename = "frameId")]
        frame_id: page::FrameId,
    }

    impl GetStorageKeyForFrame {
        pub fn new(frame_id: impl Into<page::FrameId>) -> Self {
            Self {
                frame_id: frame_id.into(),
            }
        }
    }

    impl Command for GetStorageKeyForFrame {
        type Response = GetStorageKeyForFrameResult;
        const METHOD: &'static str = "Storage.getStorageKeyForFrame";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageKeyForFrameResult {
        #[serde(rename = "storageKey")]
        pub storage_key: SerializedStorageKey,
    }

    /// Returns storage key for the given frame. If no frame ID is provided, the storage key of the target executing this command is returned.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageKey {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "frameId")]
        frame_id: Option<page::FrameId>,
    }

    impl GetStorageKey {
        pub fn new() -> Self {
            Self { frame_id: None }
        }

        pub fn with_frame_id(mut self, frame_id: impl Into<page::FrameId>) -> Self {
            self.frame_id = Some(frame_id.into());
            self
        }
    }

    impl Command for GetStorageKey {
        type Response = GetStorageKeyResult;
        const METHOD: &'static str = "Storage.getStorageKey";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStorageKeyResult {
        #[serde(rename = "storageKey")]
        pub storage_key: SerializedStorageKey,
    }

    /// Clears storage for origin.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDataForOrigin {
        /// Security origin.
        origin: String,
        /// Comma separated list of StorageType to clear.
        #[serde(rename = "storageTypes")]
        storage_types: String,
    }

    impl ClearDataForOrigin {
        pub fn new(origin: impl Into<String>, storage_types: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
                storage_types: storage_types.into(),
            }
        }
    }

    impl Command for ClearDataForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.clearDataForOrigin";
    }

    /// Clears storage for storage key.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearDataForStorageKey {
        /// Storage key.
        #[serde(rename = "storageKey")]
        storage_key: String,
        /// Comma separated list of StorageType to clear.
        #[serde(rename = "storageTypes")]
        storage_types: String,
    }

    impl ClearDataForStorageKey {
        pub fn new(storage_key: impl Into<String>, storage_types: impl Into<String>) -> Self {
            Self {
                storage_key: storage_key.into(),
                storage_types: storage_types.into(),
            }
        }
    }

    impl Command for ClearDataForStorageKey {
        type Response = ();
        const METHOD: &'static str = "Storage.clearDataForStorageKey";
    }

    /// Returns all browser cookies.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCookies {
        /// Browser context to use when called on the browser endpoint.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<browser::BrowserContextID>,
    }

    impl GetCookies {
        pub fn new() -> Self {
            Self {
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<browser::BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for GetCookies {
        type Response = GetCookiesResult;
        const METHOD: &'static str = "Storage.getCookies";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCookiesResult {
        /// Array of cookie objects.
        pub cookies: Vec<network::Cookie>,
    }

    /// Sets given cookies.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCookies {
        /// Cookies to be set.
        cookies: Vec<network::CookieParam>,
        /// Browser context to use when called on the browser endpoint.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<browser::BrowserContextID>,
    }

    impl SetCookies {
        pub fn new(cookies: impl Into<Vec<network::CookieParam>>) -> Self {
            Self {
                cookies: cookies.into(),
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<browser::BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for SetCookies {
        type Response = ();
        const METHOD: &'static str = "Storage.setCookies";
    }

    /// Clears cookies.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearCookies {
        /// Browser context to use when called on the browser endpoint.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<browser::BrowserContextID>,
    }

    impl ClearCookies {
        pub fn new() -> Self {
            Self {
                browser_context_id: None,
            }
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<browser::BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }
    }

    impl Command for ClearCookies {
        type Response = ();
        const METHOD: &'static str = "Storage.clearCookies";
    }

    /// Returns usage and quota in bytes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetUsageAndQuota {
        /// Security origin.
        origin: String,
    }

    impl GetUsageAndQuota {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for GetUsageAndQuota {
        type Response = GetUsageAndQuotaResult;
        const METHOD: &'static str = "Storage.getUsageAndQuota";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetUsageAndQuotaResult {
        /// Storage usage (bytes).
        pub usage: f64,
        /// Storage quota (bytes).
        pub quota: f64,
        /// Whether or not the origin has an active storage quota override
        #[serde(rename = "overrideActive")]
        pub override_active: bool,
        /// Storage usage per type (bytes).
        #[serde(rename = "usageBreakdown")]
        pub usage_breakdown: Vec<UsageForType>,
    }

    /// Override quota for the specified origin
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OverrideQuotaForOrigin {
        /// Security origin.
        origin: String,
        /// The quota size (in bytes) to override the original quota with. If this is called multiple times, the overridden quota will be equal to the quotaSize provided in the final call. If this is called without specifying a quotaSize, the quota will be reset to the default value for the specified origin. If this is called multiple times with different origins, the override will be maintained for each origin until it is disabled (called without a quotaSize).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "quotaSize")]
        quota_size: Option<f64>,
    }

    impl OverrideQuotaForOrigin {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
                quota_size: None,
            }
        }

        pub fn with_quota_size(mut self, quota_size: impl Into<f64>) -> Self {
            self.quota_size = Some(quota_size.into());
            self
        }
    }

    impl Command for OverrideQuotaForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.overrideQuotaForOrigin";
    }

    /// Registers origin to be notified when an update occurs to its cache storage list.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackCacheStorageForOrigin {
        /// Security origin.
        origin: String,
    }

    impl TrackCacheStorageForOrigin {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for TrackCacheStorageForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.trackCacheStorageForOrigin";
    }

    /// Registers storage key to be notified when an update occurs to its cache storage list.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackCacheStorageForStorageKey {
        /// Storage key.
        #[serde(rename = "storageKey")]
        storage_key: String,
    }

    impl TrackCacheStorageForStorageKey {
        pub fn new(storage_key: impl Into<String>) -> Self {
            Self {
                storage_key: storage_key.into(),
            }
        }
    }

    impl Command for TrackCacheStorageForStorageKey {
        type Response = ();
        const METHOD: &'static str = "Storage.trackCacheStorageForStorageKey";
    }

    /// Registers origin to be notified when an update occurs to its IndexedDB.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackIndexedDbForOrigin {
        /// Security origin.
        origin: String,
    }

    impl TrackIndexedDbForOrigin {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for TrackIndexedDbForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.trackIndexedDBForOrigin";
    }

    /// Registers storage key to be notified when an update occurs to its IndexedDB.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TrackIndexedDbForStorageKey {
        /// Storage key.
        #[serde(rename = "storageKey")]
        storage_key: String,
    }

    impl TrackIndexedDbForStorageKey {
        pub fn new(storage_key: impl Into<String>) -> Self {
            Self {
                storage_key: storage_key.into(),
            }
        }
    }

    impl Command for TrackIndexedDbForStorageKey {
        type Response = ();
        const METHOD: &'static str = "Storage.trackIndexedDBForStorageKey";
    }

    /// Unregisters origin from receiving notifications for cache storage.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UntrackCacheStorageForOrigin {
        /// Security origin.
        origin: String,
    }

    impl UntrackCacheStorageForOrigin {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for UntrackCacheStorageForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.untrackCacheStorageForOrigin";
    }

    /// Unregisters storage key from receiving notifications for cache storage.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UntrackCacheStorageForStorageKey {
        /// Storage key.
        #[serde(rename = "storageKey")]
        storage_key: String,
    }

    impl UntrackCacheStorageForStorageKey {
        pub fn new(storage_key: impl Into<String>) -> Self {
            Self {
                storage_key: storage_key.into(),
            }
        }
    }

    impl Command for UntrackCacheStorageForStorageKey {
        type Response = ();
        const METHOD: &'static str = "Storage.untrackCacheStorageForStorageKey";
    }

    /// Unregisters origin from receiving notifications for IndexedDB.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UntrackIndexedDbForOrigin {
        /// Security origin.
        origin: String,
    }

    impl UntrackIndexedDbForOrigin {
        pub fn new(origin: impl Into<String>) -> Self {
            Self {
                origin: origin.into(),
            }
        }
    }

    impl Command for UntrackIndexedDbForOrigin {
        type Response = ();
        const METHOD: &'static str = "Storage.untrackIndexedDBForOrigin";
    }

    /// Unregisters storage key from receiving notifications for IndexedDB.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct UntrackIndexedDbForStorageKey {
        /// Storage key.
        #[serde(rename = "storageKey")]
        storage_key: String,
    }

    impl UntrackIndexedDbForStorageKey {
        pub fn new(storage_key: impl Into<String>) -> Self {
            Self {
                storage_key: storage_key.into(),
            }
        }
    }

    impl Command for UntrackIndexedDbForStorageKey {
        type Response = ();
        const METHOD: &'static str = "Storage.untrackIndexedDBForStorageKey";
    }

    /// Returns the number of stored Trust Tokens per issuer for the current browsing context.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTrustTokens {}

    impl GetTrustTokens {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetTrustTokens {
        type Response = GetTrustTokensResult;
        const METHOD: &'static str = "Storage.getTrustTokens";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTrustTokensResult {
        pub tokens: Vec<TrustTokens>,
    }

    /// Removes all Trust Tokens issued by the provided issuerOrigin. Leaves other stored data, including the issuer's Redemption Records, intact.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearTrustTokens {
        #[serde(rename = "issuerOrigin")]
        issuer_origin: String,
    }

    impl ClearTrustTokens {
        pub fn new(issuer_origin: impl Into<String>) -> Self {
            Self {
                issuer_origin: issuer_origin.into(),
            }
        }
    }

    impl Command for ClearTrustTokens {
        type Response = ClearTrustTokensResult;
        const METHOD: &'static str = "Storage.clearTrustTokens";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearTrustTokensResult {
        /// True if any tokens were deleted, false otherwise.
        #[serde(rename = "didDeleteTokens")]
        pub did_delete_tokens: bool,
    }

    /// Gets details for a named interest group.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInterestGroupDetails {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
        name: String,
    }

    impl GetInterestGroupDetails {
        pub fn new(owner_origin: impl Into<String>, name: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
                name: name.into(),
            }
        }
    }

    impl Command for GetInterestGroupDetails {
        type Response = GetInterestGroupDetailsResult;
        const METHOD: &'static str = "Storage.getInterestGroupDetails";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInterestGroupDetailsResult {
        /// This largely corresponds to: https://wicg.github.io/turtledove/#dictdef-generatebidinterestgroup but has absolute expirationTime instead of relative lifetimeMs and also adds joiningOrigin.
        pub details: serde_json::Value,
    }

    /// Enables/Disables issuing of interestGroupAccessed events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInterestGroupTracking {
        enable: bool,
    }

    impl SetInterestGroupTracking {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for SetInterestGroupTracking {
        type Response = ();
        const METHOD: &'static str = "Storage.setInterestGroupTracking";
    }

    /// Enables/Disables issuing of interestGroupAuctionEventOccurred and interestGroupAuctionNetworkRequestCreated.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInterestGroupAuctionTracking {
        enable: bool,
    }

    impl SetInterestGroupAuctionTracking {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for SetInterestGroupAuctionTracking {
        type Response = ();
        const METHOD: &'static str = "Storage.setInterestGroupAuctionTracking";
    }

    /// Gets metadata for an origin's shared storage.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSharedStorageMetadata {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
    }

    impl GetSharedStorageMetadata {
        pub fn new(owner_origin: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
            }
        }
    }

    impl Command for GetSharedStorageMetadata {
        type Response = GetSharedStorageMetadataResult;
        const METHOD: &'static str = "Storage.getSharedStorageMetadata";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSharedStorageMetadataResult {
        pub metadata: SharedStorageMetadata,
    }

    /// Gets the entries in an given origin's shared storage.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSharedStorageEntries {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
    }

    impl GetSharedStorageEntries {
        pub fn new(owner_origin: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
            }
        }
    }

    impl Command for GetSharedStorageEntries {
        type Response = GetSharedStorageEntriesResult;
        const METHOD: &'static str = "Storage.getSharedStorageEntries";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSharedStorageEntriesResult {
        pub entries: Vec<SharedStorageEntry>,
    }

    /// Sets entry with `key` and `value` for a given origin's shared storage.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSharedStorageEntry {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
        key: String,
        value: String,
        /// If `ignoreIfPresent` is included and true, then only sets the entry if `key` doesn't already exist.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ignoreIfPresent")]
        ignore_if_present: Option<bool>,
    }

    impl SetSharedStorageEntry {
        pub fn new(
            owner_origin: impl Into<String>,
            key: impl Into<String>,
            value: impl Into<String>,
        ) -> Self {
            Self {
                owner_origin: owner_origin.into(),
                key: key.into(),
                value: value.into(),
                ignore_if_present: None,
            }
        }

        pub fn with_ignore_if_present(mut self, ignore_if_present: impl Into<bool>) -> Self {
            self.ignore_if_present = Some(ignore_if_present.into());
            self
        }
    }

    impl Command for SetSharedStorageEntry {
        type Response = ();
        const METHOD: &'static str = "Storage.setSharedStorageEntry";
    }

    /// Deletes entry for `key` (if it exists) for a given origin's shared storage.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteSharedStorageEntry {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
        key: String,
    }

    impl DeleteSharedStorageEntry {
        pub fn new(owner_origin: impl Into<String>, key: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
                key: key.into(),
            }
        }
    }

    impl Command for DeleteSharedStorageEntry {
        type Response = ();
        const METHOD: &'static str = "Storage.deleteSharedStorageEntry";
    }

    /// Clears all entries for a given origin's shared storage.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearSharedStorageEntries {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
    }

    impl ClearSharedStorageEntries {
        pub fn new(owner_origin: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
            }
        }
    }

    impl Command for ClearSharedStorageEntries {
        type Response = ();
        const METHOD: &'static str = "Storage.clearSharedStorageEntries";
    }

    /// Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetSharedStorageBudget {
        #[serde(rename = "ownerOrigin")]
        owner_origin: String,
    }

    impl ResetSharedStorageBudget {
        pub fn new(owner_origin: impl Into<String>) -> Self {
            Self {
                owner_origin: owner_origin.into(),
            }
        }
    }

    impl Command for ResetSharedStorageBudget {
        type Response = ();
        const METHOD: &'static str = "Storage.resetSharedStorageBudget";
    }

    /// Enables/disables issuing of sharedStorageAccessed events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSharedStorageTracking {
        enable: bool,
    }

    impl SetSharedStorageTracking {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for SetSharedStorageTracking {
        type Response = ();
        const METHOD: &'static str = "Storage.setSharedStorageTracking";
    }

    /// Set tracking for a storage key's buckets.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetStorageBucketTracking {
        #[serde(rename = "storageKey")]
        storage_key: String,
        enable: bool,
    }

    impl SetStorageBucketTracking {
        pub fn new(storage_key: impl Into<String>, enable: impl Into<bool>) -> Self {
            Self {
                storage_key: storage_key.into(),
                enable: enable.into(),
            }
        }
    }

    impl Command for SetStorageBucketTracking {
        type Response = ();
        const METHOD: &'static str = "Storage.setStorageBucketTracking";
    }

    /// Deletes the Storage Bucket with the given storage key and bucket name.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeleteStorageBucket {
        bucket: StorageBucket,
    }

    impl DeleteStorageBucket {
        pub fn new(bucket: impl Into<StorageBucket>) -> Self {
            Self {
                bucket: bucket.into(),
            }
        }
    }

    impl Command for DeleteStorageBucket {
        type Response = ();
        const METHOD: &'static str = "Storage.deleteStorageBucket";
    }

    /// Deletes state for sites identified as potential bounce trackers, immediately.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RunBounceTrackingMitigations {}

    impl RunBounceTrackingMitigations {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for RunBounceTrackingMitigations {
        type Response = RunBounceTrackingMitigationsResult;
        const METHOD: &'static str = "Storage.runBounceTrackingMitigations";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RunBounceTrackingMitigationsResult {
        #[serde(rename = "deletedSites")]
        pub deleted_sites: Vec<String>,
    }

    /// https://wicg.github.io/attribution-reporting-api/
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttributionReportingLocalTestingMode {
        /// If enabled, noise is suppressed and reports are sent immediately.
        enabled: bool,
    }

    impl SetAttributionReportingLocalTestingMode {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetAttributionReportingLocalTestingMode {
        type Response = ();
        const METHOD: &'static str = "Storage.setAttributionReportingLocalTestingMode";
    }

    /// Enables/disables issuing of Attribution Reporting events.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAttributionReportingTracking {
        enable: bool,
    }

    impl SetAttributionReportingTracking {
        pub fn new(enable: impl Into<bool>) -> Self {
            Self {
                enable: enable.into(),
            }
        }
    }

    impl Command for SetAttributionReportingTracking {
        type Response = ();
        const METHOD: &'static str = "Storage.setAttributionReportingTracking";
    }

    /// Sends all pending Attribution Reports immediately, regardless of their scheduled report time.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SendPendingAttributionReports {}

    impl SendPendingAttributionReports {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for SendPendingAttributionReports {
        type Response = SendPendingAttributionReportsResult;
        const METHOD: &'static str = "Storage.sendPendingAttributionReports";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SendPendingAttributionReportsResult {
        /// The number of reports that were sent.
        #[serde(rename = "numSent")]
        pub num_sent: i64,
    }

    /// Returns the effective Related Website Sets in use by this profile for the browser session. The effective Related Website Sets will not change during a browser session.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRelatedWebsiteSets {}

    impl GetRelatedWebsiteSets {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetRelatedWebsiteSets {
        type Response = GetRelatedWebsiteSetsResult;
        const METHOD: &'static str = "Storage.getRelatedWebsiteSets";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRelatedWebsiteSetsResult {
        pub sets: Vec<RelatedWebsiteSet>,
    }

    /// Returns the list of URLs from a page and its embedded resources that match existing grace period URL pattern rules. https://developers.google.com/privacy-sandbox/cookies/temporary-exceptions/grace-period
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAffectedUrlsForThirdPartyCookieMetadata {
        /// The URL of the page currently being visited.
        #[serde(rename = "firstPartyUrl")]
        first_party_url: String,
        /// The list of embedded resource URLs from the page.
        #[serde(rename = "thirdPartyUrls")]
        third_party_urls: Vec<String>,
    }

    impl GetAffectedUrlsForThirdPartyCookieMetadata {
        pub fn new(
            first_party_url: impl Into<String>,
            third_party_urls: impl Into<Vec<String>>,
        ) -> Self {
            Self {
                first_party_url: first_party_url.into(),
                third_party_urls: third_party_urls.into(),
            }
        }
    }

    impl Command for GetAffectedUrlsForThirdPartyCookieMetadata {
        type Response = GetAffectedUrlsForThirdPartyCookieMetadataResult;
        const METHOD: &'static str = "Storage.getAffectedUrlsForThirdPartyCookieMetadata";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetAffectedUrlsForThirdPartyCookieMetadataResult {
        /// Array of matching URLs. If there is a primary pattern match for the first- party URL, only the first-party URL is returned in the array.
        #[serde(rename = "matchedUrls")]
        pub matched_urls: Vec<String>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetProtectedAudienceKAnonymity {
        owner: String,
        name: String,
        hashes: Vec<String>,
    }

    impl SetProtectedAudienceKAnonymity {
        pub fn new(
            owner: impl Into<String>,
            name: impl Into<String>,
            hashes: impl Into<Vec<String>>,
        ) -> Self {
            Self {
                owner: owner.into(),
                name: name.into(),
                hashes: hashes.into(),
            }
        }
    }

    impl Command for SetProtectedAudienceKAnonymity {
        type Response = ();
        const METHOD: &'static str = "Storage.setProtectedAudienceKAnonymity";
    }

    /// A cache's contents have been modified.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CacheStorageContentUpdated {
        /// Origin to update.
        pub origin: String,
        /// Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        /// Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
        /// Name of cache in origin.
        #[serde(rename = "cacheName")]
        pub cache_name: String,
    }

    impl CacheStorageContentUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.cacheStorageContentUpdated")
        }
    }

    /// A cache has been added/deleted.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CacheStorageListUpdated {
        /// Origin to update.
        pub origin: String,
        /// Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        /// Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }

    impl CacheStorageListUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.cacheStorageListUpdated")
        }
    }

    /// The origin's IndexedDB object store has been modified.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IndexedDbContentUpdated {
        /// Origin to update.
        pub origin: String,
        /// Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        /// Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
        /// Database to update.
        #[serde(rename = "databaseName")]
        pub database_name: String,
        /// ObjectStore to update.
        #[serde(rename = "objectStoreName")]
        pub object_store_name: String,
    }

    impl IndexedDbContentUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.indexedDBContentUpdated")
        }
    }

    /// The origin's IndexedDB database list has been modified.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct IndexedDbListUpdated {
        /// Origin to update.
        pub origin: String,
        /// Storage key to update.
        #[serde(rename = "storageKey")]
        pub storage_key: String,
        /// Storage bucket to update.
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }

    impl IndexedDbListUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.indexedDBListUpdated")
        }
    }

    /// One of the interest groups was accessed. Note that these events are global to all targets sharing an interest group store.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InterestGroupAccessed {
        #[serde(rename = "accessTime")]
        pub access_time: network::TimeSinceEpoch,
        #[serde(rename = "type")]
        pub type_: InterestGroupAccessType,
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        pub name: String,
        /// For topLevelBid/topLevelAdditionalBid, and when appropriate, win and additionalBidWin
        #[serde(rename = "componentSellerOrigin")]
        pub component_seller_origin: Option<String>,
        /// For bid or somethingBid event, if done locally and not on a server.
        pub bid: Option<f64>,
        #[serde(rename = "bidCurrency")]
        pub bid_currency: Option<String>,
        /// For non-global events --- links to interestGroupAuctionEvent
        #[serde(rename = "uniqueAuctionId")]
        pub unique_auction_id: Option<InterestGroupAuctionId>,
    }

    impl InterestGroupAccessed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.interestGroupAccessed")
        }
    }

    /// An auction involving interest groups is taking place. These events are target-specific.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InterestGroupAuctionEventOccurred {
        #[serde(rename = "eventTime")]
        pub event_time: network::TimeSinceEpoch,
        #[serde(rename = "type")]
        pub type_: InterestGroupAuctionEventType,
        #[serde(rename = "uniqueAuctionId")]
        pub unique_auction_id: InterestGroupAuctionId,
        /// Set for child auctions.
        #[serde(rename = "parentAuctionId")]
        pub parent_auction_id: Option<InterestGroupAuctionId>,
        /// Set for started and configResolved
        #[serde(rename = "auctionConfig")]
        pub auction_config: Option<serde_json::Value>,
    }

    impl InterestGroupAuctionEventOccurred {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.interestGroupAuctionEventOccurred")
        }
    }

    /// Specifies which auctions a particular network fetch may be related to, and in what role. Note that it is not ordered with respect to Network.requestWillBeSent (but will happen before loadingFinished loadingFailed).
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InterestGroupAuctionNetworkRequestCreated {
        #[serde(rename = "type")]
        pub type_: InterestGroupAuctionFetchType,
        #[serde(rename = "requestId")]
        pub request_id: network::RequestId,
        /// This is the set of the auctions using the worklet that issued this request. In the case of trusted signals, it's possible that only some of them actually care about the keys being queried.
        pub auctions: Vec<InterestGroupAuctionId>,
    }

    impl InterestGroupAuctionNetworkRequestCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.interestGroupAuctionNetworkRequestCreated")
        }
    }

    /// Shared storage was accessed by the associated page. The following parameters are included in all events.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageAccessed {
        /// Time of the access.
        #[serde(rename = "accessTime")]
        pub access_time: network::TimeSinceEpoch,
        /// Enum value indicating the access scope.
        pub scope: SharedStorageAccessScope,
        /// Enum value indicating the Shared Storage API method invoked.
        pub method: SharedStorageAccessMethod,
        /// DevTools Frame Token for the primary frame tree's root.
        #[serde(rename = "mainFrameId")]
        pub main_frame_id: page::FrameId,
        /// Serialization of the origin owning the Shared Storage data.
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
        /// Serialization of the site owning the Shared Storage data.
        #[serde(rename = "ownerSite")]
        pub owner_site: String,
        /// The sub-parameters wrapped by `params` are all optional and their presence/absence depends on `type`.
        pub params: SharedStorageAccessParams,
    }

    impl SharedStorageAccessed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.sharedStorageAccessed")
        }
    }

    /// A shared storage run or selectURL operation finished its execution. The following parameters are included in all events.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SharedStorageWorkletOperationExecutionFinished {
        /// Time that the operation finished.
        #[serde(rename = "finishedTime")]
        pub finished_time: network::TimeSinceEpoch,
        /// Time, in microseconds, from start of shared storage JS API call until end of operation execution in the worklet.
        #[serde(rename = "executionTime")]
        pub execution_time: i64,
        /// Enum value indicating the Shared Storage API method invoked.
        pub method: SharedStorageAccessMethod,
        /// ID of the operation call.
        #[serde(rename = "operationId")]
        pub operation_id: String,
        /// Hex representation of the DevTools token used as the TargetID for the associated shared storage worklet.
        #[serde(rename = "workletTargetId")]
        pub worklet_target_id: target::TargetID,
        /// DevTools Frame Token for the primary frame tree's root.
        #[serde(rename = "mainFrameId")]
        pub main_frame_id: page::FrameId,
        /// Serialization of the origin owning the Shared Storage data.
        #[serde(rename = "ownerOrigin")]
        pub owner_origin: String,
    }

    impl SharedStorageWorkletOperationExecutionFinished {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.sharedStorageWorkletOperationExecutionFinished")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StorageBucketCreatedOrUpdated {
        #[serde(rename = "bucketInfo")]
        pub bucket_info: StorageBucketInfo,
    }

    impl StorageBucketCreatedOrUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.storageBucketCreatedOrUpdated")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StorageBucketDeleted {
        #[serde(rename = "bucketId")]
        pub bucket_id: String,
    }

    impl StorageBucketDeleted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Storage.storageBucketDeleted")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingSourceRegistered {
        pub registration: AttributionReportingSourceRegistration,
        pub result: AttributionReportingSourceRegistrationResult,
    }

    impl AttributionReportingSourceRegistered {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.attributionReportingSourceRegistered")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingTriggerRegistered {
        pub registration: AttributionReportingTriggerRegistration,
        #[serde(rename = "eventLevel")]
        pub event_level: AttributionReportingEventLevelResult,
        pub aggregatable: AttributionReportingAggregatableResult,
    }

    impl AttributionReportingTriggerRegistered {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.attributionReportingTriggerRegistered")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingReportSent {
        pub url: String,
        pub body: serde_json::Value,
        pub result: AttributionReportingReportResult,
        /// If result is `sent`, populated with net/HTTP status.
        #[serde(rename = "netError")]
        pub net_error: Option<i64>,
        #[serde(rename = "netErrorName")]
        pub net_error_name: Option<String>,
        #[serde(rename = "httpStatusCode")]
        pub http_status_code: Option<i64>,
    }

    impl AttributionReportingReportSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.attributionReportingReportSent")
        }
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttributionReportingVerboseDebugReportSent {
        pub url: String,
        pub body: Option<Vec<serde_json::Value>>,
        #[serde(rename = "netError")]
        pub net_error: Option<i64>,
        #[serde(rename = "netErrorName")]
        pub net_error_name: Option<String>,
        #[serde(rename = "httpStatusCode")]
        pub http_status_code: Option<i64>,
    }

    impl AttributionReportingVerboseDebugReportSent {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Storage.attributionReportingVerboseDebugReportSent")
        }
    }
}

pub mod system_info {
    use super::*;

    /// Describes a single graphics processor (GPU).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GPUDevice {
        /// PCI ID of the GPU vendor, if available; 0 otherwise.
        #[serde(rename = "vendorId")]
        pub vendor_id: f64,
        /// PCI ID of the GPU device, if available; 0 otherwise.
        #[serde(rename = "deviceId")]
        pub device_id: f64,
        /// Sub sys ID of the GPU, only available on Windows.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "subSysId")]
        pub sub_sys_id: Option<f64>,
        /// Revision of the GPU, only available on Windows.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub revision: Option<f64>,
        /// String description of the GPU vendor, if the PCI ID is not available.
        #[serde(rename = "vendorString")]
        pub vendor_string: String,
        /// String description of the GPU device, if the PCI ID is not available.
        #[serde(rename = "deviceString")]
        pub device_string: String,
        /// String description of the GPU driver vendor.
        #[serde(rename = "driverVendor")]
        pub driver_vendor: String,
        /// String description of the GPU driver version.
        #[serde(rename = "driverVersion")]
        pub driver_version: String,
    }

    /// Describes the width and height dimensions of an entity.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Size {
        /// Width in pixels.
        pub width: i64,
        /// Height in pixels.
        pub height: i64,
    }

    /// Describes a supported video decoding profile with its associated minimum and maximum resolutions.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VideoDecodeAcceleratorCapability {
        /// Video codec profile that is supported, e.g. VP9 Profile 2.
        pub profile: String,
        /// Maximum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "maxResolution")]
        pub max_resolution: Size,
        /// Minimum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "minResolution")]
        pub min_resolution: Size,
    }

    /// Describes a supported video encoding profile with its associated maximum resolution and maximum framerate.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VideoEncodeAcceleratorCapability {
        /// Video codec profile that is supported, e.g H264 Main.
        pub profile: String,
        /// Maximum video dimensions in pixels supported for this |profile|.
        #[serde(rename = "maxResolution")]
        pub max_resolution: Size,
        /// Maximum encoding framerate in frames per second supported for this |profile|, as fraction's numerator and denominator, e.g. 24/1 fps, 24000/1001 fps, etc.
        #[serde(rename = "maxFramerateNumerator")]
        pub max_framerate_numerator: i64,
        #[serde(rename = "maxFramerateDenominator")]
        pub max_framerate_denominator: i64,
    }

    /// YUV subsampling type of the pixels of a given image.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum SubsamplingFormat {
        #[serde(rename = "yuv420")]
        Yuv420,
        #[serde(rename = "yuv422")]
        Yuv422,
        #[serde(rename = "yuv444")]
        Yuv444,
    }
    impl From<&str> for SubsamplingFormat {
        fn from(s: &str) -> Self {
            match s {
                "yuv420" => Self::Yuv420,
                "yuv422" => Self::Yuv422,
                "yuv444" => Self::Yuv444,
                _ => Self::Yuv420,
            }
        }
    }
    impl From<String> for SubsamplingFormat {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Image format of a given image.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ImageType {
        #[serde(rename = "jpeg")]
        Jpeg,
        #[serde(rename = "webp")]
        Webp,
        #[serde(rename = "unknown")]
        Unknown,
    }
    impl From<&str> for ImageType {
        fn from(s: &str) -> Self {
            match s {
                "jpeg" => Self::Jpeg,
                "webp" => Self::Webp,
                "unknown" => Self::Unknown,
                _ => Self::Jpeg,
            }
        }
    }
    impl From<String> for ImageType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Provides information about the GPU(s) on the system.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GPUInfo {
        /// The graphics devices on the system. Element 0 is the primary GPU.
        pub devices: Vec<GPUDevice>,
        /// An optional dictionary of additional GPU related attributes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "auxAttributes")]
        pub aux_attributes: Option<serde_json::Value>,
        /// An optional dictionary of graphics features and their status.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "featureStatus")]
        pub feature_status: Option<serde_json::Value>,
        /// An optional array of GPU driver bug workarounds.
        #[serde(rename = "driverBugWorkarounds")]
        pub driver_bug_workarounds: Vec<String>,
        /// Supported accelerated video decoding capabilities.
        #[serde(rename = "videoDecoding")]
        pub video_decoding: Vec<VideoDecodeAcceleratorCapability>,
        /// Supported accelerated video encoding capabilities.
        #[serde(rename = "videoEncoding")]
        pub video_encoding: Vec<VideoEncodeAcceleratorCapability>,
    }

    /// Represents process info.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProcessInfo {
        /// Specifies process type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Specifies process id.
        pub id: i64,
        /// Specifies cumulative CPU usage in seconds across all threads of the process since the process start.
        #[serde(rename = "cpuTime")]
        pub cpu_time: f64,
    }

    /// Returns information about the system.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInfo {}

    impl GetInfo {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetInfo {
        type Response = GetInfoResult;
        const METHOD: &'static str = "SystemInfo.getInfo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetInfoResult {
        /// Information about the GPUs on the system.
        pub gpu: GPUInfo,
        /// A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported.
        #[serde(rename = "modelName")]
        pub model_name: String,
        /// A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported.
        #[serde(rename = "modelVersion")]
        pub model_version: String,
        /// The command line string used to launch the browser. Will be the empty string if not supported.
        #[serde(rename = "commandLine")]
        pub command_line: String,
    }

    /// Returns information about the feature state.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFeatureState {
        #[serde(rename = "featureState")]
        feature_state: String,
    }

    impl GetFeatureState {
        pub fn new(feature_state: impl Into<String>) -> Self {
            Self {
                feature_state: feature_state.into(),
            }
        }
    }

    impl Command for GetFeatureState {
        type Response = GetFeatureStateResult;
        const METHOD: &'static str = "SystemInfo.getFeatureState";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetFeatureStateResult {
        #[serde(rename = "featureEnabled")]
        pub feature_enabled: bool,
    }

    /// Returns information about all running processes.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetProcessInfo {}

    impl GetProcessInfo {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetProcessInfo {
        type Response = GetProcessInfoResult;
        const METHOD: &'static str = "SystemInfo.getProcessInfo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetProcessInfoResult {
        /// An array of process info blocks.
        #[serde(rename = "processInfo")]
        pub process_info: Vec<ProcessInfo>,
    }
}

pub mod target {
    use super::*;

    pub type TargetID = String;

    /// Unique identifier of attached debugging session.
    pub type SessionID = String;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetInfo {
        #[serde(rename = "targetId")]
        pub target_id: TargetID,
        /// List of types: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/devtools_agent_host_impl.cc?ss=chromium&q=f:devtools%20-f:out%20%22::kTypeTab%5B%5D%22
        #[serde(rename = "type")]
        pub type_: String,
        pub title: String,
        pub url: String,
        /// Whether the target has an attached client.
        pub attached: bool,
        /// Opener target Id
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "openerId")]
        pub opener_id: Option<TargetID>,
        /// Whether the target has access to the originating window.
        /// **EXPERIMENTAL**
        #[serde(rename = "canAccessOpener")]
        pub can_access_opener: bool,
        /// Frame id of originating window (is only set if target has an opener).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "openerFrameId")]
        pub opener_frame_id: Option<page::FrameId>,
        /// Id of the parent frame, only present for the "iframe" targets.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentFrameId")]
        pub parent_frame_id: Option<page::FrameId>,
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        pub browser_context_id: Option<browser::BrowserContextID>,
        /// Provides additional details for specific target types. For example, for the type of "page", this may be set to "prerender".
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub subtype: Option<String>,
    }

    /// A filter used by target query/discovery/auto-attach operations.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FilterEntry {
        /// If set, causes exclusion of matching targets from the list.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub exclude: Option<bool>,
        /// If not present, matches any type.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "type")]
        pub type_: Option<String>,
    }

    /// The entries in TargetFilter are matched sequentially against targets and the first entry that matches determines if the target is included or not, depending on the value of `exclude` field in the entry. If filter is not specified, the one assumed is [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}] (i.e. include everything but `browser` and `tab`).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type TargetFilter = Vec<FilterEntry>;

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoteLocation {
        pub host: String,
        pub port: i64,
    }

    /// The state of the target window.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum WindowState {
        #[serde(rename = "normal")]
        Normal,
        #[serde(rename = "minimized")]
        Minimized,
        #[serde(rename = "maximized")]
        Maximized,
        #[serde(rename = "fullscreen")]
        Fullscreen,
    }
    impl From<&str> for WindowState {
        fn from(s: &str) -> Self {
            match s {
                "normal" => Self::Normal,
                "minimized" => Self::Minimized,
                "maximized" => Self::Maximized,
                "fullscreen" => Self::Fullscreen,
                _ => Self::Normal,
            }
        }
    }
    impl From<String> for WindowState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Activates (focuses) the target.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ActivateTarget {
        #[serde(rename = "targetId")]
        target_id: TargetID,
    }

    impl ActivateTarget {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
            }
        }
    }

    impl Command for ActivateTarget {
        type Response = ();
        const METHOD: &'static str = "Target.activateTarget";
    }

    /// Attaches to the target with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttachToTarget {
        #[serde(rename = "targetId")]
        target_id: TargetID,
        /// Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
        #[serde(skip_serializing_if = "Option::is_none")]
        flatten: Option<bool>,
    }

    impl AttachToTarget {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
                flatten: None,
            }
        }

        pub fn with_flatten(mut self, flatten: impl Into<bool>) -> Self {
            self.flatten = Some(flatten.into());
            self
        }
    }

    impl Command for AttachToTarget {
        type Response = AttachToTargetResult;
        const METHOD: &'static str = "Target.attachToTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttachToTargetResult {
        /// Id assigned to the session.
        #[serde(rename = "sessionId")]
        pub session_id: SessionID,
    }

    /// Attaches to the browser target, only uses flat sessionId mode.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttachToBrowserTarget {}

    impl AttachToBrowserTarget {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for AttachToBrowserTarget {
        type Response = AttachToBrowserTargetResult;
        const METHOD: &'static str = "Target.attachToBrowserTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttachToBrowserTargetResult {
        /// Id assigned to the session.
        #[serde(rename = "sessionId")]
        pub session_id: SessionID,
    }

    /// Closes the target. If the target is a page that gets closed too.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CloseTarget {
        #[serde(rename = "targetId")]
        target_id: TargetID,
    }

    impl CloseTarget {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
            }
        }
    }

    impl Command for CloseTarget {
        type Response = CloseTargetResult;
        const METHOD: &'static str = "Target.closeTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CloseTargetResult {
        /// Always set to true. If an error occurs, the response indicates protocol error.
        #[deprecated]
        pub success: bool,
    }

    /// Inject object to the target's main frame that provides a communication channel with browser target. Injected object will be available as `window[bindingName]`. The object has the following API: - `binding.send(json)` - a method to send messages over the remote debugging protocol - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExposeDevToolsProtocol {
        #[serde(rename = "targetId")]
        target_id: TargetID,
        /// Binding name, 'cdp' if not specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bindingName")]
        binding_name: Option<String>,
        /// If true, inherits the current root session's permissions (default: false).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "inheritPermissions")]
        inherit_permissions: Option<bool>,
    }

    impl ExposeDevToolsProtocol {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
                binding_name: None,
                inherit_permissions: None,
            }
        }

        pub fn with_binding_name(mut self, binding_name: impl Into<String>) -> Self {
            self.binding_name = Some(binding_name.into());
            self
        }

        pub fn with_inherit_permissions(mut self, inherit_permissions: impl Into<bool>) -> Self {
            self.inherit_permissions = Some(inherit_permissions.into());
            self
        }
    }

    impl Command for ExposeDevToolsProtocol {
        type Response = ();
        const METHOD: &'static str = "Target.exposeDevToolsProtocol";
    }

    /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateBrowserContext {
        /// If specified, disposes this context when debugging session disconnects.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "disposeOnDetach")]
        dispose_on_detach: Option<bool>,
        /// Proxy server, similar to the one passed to --proxy-server
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "proxyServer")]
        proxy_server: Option<String>,
        /// Proxy bypass list, similar to the one passed to --proxy-bypass-list
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "proxyBypassList")]
        proxy_bypass_list: Option<String>,
        /// An optional list of origins to grant unlimited cross-origin access to. Parts of the URL other than those constituting origin are ignored.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "originsWithUniversalNetworkAccess")]
        origins_with_universal_network_access: Option<Vec<String>>,
    }

    impl CreateBrowserContext {
        pub fn new() -> Self {
            Self {
                dispose_on_detach: None,
                proxy_server: None,
                proxy_bypass_list: None,
                origins_with_universal_network_access: None,
            }
        }

        pub fn with_dispose_on_detach(mut self, dispose_on_detach: impl Into<bool>) -> Self {
            self.dispose_on_detach = Some(dispose_on_detach.into());
            self
        }

        pub fn with_proxy_server(mut self, proxy_server: impl Into<String>) -> Self {
            self.proxy_server = Some(proxy_server.into());
            self
        }

        pub fn with_proxy_bypass_list(mut self, proxy_bypass_list: impl Into<String>) -> Self {
            self.proxy_bypass_list = Some(proxy_bypass_list.into());
            self
        }

        pub fn with_origins_with_universal_network_access(
            mut self,
            origins_with_universal_network_access: impl Into<Vec<String>>,
        ) -> Self {
            self.origins_with_universal_network_access =
                Some(origins_with_universal_network_access.into());
            self
        }
    }

    impl Command for CreateBrowserContext {
        type Response = CreateBrowserContextResult;
        const METHOD: &'static str = "Target.createBrowserContext";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateBrowserContextResult {
        /// The id of the context created.
        #[serde(rename = "browserContextId")]
        pub browser_context_id: browser::BrowserContextID,
    }

    /// Returns all browser contexts created with `Target.createBrowserContext` method.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserContexts {}

    impl GetBrowserContexts {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetBrowserContexts {
        type Response = GetBrowserContextsResult;
        const METHOD: &'static str = "Target.getBrowserContexts";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBrowserContextsResult {
        /// An array of browser context ids.
        #[serde(rename = "browserContextIds")]
        pub browser_context_ids: Vec<browser::BrowserContextID>,
        /// The id of the default browser context if available.
        /// **EXPERIMENTAL**
        #[serde(rename = "defaultBrowserContextId")]
        pub default_browser_context_id: Option<browser::BrowserContextID>,
    }

    /// Creates a new page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateTarget {
        /// The initial URL the page will be navigated to. An empty string indicates about:blank.
        url: String,
        /// Frame left origin in DIP (requires newWindow to be true or headless shell).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        left: Option<i64>,
        /// Frame top origin in DIP (requires newWindow to be true or headless shell).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        top: Option<i64>,
        /// Frame width in DIP (requires newWindow to be true or headless shell).
        #[serde(skip_serializing_if = "Option::is_none")]
        width: Option<i64>,
        /// Frame height in DIP (requires newWindow to be true or headless shell).
        #[serde(skip_serializing_if = "Option::is_none")]
        height: Option<i64>,
        /// Frame window state (requires newWindow to be true or headless shell). Default is normal.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "windowState")]
        window_state: Option<WindowState>,
        /// The browser context to create the page in.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "browserContextId")]
        browser_context_id: Option<browser::BrowserContextID>,
        /// Whether BeginFrames for this target will be controlled via DevTools (headless shell only, not supported on MacOS yet, false by default).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableBeginFrameControl")]
        enable_begin_frame_control: Option<bool>,
        /// Whether to create a new Window or Tab (false by default, not supported by headless shell).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "newWindow")]
        new_window: Option<bool>,
        /// Whether to create the target in background or foreground (false by default, not supported by headless shell).
        #[serde(skip_serializing_if = "Option::is_none")]
        background: Option<bool>,
        /// Whether to create the target of type "tab".
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "forTab")]
        for_tab: Option<bool>,
        /// Whether to create a hidden target. The hidden target is observable via protocol, but not present in the tab UI strip. Cannot be created with `forTab: true`, `newWindow: true` or `background: false`. The life-time of the tab is limited to the life-time of the session.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        hidden: Option<bool>,
        /// If specified, the option is used to determine if the new target should be focused or not. By default, the focus behavior depends on the value of the background field. For example, background=false and focus=false will result in the target tab being opened but the browser window remain unchanged (if it was in the background, it will remain in the background) and background=false with focus=undefined will result in the window being focused. Using background: true and focus: true is not supported and will result in an error.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        focus: Option<bool>,
    }

    impl CreateTarget {
        pub fn new(url: impl Into<String>) -> Self {
            Self {
                url: url.into(),
                left: None,
                top: None,
                width: None,
                height: None,
                window_state: None,
                browser_context_id: None,
                enable_begin_frame_control: None,
                new_window: None,
                background: None,
                for_tab: None,
                hidden: None,
                focus: None,
            }
        }

        pub fn with_left(mut self, left: impl Into<i64>) -> Self {
            self.left = Some(left.into());
            self
        }

        pub fn with_top(mut self, top: impl Into<i64>) -> Self {
            self.top = Some(top.into());
            self
        }

        pub fn with_width(mut self, width: impl Into<i64>) -> Self {
            self.width = Some(width.into());
            self
        }

        pub fn with_height(mut self, height: impl Into<i64>) -> Self {
            self.height = Some(height.into());
            self
        }

        pub fn with_window_state(mut self, window_state: impl Into<WindowState>) -> Self {
            self.window_state = Some(window_state.into());
            self
        }

        pub fn with_browser_context_id(
            mut self,
            browser_context_id: impl Into<browser::BrowserContextID>,
        ) -> Self {
            self.browser_context_id = Some(browser_context_id.into());
            self
        }

        pub fn with_enable_begin_frame_control(
            mut self,
            enable_begin_frame_control: impl Into<bool>,
        ) -> Self {
            self.enable_begin_frame_control = Some(enable_begin_frame_control.into());
            self
        }

        pub fn with_new_window(mut self, new_window: impl Into<bool>) -> Self {
            self.new_window = Some(new_window.into());
            self
        }

        pub fn with_background(mut self, background: impl Into<bool>) -> Self {
            self.background = Some(background.into());
            self
        }

        pub fn with_for_tab(mut self, for_tab: impl Into<bool>) -> Self {
            self.for_tab = Some(for_tab.into());
            self
        }

        pub fn with_hidden(mut self, hidden: impl Into<bool>) -> Self {
            self.hidden = Some(hidden.into());
            self
        }

        pub fn with_focus(mut self, focus: impl Into<bool>) -> Self {
            self.focus = Some(focus.into());
            self
        }
    }

    impl Command for CreateTarget {
        type Response = CreateTargetResult;
        const METHOD: &'static str = "Target.createTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CreateTargetResult {
        /// The id of the page opened.
        #[serde(rename = "targetId")]
        pub target_id: TargetID,
    }

    /// Detaches session with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DetachFromTarget {
        /// Session to detach.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sessionId")]
        session_id: Option<SessionID>,
        /// Deprecated.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetId")]
        target_id: Option<TargetID>,
    }

    impl DetachFromTarget {
        pub fn new() -> Self {
            Self {
                session_id: None,
                target_id: None,
            }
        }

        pub fn with_session_id(mut self, session_id: impl Into<SessionID>) -> Self {
            self.session_id = Some(session_id.into());
            self
        }

        pub fn with_target_id(mut self, target_id: impl Into<TargetID>) -> Self {
            self.target_id = Some(target_id.into());
            self
        }
    }

    impl Command for DetachFromTarget {
        type Response = ();
        const METHOD: &'static str = "Target.detachFromTarget";
    }

    /// Deletes a BrowserContext. All the belonging pages will be closed without calling their beforeunload hooks.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DisposeBrowserContext {
        #[serde(rename = "browserContextId")]
        browser_context_id: browser::BrowserContextID,
    }

    impl DisposeBrowserContext {
        pub fn new(browser_context_id: impl Into<browser::BrowserContextID>) -> Self {
            Self {
                browser_context_id: browser_context_id.into(),
            }
        }
    }

    impl Command for DisposeBrowserContext {
        type Response = ();
        const METHOD: &'static str = "Target.disposeBrowserContext";
    }

    /// Returns information about a target.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTargetInfo {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetId")]
        target_id: Option<TargetID>,
    }

    impl GetTargetInfo {
        pub fn new() -> Self {
            Self { target_id: None }
        }

        pub fn with_target_id(mut self, target_id: impl Into<TargetID>) -> Self {
            self.target_id = Some(target_id.into());
            self
        }
    }

    impl Command for GetTargetInfo {
        type Response = GetTargetInfoResult;
        const METHOD: &'static str = "Target.getTargetInfo";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTargetInfoResult {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }

    /// Retrieves a list of available targets.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTargets {
        /// Only targets matching filter will be reported. If filter is not specified and target discovery is currently enabled, a filter used for target discovery is used for consistency.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        filter: Option<TargetFilter>,
    }

    impl GetTargets {
        pub fn new() -> Self {
            Self { filter: None }
        }

        pub fn with_filter(mut self, filter: impl Into<TargetFilter>) -> Self {
            self.filter = Some(filter.into());
            self
        }
    }

    impl Command for GetTargets {
        type Response = GetTargetsResult;
        const METHOD: &'static str = "Target.getTargets";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTargetsResult {
        /// The list of targets.
        #[serde(rename = "targetInfos")]
        pub target_infos: Vec<TargetInfo>,
    }

    /// Sends protocol message over session with given id. Consider using flat mode instead; see commands attachToTarget, setAutoAttach, and crbug.com/991325.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SendMessageToTarget {
        message: String,
        /// Identifier of the session.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "sessionId")]
        session_id: Option<SessionID>,
        /// Deprecated.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetId")]
        target_id: Option<TargetID>,
    }

    impl SendMessageToTarget {
        pub fn new(message: impl Into<String>) -> Self {
            Self {
                message: message.into(),
                session_id: None,
                target_id: None,
            }
        }

        pub fn with_session_id(mut self, session_id: impl Into<SessionID>) -> Self {
            self.session_id = Some(session_id.into());
            self
        }

        pub fn with_target_id(mut self, target_id: impl Into<TargetID>) -> Self {
            self.target_id = Some(target_id.into());
            self
        }
    }

    impl Command for SendMessageToTarget {
        type Response = ();
        const METHOD: &'static str = "Target.sendMessageToTarget";
    }

    /// Controls whether to automatically attach to new targets which are considered to be directly related to this one (for example, iframes or workers). When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets. This also clears all targets added by `autoAttachRelated` from the list of targets to watch for creation of related targets. You might want to call this recursively for auto-attached targets to attach to all available targets.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAutoAttach {
        /// Whether to auto-attach to related targets.
        #[serde(rename = "autoAttach")]
        auto_attach: bool,
        /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger` to run paused targets.
        #[serde(rename = "waitForDebuggerOnStart")]
        wait_for_debugger_on_start: bool,
        /// Enables "flat" access to the session via specifying sessionId attribute in the commands. We plan to make this the default, deprecate non-flattened mode, and eventually retire it. See crbug.com/991325.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        flatten: Option<bool>,
        /// Only targets matching filter will be attached.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        filter: Option<TargetFilter>,
    }

    impl SetAutoAttach {
        pub fn new(
            auto_attach: impl Into<bool>,
            wait_for_debugger_on_start: impl Into<bool>,
        ) -> Self {
            Self {
                auto_attach: auto_attach.into(),
                wait_for_debugger_on_start: wait_for_debugger_on_start.into(),
                flatten: None,
                filter: None,
            }
        }

        pub fn with_flatten(mut self, flatten: impl Into<bool>) -> Self {
            self.flatten = Some(flatten.into());
            self
        }

        pub fn with_filter(mut self, filter: impl Into<TargetFilter>) -> Self {
            self.filter = Some(filter.into());
            self
        }
    }

    impl Command for SetAutoAttach {
        type Response = ();
        const METHOD: &'static str = "Target.setAutoAttach";
    }

    /// Adds the specified target to the list of targets that will be monitored for any related target creation (such as child frames, child workers and new versions of service worker) and reported through `attachedToTarget`. The specified target is also auto-attached. This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent `setAutoAttach`. Only available at the Browser target.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AutoAttachRelated {
        #[serde(rename = "targetId")]
        target_id: TargetID,
        /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger` to run paused targets.
        #[serde(rename = "waitForDebuggerOnStart")]
        wait_for_debugger_on_start: bool,
        /// Only targets matching filter will be attached.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        filter: Option<TargetFilter>,
    }

    impl AutoAttachRelated {
        pub fn new(
            target_id: impl Into<TargetID>,
            wait_for_debugger_on_start: impl Into<bool>,
        ) -> Self {
            Self {
                target_id: target_id.into(),
                wait_for_debugger_on_start: wait_for_debugger_on_start.into(),
                filter: None,
            }
        }

        pub fn with_filter(mut self, filter: impl Into<TargetFilter>) -> Self {
            self.filter = Some(filter.into());
            self
        }
    }

    impl Command for AutoAttachRelated {
        type Response = ();
        const METHOD: &'static str = "Target.autoAttachRelated";
    }

    /// Controls whether to discover available targets and notify via `targetCreated/targetInfoChanged/targetDestroyed` events.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetDiscoverTargets {
        /// Whether to discover available targets.
        discover: bool,
        /// Only targets matching filter will be attached. If `discover` is false, `filter` must be omitted or empty.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        filter: Option<TargetFilter>,
    }

    impl SetDiscoverTargets {
        pub fn new(discover: impl Into<bool>) -> Self {
            Self {
                discover: discover.into(),
                filter: None,
            }
        }

        pub fn with_filter(mut self, filter: impl Into<TargetFilter>) -> Self {
            self.filter = Some(filter.into());
            self
        }
    }

    impl Command for SetDiscoverTargets {
        type Response = ();
        const METHOD: &'static str = "Target.setDiscoverTargets";
    }

    /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to `true`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetRemoteLocations {
        /// List of remote locations.
        locations: Vec<RemoteLocation>,
    }

    impl SetRemoteLocations {
        pub fn new(locations: impl Into<Vec<RemoteLocation>>) -> Self {
            Self {
                locations: locations.into(),
            }
        }
    }

    impl Command for SetRemoteLocations {
        type Response = ();
        const METHOD: &'static str = "Target.setRemoteLocations";
    }

    /// Gets the targetId of the DevTools page target opened for the given target (if any).
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDevToolsTarget {
        /// Page or tab target ID.
        #[serde(rename = "targetId")]
        target_id: TargetID,
    }

    impl GetDevToolsTarget {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
            }
        }
    }

    impl Command for GetDevToolsTarget {
        type Response = GetDevToolsTargetResult;
        const METHOD: &'static str = "Target.getDevToolsTarget";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDevToolsTargetResult {
        /// The targetId of DevTools page target if exists.
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetID>,
    }

    /// Opens a DevTools window for the target.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OpenDevTools {
        /// This can be the page or tab target ID.
        #[serde(rename = "targetId")]
        target_id: TargetID,
        /// The id of the panel we want DevTools to open initially. Currently supported panels are elements, console, network, sources, resources and performance.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "panelId")]
        panel_id: Option<String>,
    }

    impl OpenDevTools {
        pub fn new(target_id: impl Into<TargetID>) -> Self {
            Self {
                target_id: target_id.into(),
                panel_id: None,
            }
        }

        pub fn with_panel_id(mut self, panel_id: impl Into<String>) -> Self {
            self.panel_id = Some(panel_id.into());
            self
        }
    }

    impl Command for OpenDevTools {
        type Response = OpenDevToolsResult;
        const METHOD: &'static str = "Target.openDevTools";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct OpenDevToolsResult {
        /// The targetId of DevTools page target.
        #[serde(rename = "targetId")]
        pub target_id: TargetID,
    }

    /// Issued when attached to target because of auto-attach or `attachToTarget` command.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AttachedToTarget {
        /// Identifier assigned to the session used to send/receive messages.
        #[serde(rename = "sessionId")]
        pub session_id: SessionID,
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
        #[serde(rename = "waitingForDebugger")]
        pub waiting_for_debugger: bool,
    }

    impl AttachedToTarget {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.attachedToTarget")
        }
    }

    /// Issued when detached from target for any reason (including `detachFromTarget` command). Can be issued multiple times per target if multiple sessions have been attached to it.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DetachedFromTarget {
        /// Detached session identifier.
        #[serde(rename = "sessionId")]
        pub session_id: SessionID,
        /// Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetID>,
    }

    impl DetachedFromTarget {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.detachedFromTarget")
        }
    }

    /// Notifies about a new protocol message received from the session (as reported in `attachedToTarget` event).
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReceivedMessageFromTarget {
        /// Identifier of a session which sends a message.
        #[serde(rename = "sessionId")]
        pub session_id: SessionID,
        pub message: String,
        /// Deprecated.
        #[deprecated]
        #[serde(rename = "targetId")]
        pub target_id: Option<TargetID>,
    }

    impl ReceivedMessageFromTarget {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.receivedMessageFromTarget")
        }
    }

    /// Issued when a possible inspection target is created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetCreated {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }

    impl TargetCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.targetCreated")
        }
    }

    /// Issued when a target is destroyed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetDestroyed {
        #[serde(rename = "targetId")]
        pub target_id: TargetID,
    }

    impl TargetDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.targetDestroyed")
        }
    }

    /// Issued when a target has crashed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetCrashed {
        #[serde(rename = "targetId")]
        pub target_id: TargetID,
        /// Termination status type.
        pub status: String,
        /// Termination error code.
        #[serde(rename = "errorCode")]
        pub error_code: i64,
    }

    impl TargetCrashed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.targetCrashed")
        }
    }

    /// Issued when some information about a target has changed. This only happens between `targetCreated` and `targetDestroyed`.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TargetInfoChanged {
        #[serde(rename = "targetInfo")]
        pub target_info: TargetInfo,
    }

    impl TargetInfoChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Target.targetInfoChanged")
        }
    }
}

pub mod tethering {
    use super::*;

    /// Request browser port binding.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Bind {
        /// Port number to bind.
        port: i64,
    }

    impl Bind {
        pub fn new(port: impl Into<i64>) -> Self {
            Self { port: port.into() }
        }
    }

    impl Command for Bind {
        type Response = ();
        const METHOD: &'static str = "Tethering.bind";
    }

    /// Request browser port unbinding.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Unbind {
        /// Port number to unbind.
        port: i64,
    }

    impl Unbind {
        pub fn new(port: impl Into<i64>) -> Self {
            Self { port: port.into() }
        }
    }

    impl Command for Unbind {
        type Response = ();
        const METHOD: &'static str = "Tethering.unbind";
    }

    /// Informs that port was successfully bound and got a specified connection id.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Accepted {
        /// Port number that was successfully bound.
        pub port: i64,
        /// Connection id to be used.
        #[serde(rename = "connectionId")]
        pub connection_id: String,
    }

    impl Accepted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Tethering.accepted")
        }
    }
}

pub mod tracing {
    use super::*;

    /// Configuration for memory dump. Used only when "memory-infra" category is enabled.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type MemoryDumpConfig = serde_json::Value;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TraceConfig {
        /// Controls how the trace buffer stores data. The default is `recordUntilFull`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "recordMode")]
        pub record_mode: Option<String>,
        /// Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value of 200 MB would be used.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "traceBufferSizeInKb")]
        pub trace_buffer_size_in_kb: Option<f64>,
        /// Turns on JavaScript stack sampling.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableSampling")]
        pub enable_sampling: Option<bool>,
        /// Turns on system tracing.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableSystrace")]
        pub enable_systrace: Option<bool>,
        /// Turns on argument filter.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableArgumentFilter")]
        pub enable_argument_filter: Option<bool>,
        /// Included category filters.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includedCategories")]
        pub included_categories: Option<Vec<String>>,
        /// Excluded category filters.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "excludedCategories")]
        pub excluded_categories: Option<Vec<String>>,
        /// Configuration to synthesize the delays in tracing.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "syntheticDelays")]
        pub synthetic_delays: Option<Vec<String>>,
        /// Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "memoryDumpConfig")]
        pub memory_dump_config: Option<MemoryDumpConfig>,
    }

    /// Data format of a trace. Can be either the legacy JSON format or the protocol buffer format. Note that the JSON format will be deprecated soon.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StreamFormat {
        #[serde(rename = "json")]
        Json,
        #[serde(rename = "proto")]
        Proto,
    }
    impl From<&str> for StreamFormat {
        fn from(s: &str) -> Self {
            match s {
                "json" => Self::Json,
                "proto" => Self::Proto,
                _ => Self::Json,
            }
        }
    }
    impl From<String> for StreamFormat {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Compression type to use for traces returned via streams.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum StreamCompression {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "gzip")]
        Gzip,
    }
    impl From<&str> for StreamCompression {
        fn from(s: &str) -> Self {
            match s {
                "none" => Self::None,
                "gzip" => Self::Gzip,
                _ => Self::None,
            }
        }
    }
    impl From<String> for StreamCompression {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Details exposed when memory request explicitly declared. Keep consistent with memory_dump_request_args.h and memory_instrumentation.mojom
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum MemoryDumpLevelOfDetail {
        #[serde(rename = "background")]
        Background,
        #[serde(rename = "light")]
        Light,
        #[serde(rename = "detailed")]
        Detailed,
    }
    impl From<&str> for MemoryDumpLevelOfDetail {
        fn from(s: &str) -> Self {
            match s {
                "background" => Self::Background,
                "light" => Self::Light,
                "detailed" => Self::Detailed,
                _ => Self::Background,
            }
        }
    }
    impl From<String> for MemoryDumpLevelOfDetail {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Backend type to use for tracing. `chrome` uses the Chrome-integrated tracing service and is supported on all platforms. `system` is only supported on Chrome OS and uses the Perfetto system tracing service. `auto` chooses `system` when the perfettoConfig provided to Tracing.start specifies at least one non-Chrome data source; otherwise uses `chrome`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum TracingBackend {
        #[serde(rename = "auto")]
        Auto,
        #[serde(rename = "chrome")]
        Chrome,
        #[serde(rename = "system")]
        System,
    }
    impl From<&str> for TracingBackend {
        fn from(s: &str) -> Self {
            match s {
                "auto" => Self::Auto,
                "chrome" => Self::Chrome,
                "system" => Self::System,
                _ => Self::Auto,
            }
        }
    }
    impl From<String> for TracingBackend {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Stop trace events collection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct End {}

    impl End {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for End {
        type Response = ();
        const METHOD: &'static str = "Tracing.end";
    }

    /// Gets supported tracing categories.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCategories {}

    impl GetCategories {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetCategories {
        type Response = GetCategoriesResult;
        const METHOD: &'static str = "Tracing.getCategories";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCategoriesResult {
        /// A list of supported tracing categories.
        pub categories: Vec<String>,
    }

    /// Return a descriptor for all available tracing categories.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTrackEventDescriptor {}

    impl GetTrackEventDescriptor {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetTrackEventDescriptor {
        type Response = GetTrackEventDescriptorResult;
        const METHOD: &'static str = "Tracing.getTrackEventDescriptor";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetTrackEventDescriptorResult {
        /// Base64-encoded serialized perfetto.protos.TrackEventDescriptor protobuf message. (Encoded as a base64 string when passed over JSON)
        pub descriptor: String,
    }

    /// Record a clock sync marker in the trace.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RecordClockSyncMarker {
        /// The ID of this clock sync marker
        #[serde(rename = "syncId")]
        sync_id: String,
    }

    impl RecordClockSyncMarker {
        pub fn new(sync_id: impl Into<String>) -> Self {
            Self {
                sync_id: sync_id.into(),
            }
        }
    }

    impl Command for RecordClockSyncMarker {
        type Response = ();
        const METHOD: &'static str = "Tracing.recordClockSyncMarker";
    }

    /// Request a global memory dump.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestMemoryDump {
        /// Enables more deterministic results by forcing garbage collection
        #[serde(skip_serializing_if = "Option::is_none")]
        deterministic: Option<bool>,
        /// Specifies level of details in memory dump. Defaults to "detailed".
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "levelOfDetail")]
        level_of_detail: Option<MemoryDumpLevelOfDetail>,
    }

    impl RequestMemoryDump {
        pub fn new() -> Self {
            Self {
                deterministic: None,
                level_of_detail: None,
            }
        }

        pub fn with_deterministic(mut self, deterministic: impl Into<bool>) -> Self {
            self.deterministic = Some(deterministic.into());
            self
        }

        pub fn with_level_of_detail(
            mut self,
            level_of_detail: impl Into<MemoryDumpLevelOfDetail>,
        ) -> Self {
            self.level_of_detail = Some(level_of_detail.into());
            self
        }
    }

    impl Command for RequestMemoryDump {
        type Response = RequestMemoryDumpResult;
        const METHOD: &'static str = "Tracing.requestMemoryDump";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RequestMemoryDumpResult {
        /// GUID of the resulting global memory dump.
        #[serde(rename = "dumpGuid")]
        pub dump_guid: String,
        /// True iff the global memory dump succeeded.
        pub success: bool,
    }

    /// Start trace events collection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Start {
        /// Category/tag filter
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        categories: Option<String>,
        /// Tracing options
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        options: Option<String>,
        /// If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bufferUsageReportingInterval")]
        buffer_usage_reporting_interval: Option<f64>,
        /// Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to `ReportEvents`).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "transferMode")]
        transfer_mode: Option<String>,
        /// Trace data format to use. This only applies when using `ReturnAsStream` transfer mode (defaults to `json`).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "streamFormat")]
        stream_format: Option<StreamFormat>,
        /// Compression format to use. This only applies when using `ReturnAsStream` transfer mode (defaults to `none`)
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "streamCompression")]
        stream_compression: Option<StreamCompression>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "traceConfig")]
        trace_config: Option<TraceConfig>,
        /// Base64-encoded serialized perfetto.protos.TraceConfig protobuf message When specified, the parameters `categories`, `options`, `traceConfig` are ignored. (Encoded as a base64 string when passed over JSON)
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "perfettoConfig")]
        perfetto_config: Option<String>,
        /// Backend type (defaults to `auto`)
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "tracingBackend")]
        tracing_backend: Option<TracingBackend>,
    }

    impl Start {
        pub fn new() -> Self {
            Self {
                categories: None,
                options: None,
                buffer_usage_reporting_interval: None,
                transfer_mode: None,
                stream_format: None,
                stream_compression: None,
                trace_config: None,
                perfetto_config: None,
                tracing_backend: None,
            }
        }

        pub fn with_categories(mut self, categories: impl Into<String>) -> Self {
            self.categories = Some(categories.into());
            self
        }

        pub fn with_options(mut self, options: impl Into<String>) -> Self {
            self.options = Some(options.into());
            self
        }

        pub fn with_buffer_usage_reporting_interval(
            mut self,
            buffer_usage_reporting_interval: impl Into<f64>,
        ) -> Self {
            self.buffer_usage_reporting_interval = Some(buffer_usage_reporting_interval.into());
            self
        }

        pub fn with_transfer_mode(mut self, transfer_mode: impl Into<String>) -> Self {
            self.transfer_mode = Some(transfer_mode.into());
            self
        }

        pub fn with_stream_format(mut self, stream_format: impl Into<StreamFormat>) -> Self {
            self.stream_format = Some(stream_format.into());
            self
        }

        pub fn with_stream_compression(
            mut self,
            stream_compression: impl Into<StreamCompression>,
        ) -> Self {
            self.stream_compression = Some(stream_compression.into());
            self
        }

        pub fn with_trace_config(mut self, trace_config: impl Into<TraceConfig>) -> Self {
            self.trace_config = Some(trace_config.into());
            self
        }

        pub fn with_perfetto_config(mut self, perfetto_config: impl Into<String>) -> Self {
            self.perfetto_config = Some(perfetto_config.into());
            self
        }

        pub fn with_tracing_backend(mut self, tracing_backend: impl Into<TracingBackend>) -> Self {
            self.tracing_backend = Some(tracing_backend.into());
            self
        }
    }

    impl Command for Start {
        type Response = ();
        const METHOD: &'static str = "Tracing.start";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BufferUsage {
        /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
        #[serde(rename = "percentFull")]
        pub percent_full: Option<f64>,
        /// An approximate number of events in the trace log.
        #[serde(rename = "eventCount")]
        pub event_count: Option<f64>,
        /// A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
        pub value: Option<f64>,
    }

    impl BufferUsage {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Tracing.bufferUsage")
        }
    }

    /// Contains a bucket of collected trace events. When tracing is stopped collected events will be sent as a sequence of dataCollected events followed by tracingComplete event.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DataCollected {
        pub value: Vec<serde_json::Value>,
    }

    impl DataCollected {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Tracing.dataCollected")
        }
    }

    /// Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TracingComplete {
        /// Indicates whether some trace data is known to have been lost, e.g. because the trace ring buffer wrapped around.
        #[serde(rename = "dataLossOccurred")]
        pub data_loss_occurred: bool,
        /// A handle of the stream that holds resulting trace data.
        pub stream: Option<io::StreamHandle>,
        /// Trace data format of returned stream.
        #[serde(rename = "traceFormat")]
        pub trace_format: Option<StreamFormat>,
        /// Compression format of returned stream.
        #[serde(rename = "streamCompression")]
        pub stream_compression: Option<StreamCompression>,
    }

    impl TracingComplete {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Tracing.tracingComplete")
        }
    }
}

pub mod web_audio {
    use super::*;

    /// An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
    pub type GraphObjectId = String;

    /// Enum of BaseAudioContext types
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContextType {
        #[serde(rename = "realtime")]
        Realtime,
        #[serde(rename = "offline")]
        Offline,
    }
    impl From<&str> for ContextType {
        fn from(s: &str) -> Self {
            match s {
                "realtime" => Self::Realtime,
                "offline" => Self::Offline,
                _ => Self::Realtime,
            }
        }
    }
    impl From<String> for ContextType {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of AudioContextState from the spec
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ContextState {
        #[serde(rename = "suspended")]
        Suspended,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "closed")]
        Closed,
        #[serde(rename = "interrupted")]
        Interrupted,
    }
    impl From<&str> for ContextState {
        fn from(s: &str) -> Self {
            match s {
                "suspended" => Self::Suspended,
                "running" => Self::Running,
                "closed" => Self::Closed,
                "interrupted" => Self::Interrupted,
                _ => Self::Suspended,
            }
        }
    }
    impl From<String> for ContextState {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of AudioNode types
    pub type NodeType = String;

    /// Enum of AudioNode::ChannelCountMode from the spec
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ChannelCountMode {
        #[serde(rename = "clamped-max")]
        ClampedMax,
        #[serde(rename = "explicit")]
        Explicit,
        #[serde(rename = "max")]
        Max,
    }
    impl From<&str> for ChannelCountMode {
        fn from(s: &str) -> Self {
            match s {
                "clamped-max" => Self::ClampedMax,
                "explicit" => Self::Explicit,
                "max" => Self::Max,
                _ => Self::ClampedMax,
            }
        }
    }
    impl From<String> for ChannelCountMode {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of AudioNode::ChannelInterpretation from the spec
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ChannelInterpretation {
        #[serde(rename = "discrete")]
        Discrete,
        #[serde(rename = "speakers")]
        Speakers,
    }
    impl From<&str> for ChannelInterpretation {
        fn from(s: &str) -> Self {
            match s {
                "discrete" => Self::Discrete,
                "speakers" => Self::Speakers,
                _ => Self::Discrete,
            }
        }
    }
    impl From<String> for ChannelInterpretation {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Enum of AudioParam types
    pub type ParamType = String;

    /// Enum of AudioParam::AutomationRate from the spec
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AutomationRate {
        #[serde(rename = "a-rate")]
        ARate,
        #[serde(rename = "k-rate")]
        KRate,
    }
    impl From<&str> for AutomationRate {
        fn from(s: &str) -> Self {
            match s {
                "a-rate" => Self::ARate,
                "k-rate" => Self::KRate,
                _ => Self::ARate,
            }
        }
    }
    impl From<String> for AutomationRate {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Fields in AudioContext that change in real-time.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContextRealtimeData {
        /// The current context time in second in BaseAudioContext.
        #[serde(rename = "currentTime")]
        pub current_time: f64,
        /// The time spent on rendering graph divided by render quantum duration, and multiplied by 100. 100 means the audio renderer reached the full capacity and glitch may occur.
        #[serde(rename = "renderCapacity")]
        pub render_capacity: f64,
        /// A running mean of callback interval.
        #[serde(rename = "callbackIntervalMean")]
        pub callback_interval_mean: f64,
        /// A running variance of callback interval.
        #[serde(rename = "callbackIntervalVariance")]
        pub callback_interval_variance: f64,
    }

    /// Protocol object for BaseAudioContext
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BaseAudioContext {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "contextType")]
        pub context_type: ContextType,
        #[serde(rename = "contextState")]
        pub context_state: ContextState,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "realtimeData")]
        pub realtime_data: Option<ContextRealtimeData>,
        /// Platform-dependent callback buffer size.
        #[serde(rename = "callbackBufferSize")]
        pub callback_buffer_size: f64,
        /// Number of output channels supported by audio hardware in use.
        #[serde(rename = "maxOutputChannelCount")]
        pub max_output_channel_count: f64,
        /// Context sample rate.
        #[serde(rename = "sampleRate")]
        pub sample_rate: f64,
    }

    /// Protocol object for AudioListener
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioListener {
        #[serde(rename = "listenerId")]
        pub listener_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
    }

    /// Protocol object for AudioNode
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioNode {
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeType")]
        pub node_type: NodeType,
        #[serde(rename = "numberOfInputs")]
        pub number_of_inputs: f64,
        #[serde(rename = "numberOfOutputs")]
        pub number_of_outputs: f64,
        #[serde(rename = "channelCount")]
        pub channel_count: f64,
        #[serde(rename = "channelCountMode")]
        pub channel_count_mode: ChannelCountMode,
        #[serde(rename = "channelInterpretation")]
        pub channel_interpretation: ChannelInterpretation,
    }

    /// Protocol object for AudioParam
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioParam {
        #[serde(rename = "paramId")]
        pub param_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "paramType")]
        pub param_type: ParamType,
        pub rate: AutomationRate,
        #[serde(rename = "defaultValue")]
        pub default_value: f64,
        #[serde(rename = "minValue")]
        pub min_value: f64,
        #[serde(rename = "maxValue")]
        pub max_value: f64,
    }

    /// Enables the WebAudio domain and starts sending context lifetime events.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "WebAudio.enable";
    }

    /// Disables the WebAudio domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "WebAudio.disable";
    }

    /// Fetch the realtime data from the registered contexts.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRealtimeData {
        #[serde(rename = "contextId")]
        context_id: GraphObjectId,
    }

    impl GetRealtimeData {
        pub fn new(context_id: impl Into<GraphObjectId>) -> Self {
            Self {
                context_id: context_id.into(),
            }
        }
    }

    impl Command for GetRealtimeData {
        type Response = GetRealtimeDataResult;
        const METHOD: &'static str = "WebAudio.getRealtimeData";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetRealtimeDataResult {
        #[serde(rename = "realtimeData")]
        pub realtime_data: ContextRealtimeData,
    }

    /// Notifies that a new BaseAudioContext has been created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContextCreated {
        pub context: BaseAudioContext,
    }

    impl ContextCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.contextCreated")
        }
    }

    /// Notifies that an existing BaseAudioContext will be destroyed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContextWillBeDestroyed {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
    }

    impl ContextWillBeDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.contextWillBeDestroyed")
        }
    }

    /// Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContextChanged {
        pub context: BaseAudioContext,
    }

    impl ContextChanged {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.contextChanged")
        }
    }

    /// Notifies that the construction of an AudioListener has finished.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioListenerCreated {
        pub listener: AudioListener,
    }

    impl AudioListenerCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.audioListenerCreated")
        }
    }

    /// Notifies that a new AudioListener has been created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioListenerWillBeDestroyed {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "listenerId")]
        pub listener_id: GraphObjectId,
    }

    impl AudioListenerWillBeDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("WebAudio.audioListenerWillBeDestroyed")
        }
    }

    /// Notifies that a new AudioNode has been created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioNodeCreated {
        pub node: AudioNode,
    }

    impl AudioNodeCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.audioNodeCreated")
        }
    }

    /// Notifies that an existing AudioNode has been destroyed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioNodeWillBeDestroyed {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
    }

    impl AudioNodeWillBeDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.audioNodeWillBeDestroyed")
        }
    }

    /// Notifies that a new AudioParam has been created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioParamCreated {
        pub param: AudioParam,
    }

    impl AudioParamCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.audioParamCreated")
        }
    }

    /// Notifies that an existing AudioParam has been destroyed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AudioParamWillBeDestroyed {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "nodeId")]
        pub node_id: GraphObjectId,
        #[serde(rename = "paramId")]
        pub param_id: GraphObjectId,
    }

    impl AudioParamWillBeDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.audioParamWillBeDestroyed")
        }
    }

    /// Notifies that two AudioNodes are connected.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodesConnected {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
        #[serde(rename = "destinationInputIndex")]
        pub destination_input_index: Option<f64>,
    }

    impl NodesConnected {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.nodesConnected")
        }
    }

    /// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodesDisconnected {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
        #[serde(rename = "destinationInputIndex")]
        pub destination_input_index: Option<f64>,
    }

    impl NodesDisconnected {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.nodesDisconnected")
        }
    }

    /// Notifies that an AudioNode is connected to an AudioParam.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodeParamConnected {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
    }

    impl NodeParamConnected {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.nodeParamConnected")
        }
    }

    /// Notifies that an AudioNode is disconnected to an AudioParam.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NodeParamDisconnected {
        #[serde(rename = "contextId")]
        pub context_id: GraphObjectId,
        #[serde(rename = "sourceId")]
        pub source_id: GraphObjectId,
        #[serde(rename = "destinationId")]
        pub destination_id: GraphObjectId,
        #[serde(rename = "sourceOutputIndex")]
        pub source_output_index: Option<f64>,
    }

    impl NodeParamDisconnected {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAudio.nodeParamDisconnected")
        }
    }
}

pub mod web_authn {
    use super::*;

    pub type AuthenticatorId = String;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AuthenticatorProtocol {
        #[serde(rename = "u2f")]
        U2f,
        #[serde(rename = "ctap2")]
        Ctap2,
    }
    impl From<&str> for AuthenticatorProtocol {
        fn from(s: &str) -> Self {
            match s {
                "u2f" => Self::U2f,
                "ctap2" => Self::Ctap2,
                _ => Self::U2f,
            }
        }
    }
    impl From<String> for AuthenticatorProtocol {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum Ctap2Version {
        #[serde(rename = "ctap2_0")]
        Ctap20,
        #[serde(rename = "ctap2_1")]
        Ctap21,
    }
    impl From<&str> for Ctap2Version {
        fn from(s: &str) -> Self {
            match s {
                "ctap2_0" => Self::Ctap20,
                "ctap2_1" => Self::Ctap21,
                _ => Self::Ctap20,
            }
        }
    }
    impl From<String> for Ctap2Version {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AuthenticatorTransport {
        #[serde(rename = "usb")]
        Usb,
        #[serde(rename = "nfc")]
        Nfc,
        #[serde(rename = "ble")]
        Ble,
        #[serde(rename = "cable")]
        Cable,
        #[serde(rename = "internal")]
        Internal,
    }
    impl From<&str> for AuthenticatorTransport {
        fn from(s: &str) -> Self {
            match s {
                "usb" => Self::Usb,
                "nfc" => Self::Nfc,
                "ble" => Self::Ble,
                "cable" => Self::Cable,
                "internal" => Self::Internal,
                _ => Self::Usb,
            }
        }
    }
    impl From<String> for AuthenticatorTransport {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct VirtualAuthenticatorOptions {
        pub protocol: AuthenticatorProtocol,
        /// Defaults to ctap2_0. Ignored if |protocol| == u2f.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ctap2Version")]
        pub ctap2_version: Option<Ctap2Version>,
        pub transport: AuthenticatorTransport,
        /// Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasResidentKey")]
        pub has_resident_key: Option<bool>,
        /// Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasUserVerification")]
        pub has_user_verification: Option<bool>,
        /// If set to true, the authenticator will support the largeBlob extension. https://w3c.github.io/webauthn#largeBlob Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasLargeBlob")]
        pub has_large_blob: Option<bool>,
        /// If set to true, the authenticator will support the credBlob extension. https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasCredBlob")]
        pub has_cred_blob: Option<bool>,
        /// If set to true, the authenticator will support the minPinLength extension. https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasMinPinLength")]
        pub has_min_pin_length: Option<bool>,
        /// If set to true, the authenticator will support the prf extension. https://w3c.github.io/webauthn/#prf-extension Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hasPrf")]
        pub has_prf: Option<bool>,
        /// If set to true, tests of user presence will succeed immediately. Otherwise, they will not be resolved. Defaults to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "automaticPresenceSimulation")]
        pub automatic_presence_simulation: Option<bool>,
        /// Sets whether User Verification succeeds or fails for an authenticator. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isUserVerified")]
        pub is_user_verified: Option<bool>,
        /// Credentials created by this authenticator will have the backup eligibility (BE) flag set to this value. Defaults to false. https://w3c.github.io/webauthn/#sctn-credential-backup
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "defaultBackupEligibility")]
        pub default_backup_eligibility: Option<bool>,
        /// Credentials created by this authenticator will have the backup state (BS) flag set to this value. Defaults to false. https://w3c.github.io/webauthn/#sctn-credential-backup
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "defaultBackupState")]
        pub default_backup_state: Option<bool>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Credential {
        #[serde(rename = "credentialId")]
        pub credential_id: String,
        #[serde(rename = "isResidentCredential")]
        pub is_resident_credential: bool,
        /// Relying Party ID the credential is scoped to. Must be set when adding a credential.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "rpId")]
        pub rp_id: Option<String>,
        /// The ECDSA P-256 private key in PKCS#8 format. (Encoded as a base64 string when passed over JSON)
        #[serde(rename = "privateKey")]
        pub private_key: String,
        /// An opaque byte sequence with a maximum size of 64 bytes mapping the credential to a specific user. (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userHandle")]
        pub user_handle: Option<String>,
        /// Signature counter. This is incremented by one for each successful assertion. See https://w3c.github.io/webauthn/#signature-counter
        #[serde(rename = "signCount")]
        pub sign_count: i64,
        /// The large blob associated with the credential. See https://w3c.github.io/webauthn/#sctn-large-blob-extension (Encoded as a base64 string when passed over JSON)
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "largeBlob")]
        pub large_blob: Option<String>,
        /// Assertions returned by this credential will have the backup eligibility (BE) flag set to this value. Defaults to the authenticator's defaultBackupEligibility value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backupEligibility")]
        pub backup_eligibility: Option<bool>,
        /// Assertions returned by this credential will have the backup state (BS) flag set to this value. Defaults to the authenticator's defaultBackupState value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backupState")]
        pub backup_state: Option<bool>,
        /// The credential's user.name property. Equivalent to empty if not set. https://w3c.github.io/webauthn/#dom-publickeycredentialentity-name
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userName")]
        pub user_name: Option<String>,
        /// The credential's user.displayName property. Equivalent to empty if not set. https://w3c.github.io/webauthn/#dom-publickeycredentialuserentity-displayname
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userDisplayName")]
        pub user_display_name: Option<String>,
    }

    /// Enable the WebAuthn domain and start intercepting credential storage and retrieval with a virtual authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// Whether to enable the WebAuthn user interface. Enabling the UI is recommended for debugging and demo purposes, as it is closer to the real experience. Disabling the UI is recommended for automated testing. Supported at the embedder's discretion if UI is available. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "enableUI")]
        enable_ui: Option<bool>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self { enable_ui: None }
        }

        pub fn with_enable_ui(mut self, enable_ui: impl Into<bool>) -> Self {
            self.enable_ui = Some(enable_ui.into());
            self
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.enable";
    }

    /// Disable the WebAuthn domain.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.disable";
    }

    /// Creates and adds a virtual authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddVirtualAuthenticator {
        options: VirtualAuthenticatorOptions,
    }

    impl AddVirtualAuthenticator {
        pub fn new(options: impl Into<VirtualAuthenticatorOptions>) -> Self {
            Self {
                options: options.into(),
            }
        }
    }

    impl Command for AddVirtualAuthenticator {
        type Response = AddVirtualAuthenticatorResult;
        const METHOD: &'static str = "WebAuthn.addVirtualAuthenticator";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddVirtualAuthenticatorResult {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
    }

    /// Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetResponseOverrideBits {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        /// If isBogusSignature is set, overrides the signature in the authenticator response to be zero. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isBogusSignature")]
        is_bogus_signature: Option<bool>,
        /// If isBadUV is set, overrides the UV bit in the flags in the authenticator response to be zero. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isBadUV")]
        is_bad_uv: Option<bool>,
        /// If isBadUP is set, overrides the UP bit in the flags in the authenticator response to be zero. Defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isBadUP")]
        is_bad_up: Option<bool>,
    }

    impl SetResponseOverrideBits {
        pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                is_bogus_signature: None,
                is_bad_uv: None,
                is_bad_up: None,
            }
        }

        pub fn with_is_bogus_signature(mut self, is_bogus_signature: impl Into<bool>) -> Self {
            self.is_bogus_signature = Some(is_bogus_signature.into());
            self
        }

        pub fn with_is_bad_uv(mut self, is_bad_uv: impl Into<bool>) -> Self {
            self.is_bad_uv = Some(is_bad_uv.into());
            self
        }

        pub fn with_is_bad_up(mut self, is_bad_up: impl Into<bool>) -> Self {
            self.is_bad_up = Some(is_bad_up.into());
            self
        }
    }

    impl Command for SetResponseOverrideBits {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.setResponseOverrideBits";
    }

    /// Removes the given authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveVirtualAuthenticator {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
    }

    impl RemoveVirtualAuthenticator {
        pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
            }
        }
    }

    impl Command for RemoveVirtualAuthenticator {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.removeVirtualAuthenticator";
    }

    /// Adds the credential to the specified authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddCredential {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        credential: Credential,
    }

    impl AddCredential {
        pub fn new(
            authenticator_id: impl Into<AuthenticatorId>,
            credential: impl Into<Credential>,
        ) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                credential: credential.into(),
            }
        }
    }

    impl Command for AddCredential {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.addCredential";
    }

    /// Returns a single credential stored in the given virtual authenticator that matches the credential ID.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCredential {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        credential_id: String,
    }

    impl GetCredential {
        pub fn new(
            authenticator_id: impl Into<AuthenticatorId>,
            credential_id: impl Into<String>,
        ) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                credential_id: credential_id.into(),
            }
        }
    }

    impl Command for GetCredential {
        type Response = GetCredentialResult;
        const METHOD: &'static str = "WebAuthn.getCredential";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCredentialResult {
        pub credential: Credential,
    }

    /// Returns all the credentials stored in the given virtual authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCredentials {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
    }

    impl GetCredentials {
        pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
            }
        }
    }

    impl Command for GetCredentials {
        type Response = GetCredentialsResult;
        const METHOD: &'static str = "WebAuthn.getCredentials";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetCredentialsResult {
        pub credentials: Vec<Credential>,
    }

    /// Removes a credential from the authenticator.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveCredential {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        credential_id: String,
    }

    impl RemoveCredential {
        pub fn new(
            authenticator_id: impl Into<AuthenticatorId>,
            credential_id: impl Into<String>,
        ) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                credential_id: credential_id.into(),
            }
        }
    }

    impl Command for RemoveCredential {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.removeCredential";
    }

    /// Clears all the credentials from the specified device.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearCredentials {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
    }

    impl ClearCredentials {
        pub fn new(authenticator_id: impl Into<AuthenticatorId>) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
            }
        }
    }

    impl Command for ClearCredentials {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.clearCredentials";
    }

    /// Sets whether User Verification succeeds or fails for an authenticator. The default is true.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetUserVerified {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        #[serde(rename = "isUserVerified")]
        is_user_verified: bool,
    }

    impl SetUserVerified {
        pub fn new(
            authenticator_id: impl Into<AuthenticatorId>,
            is_user_verified: impl Into<bool>,
        ) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                is_user_verified: is_user_verified.into(),
            }
        }
    }

    impl Command for SetUserVerified {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.setUserVerified";
    }

    /// Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator. The default is true.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAutomaticPresenceSimulation {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        enabled: bool,
    }

    impl SetAutomaticPresenceSimulation {
        pub fn new(authenticator_id: impl Into<AuthenticatorId>, enabled: impl Into<bool>) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetAutomaticPresenceSimulation {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.setAutomaticPresenceSimulation";
    }

    /// Allows setting credential properties. https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCredentialProperties {
        #[serde(rename = "authenticatorId")]
        authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        credential_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backupEligibility")]
        backup_eligibility: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "backupState")]
        backup_state: Option<bool>,
    }

    impl SetCredentialProperties {
        pub fn new(
            authenticator_id: impl Into<AuthenticatorId>,
            credential_id: impl Into<String>,
        ) -> Self {
            Self {
                authenticator_id: authenticator_id.into(),
                credential_id: credential_id.into(),
                backup_eligibility: None,
                backup_state: None,
            }
        }

        pub fn with_backup_eligibility(mut self, backup_eligibility: impl Into<bool>) -> Self {
            self.backup_eligibility = Some(backup_eligibility.into());
            self
        }

        pub fn with_backup_state(mut self, backup_state: impl Into<bool>) -> Self {
            self.backup_state = Some(backup_state.into());
            self
        }
    }

    impl Command for SetCredentialProperties {
        type Response = ();
        const METHOD: &'static str = "WebAuthn.setCredentialProperties";
    }

    /// Triggered when a credential is added to an authenticator.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CredentialAdded {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        pub credential: Credential,
    }

    impl CredentialAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAuthn.credentialAdded")
        }
    }

    /// Triggered when a credential is deleted, e.g. through PublicKeyCredential.signalUnknownCredential().
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CredentialDeleted {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        #[serde(rename = "credentialId")]
        pub credential_id: String,
    }

    impl CredentialDeleted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAuthn.credentialDeleted")
        }
    }

    /// Triggered when a credential is updated, e.g. through PublicKeyCredential.signalCurrentUserDetails().
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CredentialUpdated {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        pub credential: Credential,
    }

    impl CredentialUpdated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAuthn.credentialUpdated")
        }
    }

    /// Triggered when a credential is used in a webauthn assertion.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CredentialAsserted {
        #[serde(rename = "authenticatorId")]
        pub authenticator_id: AuthenticatorId,
        pub credential: Credential,
    }

    impl CredentialAsserted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("WebAuthn.credentialAsserted")
        }
    }
}

pub mod console {
    use super::*;

    /// Console message.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConsoleMessage {
        /// Message source.
        pub source: String,
        /// Message severity.
        pub level: String,
        /// Message text.
        pub text: String,
        /// URL of the message origin.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// Line number in the resource that generated this message (1-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        /// Column number in the resource that generated this message (1-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub column: Option<i64>,
    }

    /// Does nothing.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ClearMessages {}

    impl ClearMessages {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for ClearMessages {
        type Response = ();
        const METHOD: &'static str = "Console.clearMessages";
    }

    /// Disables console domain, prevents further console messages from being reported to the client.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Console.disable";
    }

    /// Enables console domain, sends the messages collected so far to the client by means of the `messageAdded` notification.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Console.enable";
    }

    /// Issued when new console message is added.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct MessageAdded {
        /// Console message that has been added.
        pub message: ConsoleMessage,
    }

    impl MessageAdded {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Console.messageAdded")
        }
    }
}

pub mod debugger {
    use super::*;

    /// Breakpoint identifier.
    pub type BreakpointId = String;

    /// Call frame identifier.
    pub type CallFrameId = String;

    /// Location in the source code.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Location {
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// Column number in the script (0-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnNumber")]
        pub column_number: Option<i64>,
    }

    /// Location in the source code.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScriptPosition {
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }

    /// Location range within one script.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LocationRange {
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        pub start: ScriptPosition,
        pub end: ScriptPosition,
    }

    /// JavaScript call frame. Array of call frames form the call stack.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CallFrame {
        /// Call frame identifier. This identifier is only valid while the virtual machine is paused.
        #[serde(rename = "callFrameId")]
        pub call_frame_id: CallFrameId,
        /// Name of the JavaScript function called on this call frame.
        #[serde(rename = "functionName")]
        pub function_name: String,
        /// Location in the source code.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "functionLocation")]
        pub function_location: Option<Location>,
        /// Location in the source code.
        pub location: Location,
        /// JavaScript script name or url. Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously sent `Debugger.scriptParsed` event.
        #[deprecated]
        pub url: String,
        /// Scope chain for this call frame.
        #[serde(rename = "scopeChain")]
        pub scope_chain: Vec<Scope>,
        /// `this` object for this call frame.
        pub this: runtime::RemoteObject,
        /// The value being returned, if the function is at return point.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnValue")]
        pub return_value: Option<runtime::RemoteObject>,
        /// Valid only while the VM is paused and indicates whether this frame can be restarted or not. Note that a `true` value here does not guarantee that Debugger#restartFrame with this CallFrameId will be successful, but it is very likely.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "canBeRestarted")]
        pub can_be_restarted: Option<bool>,
    }

    /// Scope description.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Scope {
        /// Scope type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Object representing the scope. For `global` and `with` scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
        pub object: runtime::RemoteObject,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
        /// Location in the source code where scope starts
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "startLocation")]
        pub start_location: Option<Location>,
        /// Location in the source code where scope ends
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "endLocation")]
        pub end_location: Option<Location>,
    }

    /// Search match for resource.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchMatch {
        /// Line number in resource content.
        #[serde(rename = "lineNumber")]
        pub line_number: f64,
        /// Line with match content.
        #[serde(rename = "lineContent")]
        pub line_content: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BreakLocation {
        /// Script identifier as reported in the `Debugger.scriptParsed`.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// Line number in the script (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// Column number in the script (0-based).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnNumber")]
        pub column_number: Option<i64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "type")]
        pub type_: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct WasmDisassemblyChunk {
        /// The next chunk of disassembled lines.
        pub lines: Vec<String>,
        /// The bytecode offsets describing the start of each line.
        #[serde(rename = "bytecodeOffsets")]
        pub bytecode_offsets: Vec<i64>,
    }

    /// Enum of possible script languages.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ScriptLanguage {
        #[serde(rename = "JavaScript")]
        JavaScript,
        #[serde(rename = "WebAssembly")]
        WebAssembly,
    }
    impl From<&str> for ScriptLanguage {
        fn from(s: &str) -> Self {
            match s {
                "JavaScript" => Self::JavaScript,
                "WebAssembly" => Self::WebAssembly,
                _ => Self::JavaScript,
            }
        }
    }
    impl From<String> for ScriptLanguage {
        fn from(s: String) -> Self {
            Self::from(s.as_str())
        }
    }

    /// Debug symbols available for a wasm script.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DebugSymbols {
        /// Type of the debug symbols.
        #[serde(rename = "type")]
        pub type_: String,
        /// URL of the external symbol source.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "externalURL")]
        pub external_url: Option<String>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResolvedBreakpoint {
        /// Breakpoint unique identifier.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        /// Actual breakpoint location.
        pub location: Location,
    }

    /// Continues execution until specific location is reached.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ContinueToLocation {
        /// Location to continue to.
        location: Location,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "targetCallFrames")]
        target_call_frames: Option<String>,
    }

    impl ContinueToLocation {
        pub fn new(location: impl Into<Location>) -> Self {
            Self {
                location: location.into(),
                target_call_frames: None,
            }
        }

        pub fn with_target_call_frames(mut self, target_call_frames: impl Into<String>) -> Self {
            self.target_call_frames = Some(target_call_frames.into());
            self
        }
    }

    impl Command for ContinueToLocation {
        type Response = ();
        const METHOD: &'static str = "Debugger.continueToLocation";
    }

    /// Disables debugger for given page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Debugger.disable";
    }

    /// Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {
        /// The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxScriptsCacheSize")]
        max_scripts_cache_size: Option<f64>,
    }

    impl Enable {
        pub fn new() -> Self {
            Self {
                max_scripts_cache_size: None,
            }
        }

        pub fn with_max_scripts_cache_size(
            mut self,
            max_scripts_cache_size: impl Into<f64>,
        ) -> Self {
            self.max_scripts_cache_size = Some(max_scripts_cache_size.into());
            self
        }
    }

    impl Command for Enable {
        type Response = EnableResult;
        const METHOD: &'static str = "Debugger.enable";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EnableResult {
        /// Unique identifier of the debugger.
        /// **EXPERIMENTAL**
        #[serde(rename = "debuggerId")]
        pub debugger_id: Option<runtime::UniqueDebuggerId>,
    }

    /// Evaluates expression on a given call frame.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EvaluateOnCallFrame {
        /// Call frame identifier to evaluate on.
        #[serde(rename = "callFrameId")]
        call_frame_id: CallFrameId,
        /// Expression to evaluate.
        expression: String,
        /// String object group name to put result into (allows rapid releasing resulting object handles using `releaseObjectGroup`).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
        /// Specifies whether command line API should be available to the evaluated expression, defaults to false.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeCommandLineAPI")]
        include_command_line_api: Option<bool>,
        /// In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
        #[serde(skip_serializing_if = "Option::is_none")]
        silent: Option<bool>,
        /// Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnByValue")]
        return_by_value: Option<bool>,
        /// Whether preview should be generated for the result.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
        /// Whether to throw an exception if side effect cannot be ruled out during evaluation.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "throwOnSideEffect")]
        throw_on_side_effect: Option<bool>,
        /// Terminate execution after timing out (number of milliseconds).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        timeout: Option<runtime::TimeDelta>,
    }

    impl EvaluateOnCallFrame {
        pub fn new(call_frame_id: impl Into<CallFrameId>, expression: impl Into<String>) -> Self {
            Self {
                call_frame_id: call_frame_id.into(),
                expression: expression.into(),
                object_group: None,
                include_command_line_api: None,
                silent: None,
                return_by_value: None,
                generate_preview: None,
                throw_on_side_effect: None,
                timeout: None,
            }
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }

        pub fn with_include_command_line_api(
            mut self,
            include_command_line_api: impl Into<bool>,
        ) -> Self {
            self.include_command_line_api = Some(include_command_line_api.into());
            self
        }

        pub fn with_silent(mut self, silent: impl Into<bool>) -> Self {
            self.silent = Some(silent.into());
            self
        }

        pub fn with_return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
            self.return_by_value = Some(return_by_value.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }

        pub fn with_throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
            self.throw_on_side_effect = Some(throw_on_side_effect.into());
            self
        }

        pub fn with_timeout(mut self, timeout: impl Into<runtime::TimeDelta>) -> Self {
            self.timeout = Some(timeout.into());
            self
        }
    }

    impl Command for EvaluateOnCallFrame {
        type Response = EvaluateOnCallFrameResult;
        const METHOD: &'static str = "Debugger.evaluateOnCallFrame";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EvaluateOnCallFrameResult {
        /// Object wrapper for the evaluation result.
        pub result: runtime::RemoteObject,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<runtime::ExceptionDetails>,
    }

    /// Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPossibleBreakpoints {
        /// Start of range to search possible breakpoint locations in.
        start: Location,
        /// End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
        #[serde(skip_serializing_if = "Option::is_none")]
        end: Option<Location>,
        /// Only consider locations which are in the same (non-nested) function as start.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "restrictToFunction")]
        restrict_to_function: Option<bool>,
    }

    impl GetPossibleBreakpoints {
        pub fn new(start: impl Into<Location>) -> Self {
            Self {
                start: start.into(),
                end: None,
                restrict_to_function: None,
            }
        }

        pub fn with_end(mut self, end: impl Into<Location>) -> Self {
            self.end = Some(end.into());
            self
        }

        pub fn with_restrict_to_function(mut self, restrict_to_function: impl Into<bool>) -> Self {
            self.restrict_to_function = Some(restrict_to_function.into());
            self
        }
    }

    impl Command for GetPossibleBreakpoints {
        type Response = GetPossibleBreakpointsResult;
        const METHOD: &'static str = "Debugger.getPossibleBreakpoints";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPossibleBreakpointsResult {
        /// List of the possible breakpoint locations.
        pub locations: Vec<BreakLocation>,
    }

    /// Returns source for the script with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetScriptSource {
        /// Id of the script to get source for.
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
    }

    impl GetScriptSource {
        pub fn new(script_id: impl Into<runtime::ScriptId>) -> Self {
            Self {
                script_id: script_id.into(),
            }
        }
    }

    impl Command for GetScriptSource {
        type Response = GetScriptSourceResult;
        const METHOD: &'static str = "Debugger.getScriptSource";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetScriptSourceResult {
        /// Script source (empty in case of Wasm bytecode).
        #[serde(rename = "scriptSource")]
        pub script_source: String,
        /// Wasm bytecode. (Encoded as a base64 string when passed over JSON)
        pub bytecode: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DisassembleWasmModule {
        /// Id of the script to disassemble
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
    }

    impl DisassembleWasmModule {
        pub fn new(script_id: impl Into<runtime::ScriptId>) -> Self {
            Self {
                script_id: script_id.into(),
            }
        }
    }

    impl Command for DisassembleWasmModule {
        type Response = DisassembleWasmModuleResult;
        const METHOD: &'static str = "Debugger.disassembleWasmModule";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DisassembleWasmModuleResult {
        /// For large modules, return a stream from which additional chunks of disassembly can be read successively.
        #[serde(rename = "streamId")]
        pub stream_id: Option<String>,
        /// The total number of lines in the disassembly text.
        #[serde(rename = "totalNumberOfLines")]
        pub total_number_of_lines: i64,
        /// The offsets of all function bodies, in the format [start1, end1, start2, end2, ...] where all ends are exclusive.
        #[serde(rename = "functionBodyOffsets")]
        pub function_body_offsets: Vec<i64>,
        /// The first chunk of disassembly.
        pub chunk: WasmDisassemblyChunk,
    }

    /// Disassemble the next chunk of lines for the module corresponding to the stream. If disassembly is complete, this API will invalidate the streamId and return an empty chunk. Any subsequent calls for the now invalid stream will return errors.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NextWasmDisassemblyChunk {
        #[serde(rename = "streamId")]
        stream_id: String,
    }

    impl NextWasmDisassemblyChunk {
        pub fn new(stream_id: impl Into<String>) -> Self {
            Self {
                stream_id: stream_id.into(),
            }
        }
    }

    impl Command for NextWasmDisassemblyChunk {
        type Response = NextWasmDisassemblyChunkResult;
        const METHOD: &'static str = "Debugger.nextWasmDisassemblyChunk";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct NextWasmDisassemblyChunkResult {
        /// The next chunk of disassembly.
        pub chunk: WasmDisassemblyChunk,
    }

    /// This command is deprecated. Use getScriptSource instead.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWasmBytecode {
        /// Id of the Wasm script to get source for.
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
    }

    impl GetWasmBytecode {
        pub fn new(script_id: impl Into<runtime::ScriptId>) -> Self {
            Self {
                script_id: script_id.into(),
            }
        }
    }

    impl Command for GetWasmBytecode {
        type Response = GetWasmBytecodeResult;
        const METHOD: &'static str = "Debugger.getWasmBytecode";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetWasmBytecodeResult {
        /// Script source. (Encoded as a base64 string when passed over JSON)
        pub bytecode: String,
    }

    /// Returns stack trace with given `stackTraceId`.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStackTrace {
        #[serde(rename = "stackTraceId")]
        stack_trace_id: runtime::StackTraceId,
    }

    impl GetStackTrace {
        pub fn new(stack_trace_id: impl Into<runtime::StackTraceId>) -> Self {
            Self {
                stack_trace_id: stack_trace_id.into(),
            }
        }
    }

    impl Command for GetStackTrace {
        type Response = GetStackTraceResult;
        const METHOD: &'static str = "Debugger.getStackTrace";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetStackTraceResult {
        #[serde(rename = "stackTrace")]
        pub stack_trace: runtime::StackTrace,
    }

    /// Stops on the next JavaScript statement.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Pause {}

    impl Pause {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Pause {
        type Response = ();
        const METHOD: &'static str = "Debugger.pause";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[deprecated]
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PauseOnAsyncCall {
        /// Debugger will pause when async call with given stack trace is started.
        #[serde(rename = "parentStackTraceId")]
        parent_stack_trace_id: runtime::StackTraceId,
    }

    impl PauseOnAsyncCall {
        pub fn new(parent_stack_trace_id: impl Into<runtime::StackTraceId>) -> Self {
            Self {
                parent_stack_trace_id: parent_stack_trace_id.into(),
            }
        }
    }

    impl Command for PauseOnAsyncCall {
        type Response = ();
        const METHOD: &'static str = "Debugger.pauseOnAsyncCall";
    }

    /// Removes JavaScript breakpoint.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveBreakpoint {
        #[serde(rename = "breakpointId")]
        breakpoint_id: BreakpointId,
    }

    impl RemoveBreakpoint {
        pub fn new(breakpoint_id: impl Into<BreakpointId>) -> Self {
            Self {
                breakpoint_id: breakpoint_id.into(),
            }
        }
    }

    impl Command for RemoveBreakpoint {
        type Response = ();
        const METHOD: &'static str = "Debugger.removeBreakpoint";
    }

    /// Restarts particular call frame from the beginning. The old, deprecated behavior of `restartFrame` is to stay paused and allow further CDP commands after a restart was scheduled. This can cause problems with restarting, so we now continue execution immediatly after it has been scheduled until we reach the beginning of the restarted frame. To stay back-wards compatible, `restartFrame` now expects a `mode` parameter to be present. If the `mode` parameter is missing, `restartFrame` errors out. The various return values are deprecated and `callFrames` is always empty. Use the call frames from the `Debugger#paused` events instead, that fires once V8 pauses at the beginning of the restarted function.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RestartFrame {
        /// Call frame identifier to evaluate on.
        #[serde(rename = "callFrameId")]
        call_frame_id: CallFrameId,
        /// The `mode` parameter must be present and set to 'StepInto', otherwise `restartFrame` will error out.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        mode: Option<String>,
    }

    impl RestartFrame {
        pub fn new(call_frame_id: impl Into<CallFrameId>) -> Self {
            Self {
                call_frame_id: call_frame_id.into(),
                mode: None,
            }
        }

        pub fn with_mode(mut self, mode: impl Into<String>) -> Self {
            self.mode = Some(mode.into());
            self
        }
    }

    impl Command for RestartFrame {
        type Response = RestartFrameResult;
        const METHOD: &'static str = "Debugger.restartFrame";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RestartFrameResult {
        /// New stack trace.
        #[deprecated]
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        /// Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<runtime::StackTrace>,
        /// Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<runtime::StackTraceId>,
    }

    /// Resumes JavaScript execution.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Resume {
        /// Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "terminateOnResume")]
        terminate_on_resume: Option<bool>,
    }

    impl Resume {
        pub fn new() -> Self {
            Self {
                terminate_on_resume: None,
            }
        }

        pub fn with_terminate_on_resume(mut self, terminate_on_resume: impl Into<bool>) -> Self {
            self.terminate_on_resume = Some(terminate_on_resume.into());
            self
        }
    }

    impl Command for Resume {
        type Response = ();
        const METHOD: &'static str = "Debugger.resume";
    }

    /// Searches for given string in script content.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInContent {
        /// Id of the script to search in.
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
        /// String to search for.
        query: String,
        /// If true, search is case sensitive.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "caseSensitive")]
        case_sensitive: Option<bool>,
        /// If true, treats string parameter as regex.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isRegex")]
        is_regex: Option<bool>,
    }

    impl SearchInContent {
        pub fn new(script_id: impl Into<runtime::ScriptId>, query: impl Into<String>) -> Self {
            Self {
                script_id: script_id.into(),
                query: query.into(),
                case_sensitive: None,
                is_regex: None,
            }
        }

        pub fn with_case_sensitive(mut self, case_sensitive: impl Into<bool>) -> Self {
            self.case_sensitive = Some(case_sensitive.into());
            self
        }

        pub fn with_is_regex(mut self, is_regex: impl Into<bool>) -> Self {
            self.is_regex = Some(is_regex.into());
            self
        }
    }

    impl Command for SearchInContent {
        type Response = SearchInContentResult;
        const METHOD: &'static str = "Debugger.searchInContent";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SearchInContentResult {
        /// List of search matches.
        pub result: Vec<SearchMatch>,
    }

    /// Enables or disables async call stacks tracking.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAsyncCallStackDepth {
        /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async call stacks (default).
        #[serde(rename = "maxDepth")]
        max_depth: i64,
    }

    impl SetAsyncCallStackDepth {
        pub fn new(max_depth: impl Into<i64>) -> Self {
            Self {
                max_depth: max_depth.into(),
            }
        }
    }

    impl Command for SetAsyncCallStackDepth {
        type Response = ();
        const METHOD: &'static str = "Debugger.setAsyncCallStackDepth";
    }

    /// Replace previous blackbox execution contexts with passed ones. Forces backend to skip stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBlackboxExecutionContexts {
        /// Array of execution context unique ids for the debugger to ignore.
        #[serde(rename = "uniqueIds")]
        unique_ids: Vec<String>,
    }

    impl SetBlackboxExecutionContexts {
        pub fn new(unique_ids: impl Into<Vec<String>>) -> Self {
            Self {
                unique_ids: unique_ids.into(),
            }
        }
    }

    impl Command for SetBlackboxExecutionContexts {
        type Response = ();
        const METHOD: &'static str = "Debugger.setBlackboxExecutionContexts";
    }

    /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBlackboxPatterns {
        /// Array of regexps that will be used to check script url for blackbox state.
        patterns: Vec<String>,
        /// If true, also ignore scripts with no source url.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "skipAnonymous")]
        skip_anonymous: Option<bool>,
    }

    impl SetBlackboxPatterns {
        pub fn new(patterns: impl Into<Vec<String>>) -> Self {
            Self {
                patterns: patterns.into(),
                skip_anonymous: None,
            }
        }

        pub fn with_skip_anonymous(mut self, skip_anonymous: impl Into<bool>) -> Self {
            self.skip_anonymous = Some(skip_anonymous.into());
            self
        }
    }

    impl Command for SetBlackboxPatterns {
        type Response = ();
        const METHOD: &'static str = "Debugger.setBlackboxPatterns";
    }

    /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBlackboxedRanges {
        /// Id of the script.
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
        positions: Vec<ScriptPosition>,
    }

    impl SetBlackboxedRanges {
        pub fn new(
            script_id: impl Into<runtime::ScriptId>,
            positions: impl Into<Vec<ScriptPosition>>,
        ) -> Self {
            Self {
                script_id: script_id.into(),
                positions: positions.into(),
            }
        }
    }

    impl Command for SetBlackboxedRanges {
        type Response = ();
        const METHOD: &'static str = "Debugger.setBlackboxedRanges";
    }

    /// Sets JavaScript breakpoint at a given location.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpoint {
        /// Location to set breakpoint in.
        location: Location,
        /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        condition: Option<String>,
    }

    impl SetBreakpoint {
        pub fn new(location: impl Into<Location>) -> Self {
            Self {
                location: location.into(),
                condition: None,
            }
        }

        pub fn with_condition(mut self, condition: impl Into<String>) -> Self {
            self.condition = Some(condition.into());
            self
        }
    }

    impl Command for SetBreakpoint {
        type Response = SetBreakpointResult;
        const METHOD: &'static str = "Debugger.setBreakpoint";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointResult {
        /// Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        /// Location this breakpoint resolved into.
        #[serde(rename = "actualLocation")]
        pub actual_location: Location,
    }

    /// Sets instrumentation breakpoint.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInstrumentationBreakpoint {
        /// Instrumentation name.
        instrumentation: String,
    }

    impl SetInstrumentationBreakpoint {
        pub fn new(instrumentation: impl Into<String>) -> Self {
            Self {
                instrumentation: instrumentation.into(),
            }
        }
    }

    impl Command for SetInstrumentationBreakpoint {
        type Response = SetInstrumentationBreakpointResult;
        const METHOD: &'static str = "Debugger.setInstrumentationBreakpoint";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetInstrumentationBreakpointResult {
        /// Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
    }

    /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in `locations` property. Further matching script parsing will result in subsequent `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointByUrl {
        /// Line number to set breakpoint at.
        #[serde(rename = "lineNumber")]
        line_number: i64,
        /// URL of the resources to set breakpoint on.
        #[serde(skip_serializing_if = "Option::is_none")]
        url: Option<String>,
        /// Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or `urlRegex` must be specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "urlRegex")]
        url_regex: Option<String>,
        /// Script hash of the resources to set breakpoint on.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptHash")]
        script_hash: Option<String>,
        /// Offset in the line to set breakpoint at.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "columnNumber")]
        column_number: Option<i64>,
        /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        condition: Option<String>,
    }

    impl SetBreakpointByUrl {
        pub fn new(line_number: impl Into<i64>) -> Self {
            Self {
                line_number: line_number.into(),
                url: None,
                url_regex: None,
                script_hash: None,
                column_number: None,
                condition: None,
            }
        }

        pub fn with_url(mut self, url: impl Into<String>) -> Self {
            self.url = Some(url.into());
            self
        }

        pub fn with_url_regex(mut self, url_regex: impl Into<String>) -> Self {
            self.url_regex = Some(url_regex.into());
            self
        }

        pub fn with_script_hash(mut self, script_hash: impl Into<String>) -> Self {
            self.script_hash = Some(script_hash.into());
            self
        }

        pub fn with_column_number(mut self, column_number: impl Into<i64>) -> Self {
            self.column_number = Some(column_number.into());
            self
        }

        pub fn with_condition(mut self, condition: impl Into<String>) -> Self {
            self.condition = Some(condition.into());
            self
        }
    }

    impl Command for SetBreakpointByUrl {
        type Response = SetBreakpointByUrlResult;
        const METHOD: &'static str = "Debugger.setBreakpointByUrl";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointByUrlResult {
        /// Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        /// List of the locations this breakpoint resolved into upon addition.
        pub locations: Vec<Location>,
    }

    /// Sets JavaScript breakpoint before each call to the given function. If another function was created from the same source as a given one, calling it will also trigger the breakpoint.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointOnFunctionCall {
        /// Function object id.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
        /// Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
        #[serde(skip_serializing_if = "Option::is_none")]
        condition: Option<String>,
    }

    impl SetBreakpointOnFunctionCall {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
                condition: None,
            }
        }

        pub fn with_condition(mut self, condition: impl Into<String>) -> Self {
            self.condition = Some(condition.into());
            self
        }
    }

    impl Command for SetBreakpointOnFunctionCall {
        type Response = SetBreakpointOnFunctionCallResult;
        const METHOD: &'static str = "Debugger.setBreakpointOnFunctionCall";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointOnFunctionCallResult {
        /// Id of the created breakpoint for further reference.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
    }

    /// Activates / deactivates all breakpoints on the page.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetBreakpointsActive {
        /// New value for breakpoints active state.
        active: bool,
    }

    impl SetBreakpointsActive {
        pub fn new(active: impl Into<bool>) -> Self {
            Self {
                active: active.into(),
            }
        }
    }

    impl Command for SetBreakpointsActive {
        type Response = ();
        const METHOD: &'static str = "Debugger.setBreakpointsActive";
    }

    /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions, or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetPauseOnExceptions {
        /// Pause on exceptions mode.
        state: String,
    }

    impl SetPauseOnExceptions {
        pub fn new(state: impl Into<String>) -> Self {
            Self {
                state: state.into(),
            }
        }
    }

    impl Command for SetPauseOnExceptions {
        type Response = ();
        const METHOD: &'static str = "Debugger.setPauseOnExceptions";
    }

    /// Changes return value in top frame. Available only at return break position.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetReturnValue {
        /// New return value.
        #[serde(rename = "newValue")]
        new_value: runtime::CallArgument,
    }

    impl SetReturnValue {
        pub fn new(new_value: impl Into<runtime::CallArgument>) -> Self {
            Self {
                new_value: new_value.into(),
            }
        }
    }

    impl Command for SetReturnValue {
        type Response = ();
        const METHOD: &'static str = "Debugger.setReturnValue";
    }

    /// Edits JavaScript source live. In general, functions that are currently on the stack can not be edited with a single exception: If the edited function is the top-most stack frame and that is the only activation of that function on the stack. In this case the live edit will be successful and a `Debugger.restartFrame` for the top-most function is automatically triggered.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScriptSource {
        /// Id of the script to edit.
        #[serde(rename = "scriptId")]
        script_id: runtime::ScriptId,
        /// New content of the script.
        #[serde(rename = "scriptSource")]
        script_source: String,
        /// If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "dryRun")]
        dry_run: Option<bool>,
        /// If true, then `scriptSource` is allowed to change the function on top of the stack as long as the top-most stack frame is the only activation of that function.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "allowTopFrameEditing")]
        allow_top_frame_editing: Option<bool>,
    }

    impl SetScriptSource {
        pub fn new(
            script_id: impl Into<runtime::ScriptId>,
            script_source: impl Into<String>,
        ) -> Self {
            Self {
                script_id: script_id.into(),
                script_source: script_source.into(),
                dry_run: None,
                allow_top_frame_editing: None,
            }
        }

        pub fn with_dry_run(mut self, dry_run: impl Into<bool>) -> Self {
            self.dry_run = Some(dry_run.into());
            self
        }

        pub fn with_allow_top_frame_editing(
            mut self,
            allow_top_frame_editing: impl Into<bool>,
        ) -> Self {
            self.allow_top_frame_editing = Some(allow_top_frame_editing.into());
            self
        }
    }

    impl Command for SetScriptSource {
        type Response = SetScriptSourceResult;
        const METHOD: &'static str = "Debugger.setScriptSource";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetScriptSourceResult {
        /// New stack trace in case editing has happened while VM was stopped.
        #[deprecated]
        #[serde(rename = "callFrames")]
        pub call_frames: Option<Vec<CallFrame>>,
        /// Whether current call stack was modified after applying the changes.
        #[deprecated]
        #[serde(rename = "stackChanged")]
        pub stack_changed: Option<bool>,
        /// Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<runtime::StackTrace>,
        /// Async stack trace, if any.
        #[deprecated]
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<runtime::StackTraceId>,
        /// Whether the operation was successful or not. Only `Ok` denotes a successful live edit while the other enum variants denote why the live edit failed.
        /// **EXPERIMENTAL**
        pub status: Option<String>,
        /// Exception details if any. Only present when `status` is `CompileError`.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<runtime::ExceptionDetails>,
    }

    /// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSkipAllPauses {
        /// New value for skip pauses state.
        skip: bool,
    }

    impl SetSkipAllPauses {
        pub fn new(skip: impl Into<bool>) -> Self {
            Self { skip: skip.into() }
        }
    }

    impl Command for SetSkipAllPauses {
        type Response = ();
        const METHOD: &'static str = "Debugger.setSkipAllPauses";
    }

    /// Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetVariableValue {
        /// 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
        #[serde(rename = "scopeNumber")]
        scope_number: i64,
        /// Variable name.
        #[serde(rename = "variableName")]
        variable_name: String,
        /// New variable value.
        #[serde(rename = "newValue")]
        new_value: runtime::CallArgument,
        /// Id of callframe that holds variable.
        #[serde(rename = "callFrameId")]
        call_frame_id: CallFrameId,
    }

    impl SetVariableValue {
        pub fn new(
            scope_number: impl Into<i64>,
            variable_name: impl Into<String>,
            new_value: impl Into<runtime::CallArgument>,
            call_frame_id: impl Into<CallFrameId>,
        ) -> Self {
            Self {
                scope_number: scope_number.into(),
                variable_name: variable_name.into(),
                new_value: new_value.into(),
                call_frame_id: call_frame_id.into(),
            }
        }
    }

    impl Command for SetVariableValue {
        type Response = ();
        const METHOD: &'static str = "Debugger.setVariableValue";
    }

    /// Steps into the function call.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StepInto {
        /// Debugger will pause on the execution of the first async task which was scheduled before next pause.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "breakOnAsyncCall")]
        break_on_async_call: Option<bool>,
        /// The skipList specifies location ranges that should be skipped on step into.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "skipList")]
        skip_list: Option<Vec<LocationRange>>,
    }

    impl StepInto {
        pub fn new() -> Self {
            Self {
                break_on_async_call: None,
                skip_list: None,
            }
        }

        pub fn with_break_on_async_call(mut self, break_on_async_call: impl Into<bool>) -> Self {
            self.break_on_async_call = Some(break_on_async_call.into());
            self
        }

        pub fn with_skip_list(mut self, skip_list: impl Into<Vec<LocationRange>>) -> Self {
            self.skip_list = Some(skip_list.into());
            self
        }
    }

    impl Command for StepInto {
        type Response = ();
        const METHOD: &'static str = "Debugger.stepInto";
    }

    /// Steps out of the function call.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StepOut {}

    impl StepOut {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StepOut {
        type Response = ();
        const METHOD: &'static str = "Debugger.stepOut";
    }

    /// Steps over the statement.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StepOver {
        /// The skipList specifies location ranges that should be skipped on step over.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "skipList")]
        skip_list: Option<Vec<LocationRange>>,
    }

    impl StepOver {
        pub fn new() -> Self {
            Self { skip_list: None }
        }

        pub fn with_skip_list(mut self, skip_list: impl Into<Vec<LocationRange>>) -> Self {
            self.skip_list = Some(skip_list.into());
            self
        }
    }

    impl Command for StepOver {
        type Response = ();
        const METHOD: &'static str = "Debugger.stepOver";
    }

    /// Fired when breakpoint is resolved to an actual script and location. Deprecated in favor of `resolvedBreakpoints` in the `scriptParsed` event.
    #[deprecated]
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BreakpointResolved {
        /// Breakpoint unique identifier.
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: BreakpointId,
        /// Actual breakpoint location.
        pub location: Location,
    }

    impl BreakpointResolved {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Debugger.breakpointResolved")
        }
    }

    /// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Paused {
        /// Call stack the virtual machine stopped on.
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        /// Pause reason.
        pub reason: String,
        /// Object containing break-specific auxiliary properties.
        pub data: Option<serde_json::Value>,
        /// Hit breakpoints IDs
        #[serde(rename = "hitBreakpoints")]
        pub hit_breakpoints: Option<Vec<String>>,
        /// Async stack trace, if any.
        #[serde(rename = "asyncStackTrace")]
        pub async_stack_trace: Option<runtime::StackTrace>,
        /// Async stack trace, if any.
        /// **EXPERIMENTAL**
        #[serde(rename = "asyncStackTraceId")]
        pub async_stack_trace_id: Option<runtime::StackTraceId>,
        /// Never present, will be removed.
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(rename = "asyncCallStackTraceId")]
        pub async_call_stack_trace_id: Option<runtime::StackTraceId>,
    }

    impl Paused {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Debugger.paused")
        }
    }

    /// Fired when the virtual machine resumed execution.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Resumed {}

    impl Resumed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Debugger.resumed")
        }
    }

    /// Fired when virtual machine fails to parse the script.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScriptFailedToParse {
        /// Identifier of the script parsed.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// URL or name of the script parsed (if any).
        pub url: String,
        /// Line offset of the script within the resource with given URL (for script tags).
        #[serde(rename = "startLine")]
        pub start_line: i64,
        /// Column offset of the script within the resource with given URL.
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        /// Last line of the script.
        #[serde(rename = "endLine")]
        pub end_line: i64,
        /// Length of the last line of the script.
        #[serde(rename = "endColumn")]
        pub end_column: i64,
        /// Specifies script creation context.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: runtime::ExecutionContextId,
        /// Content hash of the script, SHA-256.
        pub hash: String,
        /// For Wasm modules, the content of the `build_id` custom section. For JavaScript the `debugId` magic comment.
        #[serde(rename = "buildId")]
        pub build_id: String,
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(rename = "executionContextAuxData")]
        pub execution_context_aux_data: Option<serde_json::Value>,
        /// URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        /// True, if this script has sourceURL.
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        /// True, if this script is ES6 module.
        #[serde(rename = "isModule")]
        pub is_module: Option<bool>,
        /// This script length.
        pub length: Option<i64>,
        /// JavaScript top stack frame of where the script parsed event was triggered if available.
        /// **EXPERIMENTAL**
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<runtime::StackTrace>,
        /// If the scriptLanguage is WebAssembly, the code section offset in the module.
        /// **EXPERIMENTAL**
        #[serde(rename = "codeOffset")]
        pub code_offset: Option<i64>,
        /// The language of the script.
        /// **EXPERIMENTAL**
        #[serde(rename = "scriptLanguage")]
        pub script_language: Option<debugger::ScriptLanguage>,
        /// The name the embedder supplied for this script.
        /// **EXPERIMENTAL**
        #[serde(rename = "embedderName")]
        pub embedder_name: Option<String>,
    }

    impl ScriptFailedToParse {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Debugger.scriptFailedToParse")
        }
    }

    /// Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScriptParsed {
        /// Identifier of the script parsed.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// URL or name of the script parsed (if any).
        pub url: String,
        /// Line offset of the script within the resource with given URL (for script tags).
        #[serde(rename = "startLine")]
        pub start_line: i64,
        /// Column offset of the script within the resource with given URL.
        #[serde(rename = "startColumn")]
        pub start_column: i64,
        /// Last line of the script.
        #[serde(rename = "endLine")]
        pub end_line: i64,
        /// Length of the last line of the script.
        #[serde(rename = "endColumn")]
        pub end_column: i64,
        /// Specifies script creation context.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: runtime::ExecutionContextId,
        /// Content hash of the script, SHA-256.
        pub hash: String,
        /// For Wasm modules, the content of the `build_id` custom section. For JavaScript the `debugId` magic comment.
        #[serde(rename = "buildId")]
        pub build_id: String,
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(rename = "executionContextAuxData")]
        pub execution_context_aux_data: Option<serde_json::Value>,
        /// True, if this script is generated as a result of the live edit operation.
        /// **EXPERIMENTAL**
        #[serde(rename = "isLiveEdit")]
        pub is_live_edit: Option<bool>,
        /// URL of source map associated with script (if any).
        #[serde(rename = "sourceMapURL")]
        pub source_map_url: Option<String>,
        /// True, if this script has sourceURL.
        #[serde(rename = "hasSourceURL")]
        pub has_source_url: Option<bool>,
        /// True, if this script is ES6 module.
        #[serde(rename = "isModule")]
        pub is_module: Option<bool>,
        /// This script length.
        pub length: Option<i64>,
        /// JavaScript top stack frame of where the script parsed event was triggered if available.
        /// **EXPERIMENTAL**
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<runtime::StackTrace>,
        /// If the scriptLanguage is WebAssembly, the code section offset in the module.
        /// **EXPERIMENTAL**
        #[serde(rename = "codeOffset")]
        pub code_offset: Option<i64>,
        /// The language of the script.
        /// **EXPERIMENTAL**
        #[serde(rename = "scriptLanguage")]
        pub script_language: Option<debugger::ScriptLanguage>,
        /// If the scriptLanguage is WebAssembly, the source of debug symbols for the module.
        /// **EXPERIMENTAL**
        #[serde(rename = "debugSymbols")]
        pub debug_symbols: Option<Vec<debugger::DebugSymbols>>,
        /// The name the embedder supplied for this script.
        /// **EXPERIMENTAL**
        #[serde(rename = "embedderName")]
        pub embedder_name: Option<String>,
        /// The list of set breakpoints in this script if calls to `setBreakpointByUrl` matches this script's URL or hash. Clients that use this list can ignore the `breakpointResolved` event. They are equivalent.
        /// **EXPERIMENTAL**
        #[serde(rename = "resolvedBreakpoints")]
        pub resolved_breakpoints: Option<Vec<ResolvedBreakpoint>>,
    }

    impl ScriptParsed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Debugger.scriptParsed")
        }
    }
}

pub mod heap_profiler {
    use super::*;

    /// Heap snapshot object id.
    pub type HeapSnapshotObjectId = String;

    /// Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SamplingHeapProfileNode {
        /// Function location.
        #[serde(rename = "callFrame")]
        pub call_frame: runtime::CallFrame,
        /// Allocations size in bytes for the node excluding children.
        #[serde(rename = "selfSize")]
        pub self_size: f64,
        /// Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
        pub id: i64,
        /// Child nodes.
        pub children: Vec<SamplingHeapProfileNode>,
    }

    /// A single sample from a sampling profile.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SamplingHeapProfileSample {
        /// Allocation size in bytes attributed to the sample.
        pub size: f64,
        /// Id of the corresponding profile tree node.
        #[serde(rename = "nodeId")]
        pub node_id: i64,
        /// Time-ordered sample ordinal number. It is unique across all profiles retrieved between startSampling and stopSampling.
        pub ordinal: f64,
    }

    /// Sampling profile.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SamplingHeapProfile {
        pub head: SamplingHeapProfileNode,
        pub samples: Vec<SamplingHeapProfileSample>,
    }

    /// Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddInspectedHeapObject {
        /// Heap snapshot object id to be accessible by means of $x command line API.
        #[serde(rename = "heapObjectId")]
        heap_object_id: HeapSnapshotObjectId,
    }

    impl AddInspectedHeapObject {
        pub fn new(heap_object_id: impl Into<HeapSnapshotObjectId>) -> Self {
            Self {
                heap_object_id: heap_object_id.into(),
            }
        }
    }

    impl Command for AddInspectedHeapObject {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.addInspectedHeapObject";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CollectGarbage {}

    impl CollectGarbage {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for CollectGarbage {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.collectGarbage";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.disable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.enable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHeapObjectId {
        /// Identifier of the object to get heap object id for.
        #[serde(rename = "objectId")]
        object_id: runtime::RemoteObjectId,
    }

    impl GetHeapObjectId {
        pub fn new(object_id: impl Into<runtime::RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
            }
        }
    }

    impl Command for GetHeapObjectId {
        type Response = GetHeapObjectIdResult;
        const METHOD: &'static str = "HeapProfiler.getHeapObjectId";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHeapObjectIdResult {
        /// Id of the heap snapshot object corresponding to the passed remote object id.
        #[serde(rename = "heapSnapshotObjectId")]
        pub heap_snapshot_object_id: HeapSnapshotObjectId,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetObjectByHeapObjectId {
        #[serde(rename = "objectId")]
        object_id: HeapSnapshotObjectId,
        /// Symbolic group name that can be used to release multiple objects.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
    }

    impl GetObjectByHeapObjectId {
        pub fn new(object_id: impl Into<HeapSnapshotObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
                object_group: None,
            }
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }
    }

    impl Command for GetObjectByHeapObjectId {
        type Response = GetObjectByHeapObjectIdResult;
        const METHOD: &'static str = "HeapProfiler.getObjectByHeapObjectId";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetObjectByHeapObjectIdResult {
        /// Evaluation result.
        pub result: runtime::RemoteObject,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSamplingProfile {}

    impl GetSamplingProfile {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetSamplingProfile {
        type Response = GetSamplingProfileResult;
        const METHOD: &'static str = "HeapProfiler.getSamplingProfile";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetSamplingProfileResult {
        /// Return the sampling profile being collected.
        pub profile: SamplingHeapProfile,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartSampling {
        /// Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "samplingInterval")]
        sampling_interval: Option<f64>,
        /// Maximum stack depth. The default value is 128.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "stackDepth")]
        stack_depth: Option<f64>,
        /// By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by major GC, which will show which functions cause large temporary memory usage or long GC pauses.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeObjectsCollectedByMajorGC")]
        include_objects_collected_by_major_gc: Option<bool>,
        /// By default, the sampling heap profiler reports only objects which are still alive when the profile is returned via getSamplingProfile or stopSampling, which is useful for determining what functions contribute the most to steady-state memory usage. This flag instructs the sampling heap profiler to also include information about objects discarded by minor GC, which is useful when tuning a latency-sensitive application for minimal GC activity.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeObjectsCollectedByMinorGC")]
        include_objects_collected_by_minor_gc: Option<bool>,
    }

    impl StartSampling {
        pub fn new() -> Self {
            Self {
                sampling_interval: None,
                stack_depth: None,
                include_objects_collected_by_major_gc: None,
                include_objects_collected_by_minor_gc: None,
            }
        }

        pub fn with_sampling_interval(mut self, sampling_interval: impl Into<f64>) -> Self {
            self.sampling_interval = Some(sampling_interval.into());
            self
        }

        pub fn with_stack_depth(mut self, stack_depth: impl Into<f64>) -> Self {
            self.stack_depth = Some(stack_depth.into());
            self
        }

        pub fn with_include_objects_collected_by_major_gc(
            mut self,
            include_objects_collected_by_major_gc: impl Into<bool>,
        ) -> Self {
            self.include_objects_collected_by_major_gc =
                Some(include_objects_collected_by_major_gc.into());
            self
        }

        pub fn with_include_objects_collected_by_minor_gc(
            mut self,
            include_objects_collected_by_minor_gc: impl Into<bool>,
        ) -> Self {
            self.include_objects_collected_by_minor_gc =
                Some(include_objects_collected_by_minor_gc.into());
            self
        }
    }

    impl Command for StartSampling {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.startSampling";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartTrackingHeapObjects {
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "trackAllocations")]
        track_allocations: Option<bool>,
    }

    impl StartTrackingHeapObjects {
        pub fn new() -> Self {
            Self {
                track_allocations: None,
            }
        }

        pub fn with_track_allocations(mut self, track_allocations: impl Into<bool>) -> Self {
            self.track_allocations = Some(track_allocations.into());
            self
        }
    }

    impl Command for StartTrackingHeapObjects {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.startTrackingHeapObjects";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopSampling {}

    impl StopSampling {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopSampling {
        type Response = StopSamplingResult;
        const METHOD: &'static str = "HeapProfiler.stopSampling";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopSamplingResult {
        /// Recorded sampling heap profile.
        pub profile: SamplingHeapProfile,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopTrackingHeapObjects {
        /// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportProgress")]
        report_progress: Option<bool>,
        /// Deprecated in favor of `exposeInternals`.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "treatGlobalObjectsAsRoots")]
        treat_global_objects_as_roots: Option<bool>,
        /// If true, numerical values are included in the snapshot
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "captureNumericValue")]
        capture_numeric_value: Option<bool>,
        /// If true, exposes internals of the snapshot.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "exposeInternals")]
        expose_internals: Option<bool>,
    }

    impl StopTrackingHeapObjects {
        pub fn new() -> Self {
            Self {
                report_progress: None,
                treat_global_objects_as_roots: None,
                capture_numeric_value: None,
                expose_internals: None,
            }
        }

        pub fn with_report_progress(mut self, report_progress: impl Into<bool>) -> Self {
            self.report_progress = Some(report_progress.into());
            self
        }

        pub fn with_treat_global_objects_as_roots(
            mut self,
            treat_global_objects_as_roots: impl Into<bool>,
        ) -> Self {
            self.treat_global_objects_as_roots = Some(treat_global_objects_as_roots.into());
            self
        }

        pub fn with_capture_numeric_value(
            mut self,
            capture_numeric_value: impl Into<bool>,
        ) -> Self {
            self.capture_numeric_value = Some(capture_numeric_value.into());
            self
        }

        pub fn with_expose_internals(mut self, expose_internals: impl Into<bool>) -> Self {
            self.expose_internals = Some(expose_internals.into());
            self
        }
    }

    impl Command for StopTrackingHeapObjects {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.stopTrackingHeapObjects";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakeHeapSnapshot {
        /// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "reportProgress")]
        report_progress: Option<bool>,
        /// If true, a raw snapshot without artificial roots will be generated. Deprecated in favor of `exposeInternals`.
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "treatGlobalObjectsAsRoots")]
        treat_global_objects_as_roots: Option<bool>,
        /// If true, numerical values are included in the snapshot
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "captureNumericValue")]
        capture_numeric_value: Option<bool>,
        /// If true, exposes internals of the snapshot.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "exposeInternals")]
        expose_internals: Option<bool>,
    }

    impl TakeHeapSnapshot {
        pub fn new() -> Self {
            Self {
                report_progress: None,
                treat_global_objects_as_roots: None,
                capture_numeric_value: None,
                expose_internals: None,
            }
        }

        pub fn with_report_progress(mut self, report_progress: impl Into<bool>) -> Self {
            self.report_progress = Some(report_progress.into());
            self
        }

        pub fn with_treat_global_objects_as_roots(
            mut self,
            treat_global_objects_as_roots: impl Into<bool>,
        ) -> Self {
            self.treat_global_objects_as_roots = Some(treat_global_objects_as_roots.into());
            self
        }

        pub fn with_capture_numeric_value(
            mut self,
            capture_numeric_value: impl Into<bool>,
        ) -> Self {
            self.capture_numeric_value = Some(capture_numeric_value.into());
            self
        }

        pub fn with_expose_internals(mut self, expose_internals: impl Into<bool>) -> Self {
            self.expose_internals = Some(expose_internals.into());
            self
        }
    }

    impl Command for TakeHeapSnapshot {
        type Response = ();
        const METHOD: &'static str = "HeapProfiler.takeHeapSnapshot";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddHeapSnapshotChunk {
        pub chunk: String,
    }

    impl AddHeapSnapshotChunk {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("HeapProfiler.addHeapSnapshotChunk")
        }
    }

    /// If heap objects tracking has been started then backend may send update for one or more fragments
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct HeapStatsUpdate {
        /// An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.
        #[serde(rename = "statsUpdate")]
        pub stats_update: Vec<i64>,
    }

    impl HeapStatsUpdate {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("HeapProfiler.heapStatsUpdate")
        }
    }

    /// If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct LastSeenObjectId {
        #[serde(rename = "lastSeenObjectId")]
        pub last_seen_object_id: i64,
        pub timestamp: f64,
    }

    impl LastSeenObjectId {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("HeapProfiler.lastSeenObjectId")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReportHeapSnapshotProgress {
        pub done: i64,
        pub total: i64,
        pub finished: Option<bool>,
    }

    impl ReportHeapSnapshotProgress {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("HeapProfiler.reportHeapSnapshotProgress")
        }
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ResetProfiles {}

    impl ResetProfiles {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("HeapProfiler.resetProfiles")
        }
    }
}

pub mod profiler {
    use super::*;

    /// Profile node. Holds callsite information, execution statistics and child nodes.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ProfileNode {
        /// Unique id of the node.
        pub id: i64,
        /// Function location.
        #[serde(rename = "callFrame")]
        pub call_frame: runtime::CallFrame,
        /// Number of samples where this node was on top of the call stack.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "hitCount")]
        pub hit_count: Option<i64>,
        /// Child node ids.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub children: Option<Vec<i64>>,
        /// The reason of being not optimized. The function may be deoptimized or marked as don't optimize.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deoptReason")]
        pub deopt_reason: Option<String>,
        /// An array of source position ticks.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "positionTicks")]
        pub position_ticks: Option<Vec<PositionTickInfo>>,
    }

    /// Profile.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Profile {
        /// The list of profile nodes. First item is the root node.
        pub nodes: Vec<ProfileNode>,
        /// Profiling start timestamp in microseconds.
        #[serde(rename = "startTime")]
        pub start_time: f64,
        /// Profiling end timestamp in microseconds.
        #[serde(rename = "endTime")]
        pub end_time: f64,
        /// Ids of samples top nodes.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub samples: Option<Vec<i64>>,
        /// Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "timeDeltas")]
        pub time_deltas: Option<Vec<i64>>,
    }

    /// Specifies a number of samples attributed to a certain source position.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PositionTickInfo {
        /// Source line number (1-based).
        pub line: i64,
        /// Number of samples attributed to the source line.
        pub ticks: i64,
    }

    /// Coverage data for a source range.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CoverageRange {
        /// JavaScript script source offset for the range start.
        #[serde(rename = "startOffset")]
        pub start_offset: i64,
        /// JavaScript script source offset for the range end.
        #[serde(rename = "endOffset")]
        pub end_offset: i64,
        /// Collected execution count of the source range.
        pub count: i64,
    }

    /// Coverage data for a JavaScript function.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct FunctionCoverage {
        /// JavaScript function name.
        #[serde(rename = "functionName")]
        pub function_name: String,
        /// Source ranges inside the function with coverage data.
        pub ranges: Vec<CoverageRange>,
        /// Whether coverage data for this function has block granularity.
        #[serde(rename = "isBlockCoverage")]
        pub is_block_coverage: bool,
    }

    /// Coverage data for a JavaScript script.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ScriptCoverage {
        /// JavaScript script id.
        #[serde(rename = "scriptId")]
        pub script_id: runtime::ScriptId,
        /// JavaScript script name or url.
        pub url: String,
        /// Functions contained in the script that has coverage data.
        pub functions: Vec<FunctionCoverage>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Profiler.disable";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Profiler.enable";
    }

    /// Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBestEffortCoverage {}

    impl GetBestEffortCoverage {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetBestEffortCoverage {
        type Response = GetBestEffortCoverageResult;
        const METHOD: &'static str = "Profiler.getBestEffortCoverage";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetBestEffortCoverageResult {
        /// Coverage data for the current isolate.
        pub result: Vec<ScriptCoverage>,
    }

    /// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetSamplingInterval {
        /// New sampling interval in microseconds.
        interval: i64,
    }

    impl SetSamplingInterval {
        pub fn new(interval: impl Into<i64>) -> Self {
            Self {
                interval: interval.into(),
            }
        }
    }

    impl Command for SetSamplingInterval {
        type Response = ();
        const METHOD: &'static str = "Profiler.setSamplingInterval";
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Start {}

    impl Start {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Start {
        type Response = ();
        const METHOD: &'static str = "Profiler.start";
    }

    /// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartPreciseCoverage {
        /// Collect accurate call counts beyond simple 'covered' or 'not covered'.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "callCount")]
        call_count: Option<bool>,
        /// Collect block-based coverage.
        #[serde(skip_serializing_if = "Option::is_none")]
        detailed: Option<bool>,
        /// Allow the backend to send updates on its own initiative
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "allowTriggeredUpdates")]
        allow_triggered_updates: Option<bool>,
    }

    impl StartPreciseCoverage {
        pub fn new() -> Self {
            Self {
                call_count: None,
                detailed: None,
                allow_triggered_updates: None,
            }
        }

        pub fn with_call_count(mut self, call_count: impl Into<bool>) -> Self {
            self.call_count = Some(call_count.into());
            self
        }

        pub fn with_detailed(mut self, detailed: impl Into<bool>) -> Self {
            self.detailed = Some(detailed.into());
            self
        }

        pub fn with_allow_triggered_updates(
            mut self,
            allow_triggered_updates: impl Into<bool>,
        ) -> Self {
            self.allow_triggered_updates = Some(allow_triggered_updates.into());
            self
        }
    }

    impl Command for StartPreciseCoverage {
        type Response = StartPreciseCoverageResult;
        const METHOD: &'static str = "Profiler.startPreciseCoverage";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StartPreciseCoverageResult {
        /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        pub timestamp: f64,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Stop {}

    impl Stop {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Stop {
        type Response = StopResult;
        const METHOD: &'static str = "Profiler.stop";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopResult {
        /// Recorded profile.
        pub profile: Profile,
    }

    /// Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StopPreciseCoverage {}

    impl StopPreciseCoverage {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for StopPreciseCoverage {
        type Response = ();
        const METHOD: &'static str = "Profiler.stopPreciseCoverage";
    }

    /// Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakePreciseCoverage {}

    impl TakePreciseCoverage {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for TakePreciseCoverage {
        type Response = TakePreciseCoverageResult;
        const METHOD: &'static str = "Profiler.takePreciseCoverage";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TakePreciseCoverageResult {
        /// Coverage data for the current isolate.
        pub result: Vec<ScriptCoverage>,
        /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        pub timestamp: f64,
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConsoleProfileFinished {
        pub id: String,
        /// Location of console.profileEnd().
        pub location: debugger::Location,
        pub profile: Profile,
        /// Profile title passed as an argument to console.profile().
        pub title: Option<String>,
    }

    impl ConsoleProfileFinished {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Profiler.consoleProfileFinished")
        }
    }

    /// Sent when new profile recording is started using console.profile() call.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConsoleProfileStarted {
        pub id: String,
        /// Location of console.profile().
        pub location: debugger::Location,
        /// Profile title passed as an argument to console.profile().
        pub title: Option<String>,
    }

    impl ConsoleProfileStarted {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Profiler.consoleProfileStarted")
        }
    }

    /// Reports coverage delta since the last poll (either from an event like this, or from `takePreciseCoverage` for the current isolate. May only be sent if precise code coverage has been started. This event can be trigged by the embedder to, for example, trigger collection of coverage data immediately at a certain point in time.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PreciseCoverageDeltaUpdate {
        /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
        pub timestamp: f64,
        /// Identifier for distinguishing coverage events.
        pub occasion: String,
        /// Coverage data for the current isolate.
        pub result: Vec<ScriptCoverage>,
    }

    impl PreciseCoverageDeltaUpdate {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner
                .event_stream("Profiler.preciseCoverageDeltaUpdate")
        }
    }
}

pub mod runtime {
    use super::*;

    /// Unique script identifier.
    pub type ScriptId = String;

    /// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SerializationOptions {
        pub serialization: String,
        /// Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "maxDepth")]
        pub max_depth: Option<i64>,
        /// Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`. Values can be only of type string or integer.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "additionalParameters")]
        pub additional_parameters: Option<serde_json::Value>,
    }

    /// Represents deep serialized value.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DeepSerializedValue {
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<serde_json::Value>,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        pub object_id: Option<String>,
        /// Set if value reference met more then once during serialization. In such case, value is provided only to one of the serialized values. Unique per value in the scope of one CDP call.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "weakLocalObjectReference")]
        pub weak_local_object_reference: Option<i64>,
    }

    /// Unique object identifier.
    pub type RemoteObjectId = String;

    /// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
    pub type UnserializableValue = String;

    /// Mirror object referencing original JavaScript object.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoteObject {
        /// Object type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Object subtype hint. Specified for `object` type values only. NOTE: If you change anything here, make sure to also update `subtype` in `ObjectPreview` and `PropertyPreview` below.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub subtype: Option<String>,
        /// Object class (constructor) name. Specified for `object` type values only.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "className")]
        pub class_name: Option<String>,
        /// Remote object value in case of primitive values or JSON values (if it was requested).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<serde_json::Value>,
        /// Primitive value which can not be JSON-stringified does not have `value`, but gets this property.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "unserializableValue")]
        pub unserializable_value: Option<UnserializableValue>,
        /// String representation of the object.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        /// Deep serialized value.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "deepSerializedValue")]
        pub deep_serialized_value: Option<DeepSerializedValue>,
        /// Unique object identifier (for non-primitive values).
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        pub object_id: Option<RemoteObjectId>,
        /// Preview containing abbreviated property values. Specified for `object` type values only.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        pub preview: Option<ObjectPreview>,
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "customPreview")]
        pub custom_preview: Option<CustomPreview>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CustomPreview {
        /// The JSON-stringified result of formatter.header(object, config) call. It contains json ML array that represents RemoteObject.
        pub header: String,
        /// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will contain RemoteObjectId for the function that returns result of formatter.body(object, config) call. The result value is json ML array.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "bodyGetterId")]
        pub body_getter_id: Option<RemoteObjectId>,
    }

    /// Object containing abbreviated remote object value.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ObjectPreview {
        /// Object type.
        #[serde(rename = "type")]
        pub type_: String,
        /// Object subtype hint. Specified for `object` type values only.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub subtype: Option<String>,
        /// String representation of the object.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        /// True iff some of the properties or entries of the original object did not fit.
        pub overflow: bool,
        /// List of the properties.
        pub properties: Vec<PropertyPreview>,
        /// List of the entries. Specified for `map` and `set` subtype values only.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub entries: Option<Vec<EntryPreview>>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PropertyPreview {
        /// Property name.
        pub name: String,
        /// Object type. Accessor means that the property itself is an accessor property.
        #[serde(rename = "type")]
        pub type_: String,
        /// User-friendly property value string.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
        /// Nested value preview.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "valuePreview")]
        pub value_preview: Option<ObjectPreview>,
        /// Object subtype hint. Specified for `object` type values only.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub subtype: Option<String>,
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EntryPreview {
        /// Preview of the key. Specified for map-like collection entries.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub key: Option<ObjectPreview>,
        /// Preview of the value.
        pub value: ObjectPreview,
    }

    /// Object property descriptor.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PropertyDescriptor {
        /// Property name or symbol description.
        pub name: String,
        /// The value associated with the property.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<RemoteObject>,
        /// True if the value associated with the property may be changed (data descriptors only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub writable: Option<bool>,
        /// A function which serves as a getter for the property, or `undefined` if there is no getter (accessor descriptors only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub get: Option<RemoteObject>,
        /// A function which serves as a setter for the property, or `undefined` if there is no setter (accessor descriptors only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub set: Option<RemoteObject>,
        /// True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
        pub configurable: bool,
        /// True if this property shows up during enumeration of the properties on the corresponding object.
        pub enumerable: bool,
        /// True if the result was thrown during the evaluation.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "wasThrown")]
        pub was_thrown: Option<bool>,
        /// True if the property is owned for the object.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "isOwn")]
        pub is_own: Option<bool>,
        /// Property symbol object, if the property is of the `symbol` type.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub symbol: Option<RemoteObject>,
    }

    /// Object internal property descriptor. This property isn't normally visible in JavaScript code.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InternalPropertyDescriptor {
        /// Conventional property name.
        pub name: String,
        /// The value associated with the property.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<RemoteObject>,
    }

    /// Object private field descriptor.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct PrivatePropertyDescriptor {
        /// Private property name.
        pub name: String,
        /// The value associated with the private property.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<RemoteObject>,
        /// A function which serves as a getter for the private property, or `undefined` if there is no getter (accessor descriptors only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub get: Option<RemoteObject>,
        /// A function which serves as a setter for the private property, or `undefined` if there is no setter (accessor descriptors only).
        #[serde(skip_serializing_if = "Option::is_none")]
        pub set: Option<RemoteObject>,
    }

    /// Represents function call argument. Either remote object id `objectId`, primitive `value`, unserializable primitive value or neither of (for undefined) them should be specified.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CallArgument {
        /// Primitive value or serializable javascript object.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub value: Option<serde_json::Value>,
        /// Primitive value which can not be JSON-stringified.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "unserializableValue")]
        pub unserializable_value: Option<UnserializableValue>,
        /// Remote object handle.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        pub object_id: Option<RemoteObjectId>,
    }

    /// Id of an execution context.
    pub type ExecutionContextId = i64;

    /// Description of an isolated world.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExecutionContextDescription {
        /// Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
        pub id: ExecutionContextId,
        /// Execution context origin.
        pub origin: String,
        /// Human readable name describing given context.
        pub name: String,
        /// A system-unique execution context identifier. Unlike the id, this is unique across multiple processes, so can be reliably used to identify specific context while backend performs a cross-process navigation.
        /// **EXPERIMENTAL**
        #[serde(rename = "uniqueId")]
        pub unique_id: String,
        /// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "auxData")]
        pub aux_data: Option<serde_json::Value>,
    }

    /// Detailed information about exception (or error) that was thrown during script compilation or execution.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExceptionDetails {
        /// Exception id.
        #[serde(rename = "exceptionId")]
        pub exception_id: i64,
        /// Exception text, which should be used together with exception object when available.
        pub text: String,
        /// Line number of the exception location (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// Column number of the exception location (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
        /// Script ID of the exception location.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "scriptId")]
        pub script_id: Option<ScriptId>,
        /// URL of the exception location, to be used when the script was not reported.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        /// JavaScript stack trace if available.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<StackTrace>,
        /// Exception object if available.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub exception: Option<RemoteObject>,
        /// Identifier of the context where exception happened.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
        /// Dictionary with entries of meta data that the client associated with this exception, such as information about associated network requests, etc.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "exceptionMetaData")]
        pub exception_meta_data: Option<serde_json::Value>,
    }

    /// Number of milliseconds since epoch.
    pub type Timestamp = f64;

    /// Number of milliseconds.
    pub type TimeDelta = f64;

    /// Stack entry for runtime errors and assertions.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CallFrame {
        /// JavaScript function name.
        #[serde(rename = "functionName")]
        pub function_name: String,
        /// JavaScript script id.
        #[serde(rename = "scriptId")]
        pub script_id: ScriptId,
        /// JavaScript script name or url.
        pub url: String,
        /// JavaScript script line number (0-based).
        #[serde(rename = "lineNumber")]
        pub line_number: i64,
        /// JavaScript script column number (0-based).
        #[serde(rename = "columnNumber")]
        pub column_number: i64,
    }

    /// Call frames for assertions or error messages.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StackTrace {
        /// String label of this stack trace. For async traces this may be a name of the function that initiated the async call.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        /// JavaScript function name.
        #[serde(rename = "callFrames")]
        pub call_frames: Vec<CallFrame>,
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub parent: Option<Box<StackTrace>>,
        /// Asynchronous JavaScript stack trace that preceded this stack, if available.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "parentId")]
        pub parent_id: Option<StackTraceId>,
    }

    /// Unique identifier of current debugger.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    pub type UniqueDebuggerId = String;

    /// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct StackTraceId {
        pub id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "debuggerId")]
        pub debugger_id: Option<UniqueDebuggerId>,
    }

    /// Add handler to promise with given promise object id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AwaitPromise {
        /// Identifier of the promise.
        #[serde(rename = "promiseObjectId")]
        promise_object_id: RemoteObjectId,
        /// Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnByValue")]
        return_by_value: Option<bool>,
        /// Whether preview should be generated for the result.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
    }

    impl AwaitPromise {
        pub fn new(promise_object_id: impl Into<RemoteObjectId>) -> Self {
            Self {
                promise_object_id: promise_object_id.into(),
                return_by_value: None,
                generate_preview: None,
            }
        }

        pub fn with_return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
            self.return_by_value = Some(return_by_value.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }
    }

    impl Command for AwaitPromise {
        type Response = AwaitPromiseResult;
        const METHOD: &'static str = "Runtime.awaitPromise";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AwaitPromiseResult {
        /// Promise result. Will contain rejected value if promise was rejected.
        pub result: RemoteObject,
        /// Exception details if stack strace is available.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CallFunctionOn {
        /// Declaration of the function to call.
        #[serde(rename = "functionDeclaration")]
        function_declaration: String,
        /// Identifier of the object to call function on. Either objectId or executionContextId should be specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectId")]
        object_id: Option<RemoteObjectId>,
        /// Call arguments. All call arguments must belong to the same JavaScript world as the target object.
        #[serde(skip_serializing_if = "Option::is_none")]
        arguments: Option<Vec<CallArgument>>,
        /// In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
        #[serde(skip_serializing_if = "Option::is_none")]
        silent: Option<bool>,
        /// Whether the result is expected to be a JSON object which should be sent by value. Can be overriden by `serializationOptions`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnByValue")]
        return_by_value: Option<bool>,
        /// Whether preview should be generated for the result.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
        /// Whether execution should be treated as initiated by user in the UI.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userGesture")]
        user_gesture: Option<bool>,
        /// Whether execution should `await` for resulting value and return once awaited promise is resolved.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "awaitPromise")]
        await_promise: Option<bool>,
        /// Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<ExecutionContextId>,
        /// Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
        /// Whether to throw an exception if side effect cannot be ruled out during evaluation.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "throwOnSideEffect")]
        throw_on_side_effect: Option<bool>,
        /// An alternative way to specify the execution context to call function on. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental function call in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with `executionContextId`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "uniqueContextId")]
        unique_context_id: Option<String>,
        /// Specifies the result serialization. If provided, overrides `generatePreview` and `returnByValue`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serializationOptions")]
        serialization_options: Option<SerializationOptions>,
    }

    impl CallFunctionOn {
        pub fn new(function_declaration: impl Into<String>) -> Self {
            Self {
                function_declaration: function_declaration.into(),
                object_id: None,
                arguments: None,
                silent: None,
                return_by_value: None,
                generate_preview: None,
                user_gesture: None,
                await_promise: None,
                execution_context_id: None,
                object_group: None,
                throw_on_side_effect: None,
                unique_context_id: None,
                serialization_options: None,
            }
        }

        pub fn with_object_id(mut self, object_id: impl Into<RemoteObjectId>) -> Self {
            self.object_id = Some(object_id.into());
            self
        }

        pub fn with_arguments(mut self, arguments: impl Into<Vec<CallArgument>>) -> Self {
            self.arguments = Some(arguments.into());
            self
        }

        pub fn with_silent(mut self, silent: impl Into<bool>) -> Self {
            self.silent = Some(silent.into());
            self
        }

        pub fn with_return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
            self.return_by_value = Some(return_by_value.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }

        pub fn with_user_gesture(mut self, user_gesture: impl Into<bool>) -> Self {
            self.user_gesture = Some(user_gesture.into());
            self
        }

        pub fn with_await_promise(mut self, await_promise: impl Into<bool>) -> Self {
            self.await_promise = Some(await_promise.into());
            self
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }

        pub fn with_throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
            self.throw_on_side_effect = Some(throw_on_side_effect.into());
            self
        }

        pub fn with_unique_context_id(mut self, unique_context_id: impl Into<String>) -> Self {
            self.unique_context_id = Some(unique_context_id.into());
            self
        }

        pub fn with_serialization_options(
            mut self,
            serialization_options: impl Into<SerializationOptions>,
        ) -> Self {
            self.serialization_options = Some(serialization_options.into());
            self
        }
    }

    impl Command for CallFunctionOn {
        type Response = CallFunctionOnResult;
        const METHOD: &'static str = "Runtime.callFunctionOn";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CallFunctionOnResult {
        /// Call result.
        pub result: RemoteObject,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Compiles expression.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompileScript {
        /// Expression to compile.
        expression: String,
        /// Source url to be set for the script.
        #[serde(rename = "sourceURL")]
        source_url: String,
        /// Specifies whether the compiled script should be persisted.
        #[serde(rename = "persistScript")]
        persist_script: bool,
        /// Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<ExecutionContextId>,
    }

    impl CompileScript {
        pub fn new(
            expression: impl Into<String>,
            source_url: impl Into<String>,
            persist_script: impl Into<bool>,
        ) -> Self {
            Self {
                expression: expression.into(),
                source_url: source_url.into(),
                persist_script: persist_script.into(),
                execution_context_id: None,
            }
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }
    }

    impl Command for CompileScript {
        type Response = CompileScriptResult;
        const METHOD: &'static str = "Runtime.compileScript";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct CompileScriptResult {
        /// Id of the script.
        #[serde(rename = "scriptId")]
        pub script_id: Option<ScriptId>,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Disables reporting of execution contexts creation.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Disable {}

    impl Disable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Disable {
        type Response = ();
        const METHOD: &'static str = "Runtime.disable";
    }

    /// Discards collected exceptions and console API calls.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct DiscardConsoleEntries {}

    impl DiscardConsoleEntries {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for DiscardConsoleEntries {
        type Response = ();
        const METHOD: &'static str = "Runtime.discardConsoleEntries";
    }

    /// Enables reporting of execution contexts creation by means of `executionContextCreated` event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Enable {}

    impl Enable {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for Enable {
        type Response = ();
        const METHOD: &'static str = "Runtime.enable";
    }

    /// Evaluates expression on global object.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Evaluate {
        /// Expression to evaluate.
        expression: String,
        /// Symbolic group name that can be used to release multiple objects.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
        /// Determines whether Command Line API should be available during the evaluation.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeCommandLineAPI")]
        include_command_line_api: Option<bool>,
        /// In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
        #[serde(skip_serializing_if = "Option::is_none")]
        silent: Option<bool>,
        /// Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with `uniqueContextId`, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "contextId")]
        context_id: Option<ExecutionContextId>,
        /// Whether the result is expected to be a JSON object that should be sent by value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnByValue")]
        return_by_value: Option<bool>,
        /// Whether preview should be generated for the result.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
        /// Whether execution should be treated as initiated by user in the UI.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "userGesture")]
        user_gesture: Option<bool>,
        /// Whether execution should `await` for resulting value and return once awaited promise is resolved.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "awaitPromise")]
        await_promise: Option<bool>,
        /// Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies `disableBreaks` below.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "throwOnSideEffect")]
        throw_on_side_effect: Option<bool>,
        /// Terminate execution after timing out (number of milliseconds).
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        timeout: Option<TimeDelta>,
        /// Disable breakpoints during execution.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "disableBreaks")]
        disable_breaks: Option<bool>,
        /// Setting this flag to true enables `let` re-declaration and top-level `await`. Note that `let` variables can only be re-declared if they originate from `replMode` themselves.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "replMode")]
        repl_mode: Option<bool>,
        /// The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "allowUnsafeEvalBlockedByCSP")]
        allow_unsafe_eval_blocked_by_csp: Option<bool>,
        /// An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused across processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation across process boundaries). This is mutually exclusive with `contextId`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "uniqueContextId")]
        unique_context_id: Option<String>,
        /// Specifies the result serialization. If provided, overrides `generatePreview` and `returnByValue`.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "serializationOptions")]
        serialization_options: Option<SerializationOptions>,
    }

    impl Evaluate {
        pub fn new(expression: impl Into<String>) -> Self {
            Self {
                expression: expression.into(),
                object_group: None,
                include_command_line_api: None,
                silent: None,
                context_id: None,
                return_by_value: None,
                generate_preview: None,
                user_gesture: None,
                await_promise: None,
                throw_on_side_effect: None,
                timeout: None,
                disable_breaks: None,
                repl_mode: None,
                allow_unsafe_eval_blocked_by_csp: None,
                unique_context_id: None,
                serialization_options: None,
            }
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }

        pub fn with_include_command_line_api(
            mut self,
            include_command_line_api: impl Into<bool>,
        ) -> Self {
            self.include_command_line_api = Some(include_command_line_api.into());
            self
        }

        pub fn with_silent(mut self, silent: impl Into<bool>) -> Self {
            self.silent = Some(silent.into());
            self
        }

        pub fn with_context_id(mut self, context_id: impl Into<ExecutionContextId>) -> Self {
            self.context_id = Some(context_id.into());
            self
        }

        pub fn with_return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
            self.return_by_value = Some(return_by_value.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }

        pub fn with_user_gesture(mut self, user_gesture: impl Into<bool>) -> Self {
            self.user_gesture = Some(user_gesture.into());
            self
        }

        pub fn with_await_promise(mut self, await_promise: impl Into<bool>) -> Self {
            self.await_promise = Some(await_promise.into());
            self
        }

        pub fn with_throw_on_side_effect(mut self, throw_on_side_effect: impl Into<bool>) -> Self {
            self.throw_on_side_effect = Some(throw_on_side_effect.into());
            self
        }

        pub fn with_timeout(mut self, timeout: impl Into<TimeDelta>) -> Self {
            self.timeout = Some(timeout.into());
            self
        }

        pub fn with_disable_breaks(mut self, disable_breaks: impl Into<bool>) -> Self {
            self.disable_breaks = Some(disable_breaks.into());
            self
        }

        pub fn with_repl_mode(mut self, repl_mode: impl Into<bool>) -> Self {
            self.repl_mode = Some(repl_mode.into());
            self
        }

        pub fn with_allow_unsafe_eval_blocked_by_csp(
            mut self,
            allow_unsafe_eval_blocked_by_csp: impl Into<bool>,
        ) -> Self {
            self.allow_unsafe_eval_blocked_by_csp = Some(allow_unsafe_eval_blocked_by_csp.into());
            self
        }

        pub fn with_unique_context_id(mut self, unique_context_id: impl Into<String>) -> Self {
            self.unique_context_id = Some(unique_context_id.into());
            self
        }

        pub fn with_serialization_options(
            mut self,
            serialization_options: impl Into<SerializationOptions>,
        ) -> Self {
            self.serialization_options = Some(serialization_options.into());
            self
        }
    }

    impl Command for Evaluate {
        type Response = EvaluateResult;
        const METHOD: &'static str = "Runtime.evaluate";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct EvaluateResult {
        /// Evaluation result.
        pub result: RemoteObject,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Returns the isolate id.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetIsolateId {}

    impl GetIsolateId {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetIsolateId {
        type Response = GetIsolateIdResult;
        const METHOD: &'static str = "Runtime.getIsolateId";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetIsolateIdResult {
        /// The isolate id.
        pub id: String,
    }

    /// Returns the JavaScript heap usage. It is the total usage of the corresponding isolate not scoped to a particular Runtime.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHeapUsage {}

    impl GetHeapUsage {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetHeapUsage {
        type Response = GetHeapUsageResult;
        const METHOD: &'static str = "Runtime.getHeapUsage";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetHeapUsageResult {
        /// Used JavaScript heap size in bytes.
        #[serde(rename = "usedSize")]
        pub used_size: f64,
        /// Allocated JavaScript heap size in bytes.
        #[serde(rename = "totalSize")]
        pub total_size: f64,
        /// Used size in bytes in the embedder's garbage-collected heap.
        #[serde(rename = "embedderHeapUsedSize")]
        pub embedder_heap_used_size: f64,
        /// Size in bytes of backing storage for array buffers and external strings.
        #[serde(rename = "backingStorageSize")]
        pub backing_storage_size: f64,
    }

    /// Returns properties of a given object. Object group of the result is inherited from the target object.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetProperties {
        /// Identifier of the object to return properties for.
        #[serde(rename = "objectId")]
        object_id: RemoteObjectId,
        /// If true, returns properties belonging only to the element itself, not to its prototype chain.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "ownProperties")]
        own_properties: Option<bool>,
        /// If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "accessorPropertiesOnly")]
        accessor_properties_only: Option<bool>,
        /// Whether preview should be generated for the results.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
        /// If true, returns non-indexed properties only.
        /// **EXPERIMENTAL**
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "nonIndexedPropertiesOnly")]
        non_indexed_properties_only: Option<bool>,
    }

    impl GetProperties {
        pub fn new(object_id: impl Into<RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
                own_properties: None,
                accessor_properties_only: None,
                generate_preview: None,
                non_indexed_properties_only: None,
            }
        }

        pub fn with_own_properties(mut self, own_properties: impl Into<bool>) -> Self {
            self.own_properties = Some(own_properties.into());
            self
        }

        pub fn with_accessor_properties_only(
            mut self,
            accessor_properties_only: impl Into<bool>,
        ) -> Self {
            self.accessor_properties_only = Some(accessor_properties_only.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }

        pub fn with_non_indexed_properties_only(
            mut self,
            non_indexed_properties_only: impl Into<bool>,
        ) -> Self {
            self.non_indexed_properties_only = Some(non_indexed_properties_only.into());
            self
        }
    }

    impl Command for GetProperties {
        type Response = GetPropertiesResult;
        const METHOD: &'static str = "Runtime.getProperties";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetPropertiesResult {
        /// Object properties.
        pub result: Vec<PropertyDescriptor>,
        /// Internal object properties (only of the element itself).
        #[serde(rename = "internalProperties")]
        pub internal_properties: Option<Vec<InternalPropertyDescriptor>>,
        /// Object private properties.
        /// **EXPERIMENTAL**
        #[serde(rename = "privateProperties")]
        pub private_properties: Option<Vec<PrivatePropertyDescriptor>>,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Returns all let, const and class variables from global scope.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GlobalLexicalScopeNames {
        /// Specifies in which execution context to lookup global scope variables.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<ExecutionContextId>,
    }

    impl GlobalLexicalScopeNames {
        pub fn new() -> Self {
            Self {
                execution_context_id: None,
            }
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }
    }

    impl Command for GlobalLexicalScopeNames {
        type Response = GlobalLexicalScopeNamesResult;
        const METHOD: &'static str = "Runtime.globalLexicalScopeNames";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GlobalLexicalScopeNamesResult {
        pub names: Vec<String>,
    }

    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QueryObjects {
        /// Identifier of the prototype to return objects for.
        #[serde(rename = "prototypeObjectId")]
        prototype_object_id: RemoteObjectId,
        /// Symbolic group name that can be used to release the results.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
    }

    impl QueryObjects {
        pub fn new(prototype_object_id: impl Into<RemoteObjectId>) -> Self {
            Self {
                prototype_object_id: prototype_object_id.into(),
                object_group: None,
            }
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }
    }

    impl Command for QueryObjects {
        type Response = QueryObjectsResult;
        const METHOD: &'static str = "Runtime.queryObjects";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct QueryObjectsResult {
        /// Array with objects.
        pub objects: RemoteObject,
    }

    /// Releases remote object with given id.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReleaseObject {
        /// Identifier of the object to release.
        #[serde(rename = "objectId")]
        object_id: RemoteObjectId,
    }

    impl ReleaseObject {
        pub fn new(object_id: impl Into<RemoteObjectId>) -> Self {
            Self {
                object_id: object_id.into(),
            }
        }
    }

    impl Command for ReleaseObject {
        type Response = ();
        const METHOD: &'static str = "Runtime.releaseObject";
    }

    /// Releases all remote objects that belong to a given group.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ReleaseObjectGroup {
        /// Symbolic object group name.
        #[serde(rename = "objectGroup")]
        object_group: String,
    }

    impl ReleaseObjectGroup {
        pub fn new(object_group: impl Into<String>) -> Self {
            Self {
                object_group: object_group.into(),
            }
        }
    }

    impl Command for ReleaseObjectGroup {
        type Response = ();
        const METHOD: &'static str = "Runtime.releaseObjectGroup";
    }

    /// Tells inspected instance to run if it was waiting for debugger to attach.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RunIfWaitingForDebugger {}

    impl RunIfWaitingForDebugger {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for RunIfWaitingForDebugger {
        type Response = ();
        const METHOD: &'static str = "Runtime.runIfWaitingForDebugger";
    }

    /// Runs script with given id in a given context.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RunScript {
        /// Id of the script to run.
        #[serde(rename = "scriptId")]
        script_id: ScriptId,
        /// Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<ExecutionContextId>,
        /// Symbolic group name that can be used to release multiple objects.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "objectGroup")]
        object_group: Option<String>,
        /// In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
        #[serde(skip_serializing_if = "Option::is_none")]
        silent: Option<bool>,
        /// Determines whether Command Line API should be available during the evaluation.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "includeCommandLineAPI")]
        include_command_line_api: Option<bool>,
        /// Whether the result is expected to be a JSON object which should be sent by value.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "returnByValue")]
        return_by_value: Option<bool>,
        /// Whether preview should be generated for the result.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "generatePreview")]
        generate_preview: Option<bool>,
        /// Whether execution should `await` for resulting value and return once awaited promise is resolved.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "awaitPromise")]
        await_promise: Option<bool>,
    }

    impl RunScript {
        pub fn new(script_id: impl Into<ScriptId>) -> Self {
            Self {
                script_id: script_id.into(),
                execution_context_id: None,
                object_group: None,
                silent: None,
                include_command_line_api: None,
                return_by_value: None,
                generate_preview: None,
                await_promise: None,
            }
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }

        pub fn with_object_group(mut self, object_group: impl Into<String>) -> Self {
            self.object_group = Some(object_group.into());
            self
        }

        pub fn with_silent(mut self, silent: impl Into<bool>) -> Self {
            self.silent = Some(silent.into());
            self
        }

        pub fn with_include_command_line_api(
            mut self,
            include_command_line_api: impl Into<bool>,
        ) -> Self {
            self.include_command_line_api = Some(include_command_line_api.into());
            self
        }

        pub fn with_return_by_value(mut self, return_by_value: impl Into<bool>) -> Self {
            self.return_by_value = Some(return_by_value.into());
            self
        }

        pub fn with_generate_preview(mut self, generate_preview: impl Into<bool>) -> Self {
            self.generate_preview = Some(generate_preview.into());
            self
        }

        pub fn with_await_promise(mut self, await_promise: impl Into<bool>) -> Self {
            self.await_promise = Some(await_promise.into());
            self
        }
    }

    impl Command for RunScript {
        type Response = RunScriptResult;
        const METHOD: &'static str = "Runtime.runScript";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RunScriptResult {
        /// Run result.
        pub result: RemoteObject,
        /// Exception details.
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Enables or disables async call stacks tracking.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetAsyncCallStackDepth {
        /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async call stacks (default).
        #[serde(rename = "maxDepth")]
        max_depth: i64,
    }

    impl SetAsyncCallStackDepth {
        pub fn new(max_depth: impl Into<i64>) -> Self {
            Self {
                max_depth: max_depth.into(),
            }
        }
    }

    impl Command for SetAsyncCallStackDepth {
        type Response = ();
        const METHOD: &'static str = "Runtime.setAsyncCallStackDepth";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetCustomObjectFormatterEnabled {
        enabled: bool,
    }

    impl SetCustomObjectFormatterEnabled {
        pub fn new(enabled: impl Into<bool>) -> Self {
            Self {
                enabled: enabled.into(),
            }
        }
    }

    impl Command for SetCustomObjectFormatterEnabled {
        type Response = ();
        const METHOD: &'static str = "Runtime.setCustomObjectFormatterEnabled";
    }

    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct SetMaxCallStackSizeToCapture {
        size: i64,
    }

    impl SetMaxCallStackSizeToCapture {
        pub fn new(size: impl Into<i64>) -> Self {
            Self { size: size.into() }
        }
    }

    impl Command for SetMaxCallStackSizeToCapture {
        type Response = ();
        const METHOD: &'static str = "Runtime.setMaxCallStackSizeToCapture";
    }

    /// Terminate current or next JavaScript execution. Will cancel the termination when the outer-most script execution ends.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct TerminateExecution {}

    impl TerminateExecution {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for TerminateExecution {
        type Response = ();
        const METHOD: &'static str = "Runtime.terminateExecution";
    }

    /// If executionContextId is empty, adds binding with the given name on the global objects of all inspected contexts, including those created later, bindings survive reloads. Binding function takes exactly one argument, this argument should be string, in case of any other input, function throws an exception. Each binding function call produces Runtime.bindingCalled notification.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct AddBinding {
        name: String,
        /// If specified, the binding would only be exposed to the specified execution context. If omitted and `executionContextName` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with `executionContextName`. Deprecated in favor of `executionContextName` due to an unclear use case and bugs in implementation (crbug.com/1169639). `executionContextId` will be removed in the future.
        /// **EXPERIMENTAL**
        #[deprecated]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextId")]
        execution_context_id: Option<ExecutionContextId>,
        /// If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also `ExecutionContext.name` and `worldName` parameter to `Page.addScriptToEvaluateOnNewDocument`. This parameter is mutually exclusive with `executionContextId`.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(rename = "executionContextName")]
        execution_context_name: Option<String>,
    }

    impl AddBinding {
        pub fn new(name: impl Into<String>) -> Self {
            Self {
                name: name.into(),
                execution_context_id: None,
                execution_context_name: None,
            }
        }

        pub fn with_execution_context_id(
            mut self,
            execution_context_id: impl Into<ExecutionContextId>,
        ) -> Self {
            self.execution_context_id = Some(execution_context_id.into());
            self
        }

        pub fn with_execution_context_name(
            mut self,
            execution_context_name: impl Into<String>,
        ) -> Self {
            self.execution_context_name = Some(execution_context_name.into());
            self
        }
    }

    impl Command for AddBinding {
        type Response = ();
        const METHOD: &'static str = "Runtime.addBinding";
    }

    /// This method does not remove binding function from global object but unsubscribes current runtime agent from Runtime.bindingCalled notifications.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct RemoveBinding {
        name: String,
    }

    impl RemoveBinding {
        pub fn new(name: impl Into<String>) -> Self {
            Self { name: name.into() }
        }
    }

    impl Command for RemoveBinding {
        type Response = ();
        const METHOD: &'static str = "Runtime.removeBinding";
    }

    /// This method tries to lookup and populate exception details for a JavaScript Error object. Note that the stackTrace portion of the resulting exceptionDetails will only be populated if the Runtime domain was enabled at the time when the Error was thrown.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetExceptionDetails {
        /// The error object for which to resolve the exception details.
        #[serde(rename = "errorObjectId")]
        error_object_id: RemoteObjectId,
    }

    impl GetExceptionDetails {
        pub fn new(error_object_id: impl Into<RemoteObjectId>) -> Self {
            Self {
                error_object_id: error_object_id.into(),
            }
        }
    }

    impl Command for GetExceptionDetails {
        type Response = GetExceptionDetailsResult;
        const METHOD: &'static str = "Runtime.getExceptionDetails";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetExceptionDetailsResult {
        #[serde(rename = "exceptionDetails")]
        pub exception_details: Option<ExceptionDetails>,
    }

    /// Notification is issued every time when binding is called.
    /// **EXPERIMENTAL**: This feature is experimental and may change or be removed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct BindingCalled {
        pub name: String,
        pub payload: String,
        /// Identifier of the context where the call was made.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
    }

    impl BindingCalled {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.bindingCalled")
        }
    }

    /// Issued when console API was called.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ConsoleApiCalled {
        /// Type of the call.
        #[serde(rename = "type")]
        pub type_: String,
        /// Call arguments.
        pub args: Vec<RemoteObject>,
        /// Identifier of the context where the call was made.
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
        /// Call timestamp.
        pub timestamp: Timestamp,
        /// Stack trace captured when the call was made. The async stack chain is automatically reported for the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
        #[serde(rename = "stackTrace")]
        pub stack_trace: Option<StackTrace>,
        /// Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
        /// **EXPERIMENTAL**
        pub context: Option<String>,
    }

    impl ConsoleApiCalled {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.consoleAPICalled")
        }
    }

    /// Issued when unhandled exception was revoked.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExceptionRevoked {
        /// Reason describing why exception was revoked.
        pub reason: String,
        /// The id of revoked exception, as reported in `exceptionThrown`.
        #[serde(rename = "exceptionId")]
        pub exception_id: i64,
    }

    impl ExceptionRevoked {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.exceptionRevoked")
        }
    }

    /// Issued when exception was thrown and unhandled.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExceptionThrown {
        /// Timestamp of the exception.
        pub timestamp: Timestamp,
        #[serde(rename = "exceptionDetails")]
        pub exception_details: ExceptionDetails,
    }

    impl ExceptionThrown {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.exceptionThrown")
        }
    }

    /// Issued when new execution context is created.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExecutionContextCreated {
        /// A newly created execution context.
        pub context: ExecutionContextDescription,
    }

    impl ExecutionContextCreated {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.executionContextCreated")
        }
    }

    /// Issued when execution context is destroyed.
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExecutionContextDestroyed {
        /// Id of the destroyed context
        #[deprecated]
        #[serde(rename = "executionContextId")]
        pub execution_context_id: ExecutionContextId,
        /// Unique Id of the destroyed context
        /// **EXPERIMENTAL**
        #[serde(rename = "executionContextUniqueId")]
        pub execution_context_unique_id: String,
    }

    impl ExecutionContextDestroyed {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.executionContextDestroyed")
        }
    }

    /// Issued when all executionContexts were cleared in browser
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct ExecutionContextsCleared {}

    impl ExecutionContextsCleared {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.executionContextsCleared")
        }
    }

    /// Issued when object should be inspected (for example, as a result of inspect() command line API call).
    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InspectRequested {
        pub object: RemoteObject,
        pub hints: serde_json::Value,
        /// Identifier of the context where the call was made.
        /// **EXPERIMENTAL**
        #[serde(rename = "executionContextId")]
        pub execution_context_id: Option<ExecutionContextId>,
    }

    impl InspectRequested {
        pub fn subscribe(
            cdp: &CDP,
        ) -> std::pin::Pin<Box<dyn futures::stream::Stream<Item = Self> + Send>> {
            cdp.inner.event_stream("Runtime.inspectRequested")
        }
    }
}

pub mod schema {
    use super::*;

    /// Description of the protocol domain.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct Domain {
        /// Domain name.
        pub name: String,
        /// Domain version.
        pub version: String,
    }

    /// Returns supported domains.
    #[derive(Debug, Clone, Serialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomains {}

    impl GetDomains {
        pub fn new() -> Self {
            Self {}
        }
    }

    impl Command for GetDomains {
        type Response = GetDomainsResult;
        const METHOD: &'static str = "Schema.getDomains";
    }

    #[derive(Debug, Clone, Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct GetDomainsResult {
        /// List of supported domains.
        pub domains: Vec<Domain>,
    }
}

/// Common type conversions
///
/// Note: Since RequestId types are type aliases to String,
/// they can be used interchangeably without explicit conversion.
pub mod conversions {
    use super::*;

    /// Convert between RequestId types from different domains.
    ///
    /// Since they are all String aliases, this is a no-op but provides type clarity.
    ///
    /// Available RequestId types:
    /// - `device_access::RequestId`
    /// - `fetch::RequestId`
    /// - `network::RequestId`
    #[inline]
    pub fn convert_request_id<T: Into<String>>(id: T) -> String {
        id.into()
    }
}
